{"meta":{"title":"理想热爱","subtitle":"理想热爱","description":"湖南工业大学 | 计算机科学与技术","author":"廖兴旺","url":"https://liaoxingwang.github.io","root":"/"},"pages":[{"title":"404","date":"2022-11-19T09:20:10.000Z","updated":"2024-12-19T06:53:09.535Z","comments":true,"path":"404.html","permalink":"https://liaoxingwang.github.io/404.html","excerpt":"","text":""},{"title":"放松一下","date":"2022-11-19T09:20:10.000Z","updated":"2024-12-19T06:53:09.536Z","comments":true,"path":"AV/index.html","permalink":"https://liaoxingwang.github.io/AV/index.html","excerpt":"","text":"影音资源共享 这里准备用来分享各类好玩的资源 待更新……"},{"title":"about","date":"2022-11-19T09:20:10.000Z","updated":"2024-12-19T06:53:09.548Z","comments":true,"path":"about/index.html","permalink":"https://liaoxingwang.github.io/about/index.html","excerpt":"","text":"公众号: 理想热爱 教育经历 本科 计算机科学与技术湖南工业大学 获得荣誉 待更…… 联系方式 电子邮箱807928930@qq.com 地址广东省深圳市南山区南新路康乐村小区，邮编518000 QQ807928930"},{"title":"archives","date":"2022-11-19T09:20:10.000Z","updated":"2024-12-19T06:53:09.548Z","comments":true,"path":"archives/index.html","permalink":"https://liaoxingwang.github.io/archives/index.html","excerpt":"","text":""},{"title":"friends","date":"2022-11-19T09:20:10.000Z","updated":"2024-12-19T06:53:09.550Z","comments":true,"path":"friends/index.html","permalink":"https://liaoxingwang.github.io/friends/index.html","excerpt":"","text":""},{"title":"contact","date":"2022-11-19T09:20:10.000Z","updated":"2024-12-19T06:53:09.550Z","comments":true,"path":"contact/index.html","permalink":"https://liaoxingwang.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 理想热爱信息 博客名称: 理想热爱 博客网址: https://gls666.gitee.io/ 博客头像: http://sunhwee.com/hwsun.jpg 博客介绍: Java开发工程师 整包服务"},{"title":"categories","date":"2022-11-19T09:20:10.000Z","updated":"2024-12-19T06:53:09.549Z","comments":true,"path":"categories/index.html","permalink":"https://liaoxingwang.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-11-19T09:20:10.000Z","updated":"2024-12-19T06:53:09.552Z","comments":true,"path":"tags/index.html","permalink":"https://liaoxingwang.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2024-12-19T06:53:09.551Z","updated":"2024-12-19T06:53:09.551Z","comments":true,"path":"galleries/index.html","permalink":"https://liaoxingwang.github.io/galleries/index.html","excerpt":"","text":""},{"title":"背景图片3","date":"2024-12-19T06:53:09.551Z","updated":"2024-12-19T06:53:09.551Z","comments":true,"path":"galleries/背景图片3/index.html","permalink":"https://liaoxingwang.github.io/galleries/背景图片3/index.html","excerpt":"","text":""},{"title":"背景图片4","date":"2024-12-19T06:53:09.552Z","updated":"2024-12-19T06:53:09.552Z","comments":true,"path":"galleries/背景图片4/index.html","permalink":"https://liaoxingwang.github.io/galleries/背景图片4/index.html","excerpt":"","text":""}],"posts":[{"title":"java笔记","slug":"Blog-Open-Source-JavaNote","date":"2024-12-20T21:20:00.000Z","updated":"2024-12-21T03:41:10.415Z","comments":true,"path":"2024/12/21/blog-open-source-javanote/","link":"","permalink":"https://liaoxingwang.github.io/2024/12/21/blog-open-source-javanote/","excerpt":"","text":"java笔记说说进程和线程的区别？进程是程序的一次执行，是系统进行资源分配和调度的独立单位，他的作用是是程序能够并发执行提高资源利用率和吞吐率。 由于进程是资源分配和调度的基本单位，因为进程的创建、销毁、切换产生大量的时间和空间的开销，进程的数量不能太多，而线程是比进程更小的能独立运行的基本单位，他是进程的一个实体，可以减少程序并发执行时的时间和空间开销，使得操作系统具有更好的并发性。 线程基本不拥有系统资源，只有一些运行时必不可少的资源，比如程序计数器、寄存器和栈，进程则占有堆、栈。 操作系统的线程状态：新建、就绪、运行、阻塞、终止 java的线程状态：新建、运行、阻塞、等待、超时等待、终止 1、重载和重写的区别重载： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。 重写： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。 2、static 关键字是干什么用的？谈谈你的理解static 是 Java 中非常重要的关键字，static 表示的概念是 静态的，在 Java 中，static 主要用来 修饰变量，static 修饰的变量称为静态变量、也称为类变量，类变量属于类所有，对于不同的类来说，static 变量只有一份，static 修饰的变量位于方法区中；static 修饰的变量能够直接通过 类名.变量名 来进行访问，不用通过实例化类再进行使用。 修饰方法，static 修饰的方法被称为静态方法，静态方法能够直接通过 类名.方法名来使用，在静态方法内部不能使用非静态属性和方法 static 可以修饰代码块，主要分为两种，一种直接定义在类中，使用 static{}，这种被称为静态代码块，一种是在类中定义静态内部类，使用 static class xxx 来进行定义。 static 可以用于静态导包，通过使用 import static xxx 来实现，这种方式一般不推荐使用 static 可以和单例模式一起使用，通过双重检查锁来实现线程安全的单例模式。 final 关键字是干什么用的？谈谈你的理解final 是 Java 中的关键字，它表示的意思是 不可变的，在 Java 中，final 主要用来 修饰类，final 修饰的类不能被继承，不能被继承的意思就是不能使用 extends 来继承被 final 修饰的类。 修饰变量，final 修饰的变量不能被改写，不能被改写的意思有两种，对于基本数据类型来说，final 修饰的变量，其值不能被改变，final 修饰的对象，对象的引用不能被改变，但是对象内部的属性可以被修改。final 修饰的变量在某种程度上起到了不可变的效果，所以，可以用来保护只读数据，尤其是在并发编程中，因为明确的不能再为 final 变量进行赋值，有利于减少额外的同步开销。 修饰方法，final 修饰的方法不能被重写。 2、StringBuild和StringBuffer还有String他们的无参构造器的初始容量都为16，有参的为参数长度加上16。 StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。每次 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。 对于三者使用的总结： 操作少量的数据 ： String 单线程操作字符串缓冲区下操作大量数据 ：StringBuilder 多线程操作字符串缓冲区下操作大量数据 ：StringBuffer String的equals源码 3、接口和抽象类的区别是什么 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），抽象类可以有非抽象的方法 接口中的实例变量默认是 final 类型的，而抽象类中则不一定 一个类可以实现多个接口，但最多只能实现一个抽象类 一个类实现接口的话要实现接口的所有方法，而抽象类不一定 接口不能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。 6、ArrayList实现了RandomAccess接口（关于随机访问）、Cloneable接口、Serializable（关于序列化和反序列化）、继承了AbstractList抽象类ArrayList的无参构造器为一个空数组 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; 此时整个数组里面是没有数据的，但是容量是initialCapacity的，如果执行add(int index, E element)和set(int index, E element)方法时会报错数组越界。ArrayList的默认初始化容量为10，jdk1.7的时候初始化默认为10，但是jdk1.8之后，默认为空，只有第一次添加数据的时候会判断当前是否有容量，否则初始化容量为10 ArrayList的add过程 初始容量：当创建一个 ArrayList 对象时，如果没有指定初始容量大小，则其初始容量为 10。 添加元素：当向 ArrayList 中添加元素时，ArrayList 会先检查当前元素个数是否达到了数组的长度，如果达到了就需要进行扩容。 计算新容量：扩容时，ArrayList 会计算新的容量大小。先获取当前容器的长度，扩大到之前容器的1.5倍，然后回去检查容器是否合适，如果当前容器小了，容器大小直接为当前的值，当前容器容量超过数组最大容量，newCapacity = (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE来扩容 创建新数组：ArrayList 将创建一个新的数组，其长度为新容量大小。 数据复制：ArrayList 将原来数组中的元素复制到新数组中。 更新引用：ArrayList 更新内部引用，使其指向新的数组。 添加新元素：最后，ArrayList 将新的元素添加到新数组中。 ArrayList的移除方法是先检查当前index是否合法，将当前index+1以及后面的元素进行复制后，往前移动一个下标覆盖之前的数据，然后设置将数组最后一个元素设置为null，并且size-1 ArrayList的添加方法：先去检查index的合法性，检查容器是否需要初始化和扩容等，然后将index位置以及之后的数据移动到index+1的位置上，留出index的位置，将元素放到index的位置上 关于Arrays.asList()方法是生成的一个内部的java.util.Arrays.ArrayList，不是java.util.ArrayList，这个要注意，它不具备添加和删除的方法。 为什么不是线程安全的，具体来说是哪里不安全？（源码层面，没答上来）在高并发添加数据下，ArrayList会暴露三个问题; 部分值为null（我们并没有add null进去） 索引越界异常 size与我们add的数量不符 下面我们来分析三种情况都是如何产生的： 部分值为null：当线程1走到了扩容那里发现当前size是9，而数组容量是10，所以不用扩容，这时候cpu让出执行权，线程2也进来了，发现size是9，而数组容量是10，所以不用扩容，这时候线程1继续执行，将数组下标索引为9的位置set值了，还没有来得及执行size++，这时候线程2也来执行了，又把数组下标索引为9的位置set了一遍，这时候两个先后进行size++，导致下标索引10的地方就为null了。 索引越界异常：线程1走到扩容那里发现当前size是9，数组容量是10不用扩容，cpu让出执行权，线程2也发现不用扩容，这时候数组的容量就是10，而线程1 set完之后size++，这时候线程2再进来size就是10，数组的大小只有10，而你要设置下标索引为10的就会越界（数组的下标索引从0开始）； size与我们add的数量不符：这个基本上每次都会发生，这个理解起来也很简单，因为size++本身就不是原子操作，可以分为三步：获取size的值，将size的值加1，将新的size值覆盖掉原来的，线程1和线程2拿到一样的size值加完了同时覆盖，就会导致一次没有加上，所以肯定不会与我们add的数量保持一致的； 7、HashMap（继承AbstractMap抽象类，实现了Map, Cloneable, Serializable）初始化的时候会根据传入的数值计算一个比传入值大的第一个2次幂的值,然后将这个值作为HashMap的容量 默认容量为16负载因子为0.75负载因子是0.75的时候，空间利用率比较高，而且避免了相当多的Hash冲突，使得底层的链表或者是红黑树的高度比较低，提升了空间效率。扩容条件 当前数据存储量达到总容量乘以负载因子时，就会发生扩容 HashMap的Put方法：1.8之前是头插法，1.8之后使用尾插法 public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V>[] tab; Node&lt;K,V> p; int n, i; //第一次put元素时，table数组为空，先调用resize生成一个指定容量的数组 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //hash值和n-1的与运算结果为桶的位置，如果该位置空就直接放置一个Node if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); //如果计算出的bucket不空，即发生哈希冲突，就要进一步判断 else { Node&lt;K,V> e; K k; //判断当前Node的key与要put的key是否相等,如果相等，直接覆盖 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //判断当前Node是否是红黑树的节点 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V>)p).putTreeVal(this, tab, hash, key, value); //以上都不是，说明要new一个Node，加入到链表中 else { for (int binCount = 0; ; ++binCount) { //在链表尾部插入新节点，注意jdk1.8是在链表尾部插入新节点 if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); // 如果当前链表中的元素大于树化的阈值，进行链表转树的操作 if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } //在链表中继续判断是否已经存在完全相同的key if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; } } //走到这里，说明本次put是更新一个已存在的键值对的value if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; //在hashMap中，afterNodeAccess方法体为空，交给子类去实现 afterNodeAccess(e); return oldValue; } } ++modCount; //如果当前size超过临界值，就扩容。注意是先插入节点再扩容 if (++size > threshold) resize(); //在hashMap中，afterNodeInsertion方法体为空，交给子类去实现 afterNodeInsertion(evict); return null; } HashMap的hash计算方法:将hashCode无符号右移16位后，让高16位和低16位进行异或运算，减少hash碰撞，实现均匀分布。 说说你对红黑树的见解？每个节点非红即黑根节点总是黑色的如果节点是红色的，则它的子节点必须是黑色的（反之不一定）每个叶子节点都是黑色的空节点（NIL节点）从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度） 8、HashMap 和 HashTable 有什么区别？ HashMap 是线程不安全的，HashTable 是线程安全的；HashTable里面所有方法使用Synchronized的修饰，导致HashTable的效率比不上HashMap HashMap最多只允许一条记录的键为null，允许多条记录的值为null，而 HashTable不允许；concurrentHashMap也不允许key和value为null。 HashMap 默认初始化数组的大小为16，HashTable 为 11，前者扩容时，扩大两倍，后者扩大两倍+1； HashMap 需要重新计算 hash 值，而 HashTable 直接使用对象的 hashCode 实现方式不同：HashTable继承Dictionary类，HashMap继承的是AbstractMap类 迭代器不同：HashMap中的迭代器是Iterator（快速失败机制）的,，而HashTable的是Enumerator（安全失败） HashMap在1.8后有引入红黑树，但是HashTable没有 HashMap1.7和1.8的区别底层结构：hashmap1.7底层结构是entry数组+链表， hashmap1.8底层结构是node数组+链表+红黑树扩容策略：7上8下(7前8后)1.8会保持原链表的顺序并且在元素插入后检测是否需要扩容，扩容后，不会把所有元素重新计算一遍位置； 1.7会颠倒链表的顺序并且在元素插入前检测是否需要扩容，扩容后，把所有元素重新计算一遍位置，为了降低hash冲突； 在JDK1.7的时候是直接用hash值和需要扩容的二进制数进行&amp;（这里就是为什么扩容的时候为啥一定必须是2的多少次幂的原因所在，因为如果只有2的n次幂的情况时最后一位二进制数才一定是1，这样能最大程度减少hash碰撞）（hash值 &amp; length-1） 而在JDK1.8的时候直接用了JDK1.7的时候计算的规律，也就是扩容前的原始位置+扩容的大小值=JDK1.8的计算方式，而不再是JDK1.7的那种异或的方法。但是这种方式就相当于只需要判断Hash值的新增参与运算的位是0还是1就直接迅速计算出了扩容后的储存方式。 9、关于Iterator和Enumeration两者都是迭代器接口，都是关于比遍历集合的 Iterator包含hasNext()、next()、remov()、forEachRemaining()四个方法，支持对集合的遍历以及删除，支持fail-fast enumeration包含hasMoreElements()、nextElement()，只支持对集合的变量，不支持对集合进行删除操作。 10. 快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？快速失败 在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。安全失败 采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。 其实，在java.util.concurrent 并发包的集合，如 ConcurrentHashMap, CopyOnWriteArrayList等，默认为都是安全失败的。 11、Java创建对象的方式 通过new的方式 通过反射 通过clone机制 通过反序列化 12、Java中的异常体系Java中的所有异常都来自顶级父类Throwable。Throwable下有两个子类Exception和Error。 Error是程序无法处理的错误，一旦出现这个错误，则程序将被迫停止运行。 Exception不会导致程序停止，又分为两个部分Unchecked Exception（非受检异常）和CheckedException（受检异常）。 Checked Exception（受检异常）：这种异常在编译时就可以被检测出来，必须要在代码中进行处理或者声明抛出，否则编译不通过。这类异常主要是由程序的外部环境引起的，例如文件不存在、网络连接失败等。常见的Checked Exception包括IOException、SQLException等。 Unchecked Exception（非受检异常）：这种异常通常是由程序内部错误引起的包括RuntimeException以及其子类，例如NullPointerException、ArrayIndexOutOfBoundsException、IllegalArgumentException等。这类异常不需要在代码中声明抛出，也可以不进行处理，但是如果不进行处理，程序会崩溃。 13. Collections.sort和Arrays.sort的实现原理Collection.sort是对list进行排序，Arrays.sort是对数组进行排序。因此，Collections.sort方法底层就是调用的Array.sort方法 Arrays的sort方法，如下： 如果比较器为null，进入sort（a）方法。如下： 因此，Arrays的sort方法底层就是： legacyMergeSort(a)，归并排序， ComparableTimSort.sort()：即Timsort排序。 Timesort排序 Timsort排序是结合了合并排序（merge.sort）和插入排序（insertion sort）而得出的排序方法； 1.当数组长度小于某个值，采用的是二分插入排序算法，如下： 找到各个run，并入栈。 按规则合并run。 14. TreeMap底层？ TreeMap实现了SotredMap接口，它是有序的集合。 TreeMap底层数据结构是一个红黑树，每个key-value都作为一个红黑树的节点。 如果在调用TreeMap的构造函数时没有指定比较器，则根据key执行自然排序。 15. Iterator 和 ListIterator 有什么区别？ ListIterator 比 Iterator有更多的方法。 ListIterator只能用于遍历List及其子类，Iterator可用来遍历所有集合， ListIterator遍历可以是逆向的，因为有previous()和hasPrevious()方法，而Iterator不可以。 ListIterator有add()方法，可以向List添加对象，而Iterator却不能。 ListIterator可以定位当前的索引位置，因为有nextIndex()和previousIndex()方法，而Iterator不可以。 ListIterator可以实现对象的修改，set()方法可以实现。Iterator仅能遍历，不能修改哦。 16. 怎么确保一个集合不能被修改？ unmodifiableMap unmodifiableList unmodifiableSet 17.Java中类的比较和排序方法使用Comparable接口 Comparable接口定义了compareTo方法，用于对象之间的比较 使用Comparator接口 Comparator可以用于比较没有实现Comparable的类的对象，Comparator的compare方法用来告诉代码应该怎么去比较两个实例，然后根据比较结果进行排序 18. 多线程创建的方式 继承Thread类创建线程 实现Runnable接口创建线程 实现Callable接口通过FutureTask包装器来创建Thread线程 使用ExecutorService、Callable、Future实现有返回结果的线程 23. 什么是Java优先级队列(Priority Queue)？优先队列PriorityQueue是Queue接口的实现，可以对其中元素进行排序 优先队列中元素默认排列顺序是升序排列 但对于自己定义的类来说，需要自己定义比较器 public class PriorityQueue&lt;E> extends AbstractQueue&lt;E> implements java.io.Serializable { ... private final Comparator&lt;? super E> comparator; 方法： peek()//返回队首元素poll()//返回队首元素，队首元素出队列add()//添加元素size()//返回队列元素个数isEmpty()//判断队列是否为空，为空返回true,不空返回false特点： 1.基于优先级堆 2.不允许null值 3.线程不安全 4.出入队时间复杂度O(log(n)) 5.调用remove()返回堆内最小值 24. JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。jdk8 放弃了分段锁而是用了Node锁，减低锁的粒度，提高性能，并使用CAS操作来确保Node的一些操作的原子性，取代了锁。 25. 阻塞队列的实现，ArrayBlockingQueue的底层实现？ArrayBlockingQueue是数组实现的线程安全的有界的阻塞队列，继承自AbstractBlockingQueue,间接的实现了Queue接口和Collection接口。底层以数组的形式保存数据(实际上可看作一个循环数组)。常用的操作包括 add ,offer,put，remove,poll,take,peek。 29. ConcurrenHashMap 原理？1.8 中为什么要用红黑树？聊到ConcurrenHashMap，需要跟面试官聊到安全性，分段锁segment，为什么放弃了分段锁，与及选择CAS，其实就是都是从效率和安全性触发，嘻嘻~ java8不是用红黑树来管理hashmap,而是在hash值相同的情况下(且重复数量大于8),用红黑树来管理数据。红黑树相当于排序数据。可以自动的使用二分法进行定位。性能较高。35. 说一下HashSet的实现原理？ 不能保证元素的排列顺序，顺序有可能发生变化。 元素可以为null hashset保证元素不重复~ （这个面试官很可能会问什么原理，这个跟HashMap有关的哦） HashSet，需要谈谈它俩hashcode()和equles()哦~ 实际是基于HashMap实现的，HashSet 底层使用HashMap来保存所有元素的看看它的add方法吧~ public boolean add(E e) { return map.put(e, PRESENT)==null; } 39. 讲讲红黑树的特点？ 每个节点或者是黑色，或者是红色。 根节点是黑色。 每个叶子节点（NIL）是黑色。[注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！] 如果一个节点是红色的，则它的子节点必须是黑色的。 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 41.谈谈线程池阻塞队列吧~ ArrayBlockingQueue LinkedBlockingQueue DelayQueue PriorityBlockingQueue SynchronousQueue ArrayBlockingQueue： （有界队列）是一个用数组实现的有界阻塞队列，按FIFO排序量。 LinkedBlockingQueue： （可设置容量队列）基于链表结构的阻塞队列，按FIFO排序任务，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE，吞吐量通常要高于ArrayBlockingQuene；newFixedThreadPool线程池使用了这个队列 DelayQueue：（延迟队列）是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序。newScheduledThreadPool线程池使用了这个队列。 PriorityBlockingQueue：（优先级队列）是具有优先级的无界阻塞队列； SynchronousQueue：（同步队列）一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene，newCachedThreadPool线程池使用了这个队列。针对面试题：线程池都有哪几种工作队列？ 我觉得，回答以上几种ArrayBlockingQueue，LinkedBlockingQueue，SynchronousQueue等，说出它们的特点，并结合使用到对应队列的常用线程池(如newFixedThreadPool线程池使用LinkedBlockingQueue)，进行展开阐述， 就可以啦。 Class类的getDeclaredFields()方法与getFields()的区别?getDeclaredFields():可以获取所有本类自己声明的方法,不能获取继承的方法getFields():只能获取所有public声明的方法,包括继承的方法 静态代码、非静态代码、构造方法的执行顺序public class HelloA { //构造方法 public HelloA() { System.out.println(\"Hello A!父类构造方法\"); } //非静态代码块 { System.out.println(\"i'm A class.父类非静态代码块\"); } //静态代码块 static { System.out.println(\"static A 父类静态代码块\"); } } public class HelloB extends HelloA { //构造方法 public HelloB() { System.out.println(\"Hello B! 构造方法\"); } //非静态代码块 { System.out.println(\"i'm B class.非静态代码块\"); } //静态代码块 static { System.out.println(\"static B 静态代码块\"); } public static void main(String[] args) { System.out.println(\"---start---\"); new HelloB(); System.out.println(\"---end---\"); } } 上面是执行一次new HelloB方法，执行结果是：static A 父类静态代码块static B 静态代码块—start—i’m A class.父类非静态代码块HelloA!父类构造方法i’m B class.非静态代码块HelloB! 构造方法—end— 面试时new HelloB方法使执行两次的，执行两次的话，结果为：static A 父类静态代码块static B 静态代码块—start—i’m A class.父类非静态代码块HelloA!父类构造方法i’m B class.非静态代码块HelloB! 构造方法i’m A class.父类非静态代码块HelloA!父类构造方法i’m B class.非静态代码块HelloB! 构造方法 transient的作用阻止实例中那些用此关键字修饰的的变量序列化； 当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。 transient 只能修饰变量，不能修饰类和方法。 java的深拷贝和浅拷贝浅拷贝定义被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。即对象的浅拷贝会对“主”对象进行拷贝，但不会复制主对象里面的对象。”里面的对象“会在原来的对象和它的副本之间共享。 深拷贝深拷贝是一个整个独立的对象拷贝，深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。 参考链接 实现深拷贝的两种方法 clone() 方法麻烦一些，需要将所有涉及到的类实现声明式接口 Cloneable，并覆盖Object类中的clone()方法，并设置作用域为public（这是为了其他类可以使用到该clone方法）。 序列化的方法简单，需要将所有涉及到的类实现接口Serializable jdbc中主要使用桥接模式关于物理分页还是内存分页 物理分页指sql中拼接好分页条件，分页的功能由sql提供。 内存分页表示程序一次性把数据库的数据全部取出来，然后由程序进行分页获取分页数据。 toString()、String.valueOf()、(String)强转区别1、toString()，可能会抛空指针异常在这种使用方法中，因为java.lang.Object类里已有public方法.toString()，所以java对象都可以调用此方法。但在使用时要注意，必须保证object不是null值，否则将抛出NullPointerException异常。采用这种方法时，通常派生类会覆盖Object里的toString()方法。 2、String.valueOf()，推荐使用，返回字符串“null”String.valueOf()方法是小编推荐使用的，因为它不会出现空指针异常，而且是静态的方法，直接通过String调用即可，只是有一点需要注意，就是上面提到的，如果为null，String.valueOf()返回结果是字符串“null”。而不是null。 3、(String)强转，不推荐使用（String）是标准的类型转换，将Object类型转为String类型，使用(String)强转时，最好使用instanceof做一个类型检查，以判断是否可以进行强转，否则容易抛出ClassCastException异常。需要注意的是编写的时候，编译器并不会提示有语法错误，所以这个方法要谨慎的使用。 Integer的范围为[-128,127]Java是值传递参考链接https://blog.csdn.net/pcwl1206/article/details/86550268?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-5.pc_relevant_default&amp;spm=1001.2101.3001.4242.4&amp;utm_relevant_index=8 比如经过Hash函数计算后， 7和 8会有相同的Hash值，对此Java的HashMap对象采用的是“链地址法”的解决方案。效果如下图所示 具体的做法是，为所有Hash值是 i的对象建立一个同义词链表。假设我们在放入 8的时候，发现 4号位置已经被占，那么就会新建一个链表结点放入 8。同样，如果我们要找 8，那么发现 4号索引里不是 8，那会沿着链表依次查找。 虽然我们还是无法彻底避免Hash值冲突的问题，但是Hash函数设计合理，仍能保证同义词链表的长度被控制在一个合理的范围里。 Object类所有方法详解Object中含有： registerNatives()、getClass()、hashCode()、equals()、clone()、toString()、notify()、notifyAll()、wait(long)、wait(long,int)、wait()、finalize() 共十二个方法。这个顺序是按照 Object类中定义方法的顺序列举的，下面我也会按照这个顺序依次进行讲解。 registerNatives() 从名字上理解，这个方法是注册 native方法（本地方法，由 JVM实现，底层是 C/C++实现的）向谁注册呢？当然是向 JVM，当有程序调用到 native方法时， JVM才好去找到这些底层的方法进行调用。 Object中的 native方法，并使用 registerNatives()向 JVM进行注册。（这属于 JNI的范畴，有兴趣的可自行查阅。） 为什么要使用静态方法，还要放到静态块中呢？ 我们知道了在类初始化的时候，会依次从父类到本类的类变量及类初始化块中的类变量及方法按照定义顺序放到 &lt; clinit&gt;方法中，这样可以保证父类的类变量及方法的初始化一定先于子类。所以当子类调用相应 native方法，比如计算 hashCode时，一定可以保证能够调用到 JVM的 native方法。 getClass() public final native Class getClass();这是一个 public的方法，我们可以直接通过对象调用。 类加载的第一阶段类的加载就是将 .class文件加载到内存，并生成一个 java.lang.Class对象的过程。 getClass()方法就是获取这个对象，这是当前类的对象在运行时类的所有信息的集合。这个方法是反射三种方式之一。 hashCode() public native int hashCode(); 这是一个 public的方法，所以子类可以重写它。这个方法返回当前对象的 hashCode值，这个值是一个整数范围内的 （-2^31~2^31-1）数字。 对于 hashCode有以下几点约束: 在 Java应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改； 如果两个对象 x.equals(y) 方法返回 true，则 x、 y这两个对象的 hashCode必须相等。 如果两个对象 x.equals(y) 方法返回 false，则 x、 y这两个对象的 hashCode可以相等也可以不等。但是，为不相等的对象生成不同整数结果可以提高哈希表的性能。 默认的 hashCode是将内存地址转换为的 hash值，重写过后就是自定义的计算方式；也可以通过 System.identityHashCode(Object)来返回原本的 hashCode。 public class HashCodeTest { private int age; private String name; @Override public int hashCode() { Object[] a = Stream.of(age, name).toArray(); int result = 1; for (Object element : a) { result = 31 * result + (element == null ? 0 : element.hashCode()); } return result; }}推荐使用 Objects.hash(Object…values)方法。相信看源码的时候，都看到计算 hashCode都使用了 31作为基础乘数，为什么使用 31呢？我比较赞同与理解 result*31=(result&lt;&lt;5)-result。 JVM底层可以自动做优化为位运算，效率很高；还有因为 31计算的 hashCode冲突较少，利于 hash桶位的分布。 equals() public boolean equals(Object obj);用于比较当前对象与目标对象是否相等，默认是比较引用是否指向同一对象。为 public方法，子类可重写。 public class Object{ public boolean equals(Object obj) { return (this == obj); }} 为什么需要重写 equals方法？ 因为如果不重写equals方法，当将自定义对象放到 map或者 set中时；如果这时两个对象的 hashCode相同，就会调用 equals方法进行比较，这个时候会调用 Object中默认的 equals方法，而默认的 equals方法只是比较了两个对象的引用是否指向了同一个对象，显然大多数时候都不会指向，这样就会将重复对象存入 map或者 set中。这就破坏了 map与 set不能存储重复对象的特性，会造成内存溢出。 重写 equals方法的几条约定： 自反性：即 x.equals(x)返回 true， x不为 null； 对称性：即 x.equals(y)与 y.equals(x）的结果相同， x与 y不为 null； 传递性：即 x.equals(y)结果为 true, y.equals(z)结果为 true，则 x.equals(z)结果也必须为 true； 一致性：即 x.equals(y)返回 true或 false，在未更改 equals方法使用的参数条件下，多次调用返回的结果也必须一致。 x与 y不为 null。 如果 x不为 null, x.equals(null)返回 false。 clone() protected native Object clone() throws CloneNotSupportedException;此方法返回当前对象的一个副本。 这是一个 protected方法，提供给子类重写。但需要实现 Cloneable接口，这是一个标记接口，如果没有实现，当调用 object.clone()方法，会抛出 CloneNotSupportedException。 public class CloneTest implements Cloneable { private int age; private String name; //省略get、set、构造函数等 @Override protected CloneTest clone() throws CloneNotSupportedException { return (CloneTest) super.clone(); } public static void main(String[] args) throws CloneNotSupportedException { CloneTest cloneTest = new CloneTest(23, &quot;XX&quot;); CloneTest clone = cloneTest.clone(); System.out.println(clone == cloneTest); System.out.println(cloneTest.getAge()==clone.getAge()); System.out.println(cloneTest.getName()==clone.getName()); }}//输出结果//false//true//true从输出我们看见， clone的对象是一个新的对象；但原对象与 clone对象的 String类型的 name却是同一个引用，这表明， super.clone方法对成员变量如果是引用类型，进行是浅拷贝。 那如果我们要进行深拷贝怎么办呢？ 答案是：如果成员变量是引用类型，想实现深拷贝，则成员变量也要实现 Cloneable接口，重写 clone方法。 toString() public String toString()；这是一个 public方法，子类可重写，建议所有子类都重写 toString方法，默认的 toString方法，只是将当前类的全限定性类名 +@+十六进制的 hashCode值。 我们思考一下为什么需要toString方法？ 可以这么理解：返回当前对象的字符串表示，可以将其打印方便查看对象的信息，方便记录日志信息提供调试。我们可以选择需要表示的重要信息重写到 toString方法中。 wait()/ wait(long)/ wait(long,int) 这三个方法是用来线程间通信用的，作用是阻塞当前线程，等待其他线程调用 notify()/notifyAll()方法将其唤醒。这些方法都是 publicfinal的，不可被重写。 注意： 此方法只能在当前线程获取到对象的锁监视器之后才能调用，否则会抛出 IllegalMonitorStateException异常。 调用 wait方法，线程会将锁监视器进行释放；而 Thread.sleep，Thread.yield()并不会释放锁。 wait方法会一直阻塞，直到其他线程调用当前对象的 notify()/notifyAll()方法将其唤醒；而 wait(long)是等待给定超时时间内（单位毫秒），如果还没有调用 notify()/nofiyAll()会自动唤醒； wait(long,int)如果第二个参数大于 0并且小于 999999，则第一个参数 +1作为超时时间； notify()/notifyAll() 前面说了，如果当前线程获得了当前对象锁，调用 wait方法，将锁释放并阻塞；这时另一个线程获取到了此对象锁，并调用此对象的 notify()/notifyAll()方法将之前的线程唤醒。这些方法都是 public final的，不可被重写。 public final native void notify(); 随机唤醒之前在当前对象上调用 wait方法的一个线程 public final native void notifyAll(); 唤醒所有之前在当前对象上调用 wait方法的线程 注意：调用 notify()后，阻塞线程被唤醒，可以参与锁的竞争，但可能调用 notify()方法的线程还要继续做其他事，锁并未释放，所以我们看到的结果是，无论 notify()是在方法一开始调用，还是最后调用，阻塞线程都要等待当前线程结束才能开始。 为什么 wait()/notify()方法要放到 Object中呢？ 因为每个对象都可以成为锁监视器对象，所以放到 Object中，可以直接使用。 finalize() protected void finalize() throws Throwable ;此方法是在垃圾回收之前，JVM会调用此方法来清理资源。此方法可能会将对象重新置为可达状态，导致JVM无法进行垃圾回收。 我们知道java相对于C++很大的优势是程序员不用手动管理内存，内存由jvm管理；如果我们的引用对象在堆中没有引用指向他们时，当内存不足时，JVM会自动将这些对象进行回收释放内存，这就是我们常说的垃圾回收。但垃圾回收没有讲述的这么简单。 finalize()方法具有如下4个特点： 永远不要主动调用某个对象的 finalize()方法，该方法由垃圾回收机制自己调用； finalize()何时被调用，是否被调用具有不确定性； 当 JVM执行可恢复对象的 finalize()可能会将此对象重新变为可达状态； 当 JVM执行 finalize()方法时出现异常，垃圾回收机制不会报告异常，程序继续执行。","categories":[{"name":"Java","slug":"Java","permalink":"https://liaoxingwang.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://liaoxingwang.github.io/tags/Java/"}],"author":"廖兴旺"},{"title":"Java中23种设计模式","slug":"Blog-Open-Source-Design patterns","date":"2024-04-15T21:20:00.000Z","updated":"2024-12-19T06:53:09.539Z","comments":true,"path":"2024/04/16/blog-open-source-design-patterns/","link":"","permalink":"https://liaoxingwang.github.io/2024/04/16/blog-open-source-design-patterns/","excerpt":"","text":"Java中23种设计模式Java中23种设计模式，包括简单介绍，适用场景以及优缺点等 一、创建型模式1.单例模式（Singleton Pattern）单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 1.1 饿汉式 特点:类加载时就初始化,线程安全 // 构造方法私有化 private Singleton() { } // 饿汉式创建单例对象 private static Singleton singleton = new Singleton(); public static Singleton getInstance() { return singleton; } 1.2 懒汉式 特点:第一次调用才初始化，避免内存浪费。 /* * 懒汉式创建单例模式 由于懒汉式是非线程安全， 所以加上线程锁保证线程安全 */ private static Singleton singleton; public static synchronized Singleton getInstance() { if (singleton == null) { singleton = new Singleton(); } return singleton; } 1.3 双重检验锁(double check lock)(DCL) 特点:安全且在多线程情况下能保持高性能 private volatile static Singleton singleton; private Singleton (){} public static Singleton getInstance() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } 1.4 静态内部类 特点:效果类似DCL,只适用于静态域 private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } private Singleton (){} public static final Singleton getInstance() { return SingletonHolder.INSTANCE; } 1.5 枚举 特点:自动支持序列化机制，绝对防止多次实例化 public enum Singleton { INSTANCE; } 1.6 破坏单例的几种方式与解决方法 1.6.1 反序列化 Singleton singleton = Singleton.getInstance(); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"D:/test.txt\")); oos.writeObject(singleton); oos.flush(); oos.close(); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"D:/test.txt\")); Singleton singleton1 = (Singleton)ois.readObject(); ois.close(); System.out.println(singleton);//com.ruoyi.base.mapper.Singleton@50134894 System.out.println(singleton1);//com.ruoyi.base.mapper.Singleton@5ccd43c2 可以看到反序列化后，两个对象的地址不一样了，那么这就是违背了单例模式的原则了，解决方法只需要在单例类里加上一个readResolve()方法即可，原因就是在反序列化的过程中，会检测readResolve()方法是否存在，如果存在的话就会反射调用readResolve()这个方法。 private Object readResolve() { return singleton; } //com.ruoyi.base.mapper.Singleton@50134894 //com.ruoyi.base.mapper.Singleton@50134894 1.6.2 反射 Singleton singleton = Singleton.getInstance(); Class singletonClass = Singleton.class; Constructor constructor = singletonClass.getDeclaredConstructor(); constructor.setAccessible(true); Singleton singleton1 = constructor.newInstance(); System.out.println(singleton);//com.ruoyi.base.mapper.Singleton@32a1bec0 System.out.println(singleton1);//com.ruoyi.base.mapper.Singleton@22927a81 同样可以看到，两个对象的地址不一样，这同样是违背了单例模式的原则，解决办法为使用一个布尔类型的标记变量标记一下即可，代码如下： private static boolean singletonFlag = false; private Singleton() { if (singleton != null || singletonFlag) { throw new RuntimeException(\"试图用反射破坏异常\"); } singletonFlag = true; } 但是这种方法假如使用了反编译，获得了这个标记变量，同样可以破坏单例，代码如下： Class&lt;Singleton> singletonClass = Singleton.class; Constructor&lt;Singleton> constructor = singletonClass.getDeclaredConstructor(); constructor.setAccessible(true); Singleton singleton = constructor.newInstance(); System.out.println(singleton); // com.ruoyi.base.mapper.Singleton@32a1bec0 Field singletonFlag = singletonClass.getDeclaredField(\"singletonFlag\"); singletonFlag.setAccessible(true); singletonFlag.setBoolean(singleton, false); Singleton singleton1 = constructor.newInstance(); System.out.println(singleton1); // com.ruoyi.base.mapper.Singleton@5e8c92f4 如果想使单例不被破坏，那么应该使用枚举的方式去实现单例模式，枚举是不可以被反射破坏单例的。 1.7 容器式单例 当程序中的单例对象非常多的时候，则可以使用容器对所有单例对象进行管理，如下： public class ContainerSingleton { private ContainerSingleton() {} private static Map&lt;String, Object> singletonMap = new ConcurrentHashMap&lt;>(); public static Object getInstance(Class clazz) throws Exception { String className = clazz.getName(); // 当容器中不存在目标对象时则先生成对象再返回该对象 if (!singletonMap.containsKey(className)) { Object instance = Class.forName(className).newInstance(); singletonMap.put(className, instance); return instance; } // 否则就直接返回容器里的对象 return singletonMap.get(className); } public static void main(String[] args) throws Exception { SafetyDangerLibrary instance1 = (SafetyDangerLibrary)ContainerSingleton.getInstance(SafetyDangerLibrary.class); SafetyDangerLibrary instance2 = (SafetyDangerLibrary)ContainerSingleton.getInstance(SafetyDangerLibrary.class); System.out.println(instance1 == instance2); // true } } 1.8 ThreadLocal单例 不保证整个应用全局唯一，但保证线程内部全局唯一，以空间换时间，且线程安全。 public class ThreadLocalSingleton { private ThreadLocalSingleton(){} private static final ThreadLocal&lt;ThreadLocalSingleton> threadLocalInstance = ThreadLocal.withInitial(() -> new ThreadLocalSingleton()); public static ThreadLocalSingleton getInstance(){ return threadLocalInstance.get(); } public static void main(String[] args) { new Thread(() -> { System.out.println(Thread.currentThread().getName() + \"-----\" + ThreadLocalSingleton.getInstance()); System.out.println(Thread.currentThread().getName() + \"-----\" + ThreadLocalSingleton.getInstance()); }).start(); new Thread(() -> { System.out.println(Thread.currentThread().getName() + \"-----\" + ThreadLocalSingleton.getInstance()); System.out.println(Thread.currentThread().getName() + \"-----\" + ThreadLocalSingleton.getInstance()); }).start(); // Thread-0-----com.ruoyi.library.domain.vo.ThreadLocalSingleton@53ac93b3 // Thread-1-----com.ruoyi.library.domain.vo.ThreadLocalSingleton@7fe11afc // Thread-0-----com.ruoyi.library.domain.vo.ThreadLocalSingleton@53ac93b3 // Thread-1-----com.ruoyi.library.domain.vo.ThreadLocalSingleton@7fe11afc } } 可以看到上面线程0和1他们的对象是不一样的，但是线程内部，他们的对象是一样的，这就是线程内部保证唯一。 1.9 总结 适用场景： 需要确保在任何情况下绝对只需要一个实例。如：ServletContext，ServletConfig，ApplicationContext，DBPool，ThreadPool等。 优点： 在内存中只有一个实例，减少了内存开销。 可以避免对资源的多重占用。 设置全局访问点，严格控制访问。 缺点： 没有接口，扩展困难。 如果要扩展单例对象，只有修改代码，没有其它途径。 2.工厂方法模式（Factory Method）2.1 简单工厂模式 简单工厂模式不是23种设计模式之一，他可以理解为工厂模式的一种简单的特殊实现。 2.1.1 基础版 // 工厂类 public class CoffeeFactory { public Coffee create(String type) { if (\"americano\".equals(type)) { return new Americano(); } if (\"mocha\".equals(type)) { return new Mocha(); } if (\"cappuccino\".equals(type)) { return new Cappuccino(); } return null; } } // 产品基类 public interface Coffee { } // 产品具体类，实现产品基类接口 public class Cappuccino implements Coffee { } 基础版是最基本的简单工厂的写法，传一个参数过来，判断是什么类型的产品，就返回对应的产品类型。但是这里有一个问题，就是参数是字符串的形式，这就很容易会写错，比如少写一个字母，或者小写写成了大写，就会无法得到自己想要的产品类了，同时如果新加了产品，还得在工厂类的创建方法中继续加if，于是就有了升级版的写法。 2.1.2 升级版 // 使用反射创建对象 // 加一个static变为静态工厂 public static Coffee create(Class clazz) throws Exception { if (clazz != null) { return clazz.newInstance(); } return null; } 升级版就很好的解决基础版的问题，在创建的时候在传参的时候不仅会有代码提示，保证不会写错，同时在新增产品的时候只需要新增产品类即可，也不需要再在工厂类的方法里面新增代码了。 2.1.3 总结 适用场景： 工厂类负责创建的对象较少。 客户端只需要传入工厂类的参数，对于如何创建的对象的逻辑不需要关心。 优点： 只需要传入一个正确的参数，就可以获取你所需要的对象，无须知道创建的细节。 缺点： 工厂类的职责相对过重，增加新的产品类型的时需要修改工厂类的判断逻辑，违背了开闭原则。 不易于扩展过于复杂的产品结构。 2.2 工厂方法模式 工厂方法模式是指定义一个创建对象的接口，让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。 工厂方法模式主要有以下几种角色： 抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。 具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它和具体工厂之间一一对应。 2.2.1 代码实现 // 抽象工厂 public interface CoffeeFactory { Coffee create(); } // 具体工厂 public class CappuccinoFactory implements CoffeeFactory { @Override public Coffee create() { return new Cappuccino(); } } // 抽象产品 public interface Coffee { } // 具体产品 public class Cappuccino implements Coffee { } 2.2.2 总结 适用场景： 创建对象需要大量的重复代码。 客户端（应用层）不依赖于产品类实例如何被创建和实现等细节。 一个类通过其子类来指定创建哪个对象。 优点： 用户只需要关系所需产品对应的工厂，无须关心创建细节。 加入新产品符合开闭原则，提高了系统的可扩展性。 缺点： 类的数量容易过多，增加了代码结构的复杂度。 增加了系统的抽象性和理解难度。 3.抽象工厂模式（Abstract Factory）抽象工厂模式是指提供一个创建一系列相关或相互依赖对象的接口，无须指定他们具体的类。 工厂方法模式中考虑的是一类产品的生产，如电脑厂只生产电脑，电话厂只生产电话，这种工厂只生产同种类的产品，同种类产品称为同等级产品，也就是说，工厂方法模式只考虑生产同等级的产品，但是现实生活中许多工厂都是综合型工厂，能生产多等级（种类）的产品，如上面说的电脑和电话，本质上他们都属于电器，那么他们就能在电器厂里生产出来，而抽象工厂模式就将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，如上图所示纵轴是产品等级，也就是同一类产品；横轴是产品族，也就是同一品牌的产品，同一品牌的产品产自同一个工厂。 抽象工厂模式的主要角色如下： 抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。 具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。 3.1 代码实现 // 咖啡店 抽象工厂 public interface CoffeeShopFactory { // 咖啡类 Coffee createCoffee(); // 甜点类 Dessert createDessert(); } // 美式风格工厂 public class AmericanFactory implements CoffeeShopFactory { @Override public Coffee createCoffee() { return new Americano(); } @Override public Dessert createDessert() { return new Cheesecake(); } } // 意式风格工厂 public class ItalyFactory implements CoffeeShopFactory { @Override public Coffee createCoffee() { return new Cappuccino(); } @Override public Dessert createDessert() { return new Tiramisu(); } } 类图 3.2 总结 产品族：一系列相关的产品，整合到一起有关联性 产品等级：同一个继承体系 适用场景： 客户端（应用层）不依赖于产品类实例如何被创建和实现等细节。 强调一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量重复的代码。 提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。 优点： 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。 缺点： 当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。 4.原型模式（Prototype）原型模式是指原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。调用者不需要知道任何创建细节，不调用构造函数。 原型模式包含如下角色： 抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。 具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。 访问类：使用具体原型类中的 clone() 方法来复制新的对象。 @Data @AllArgsConstructor @NoArgsConstructor public class Student implements Cloneable { private String name; private String sex; private Integer age; @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } public static void main(String[] args) throws Exception{ Student stu1 = new Student(\"张三\", \"男\", 18); Student stu2 = (Student)stu1.clone(); stu2.setName(\"李四\"); System.out.println(stu1);// Student(name=张三, sex=男, age=18) System.out.println(stu2);// Student(name=李四, sex=男, age=18) } } 可以看到，把一个学生复制过来，只是改了姓名而已，其他属性完全一样没有改变，需要注意的是，一定要在被拷贝的对象上实现Cloneable接口，否则会抛出CloneNotSupportedException异常。 4.1 浅克隆 创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。 @Data public class Clazz implements Cloneable { private String name; private Student student; @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } } @Data @AllArgsConstructor @NoArgsConstructor public class Student implements Serializable { private String name; private String sex; private Integer age; } public static void main(String[] args) throws Exception{ Clazz clazz1 = new Clazz(); clazz1.setName(\"高三一班\"); Student stu1 = new Student(\"张三\", \"男\", 18); clazz1.setStudent(stu1); System.out.println(clazz1); // Clazz(name=高三一班, student=Student(name=张三, sex=男, age=18)) Clazz clazz2 = (Clazz)clazz1.clone(); Student stu2 = clazz2.getStudent(); stu2.setName(\"李四\"); System.out.println(clazz1); // Clazz(name=高三一班, student=Student(name=李四, sex=男, age=18)) System.out.println(clazz2); // Clazz(name=高三一班, student=Student(name=李四, sex=男, age=18)) } 可以看到，当修改了stu2的姓名时，stu1的姓名同样也被修改了，这说明stu1和stu2是同一个对象，这就是浅克隆的特点，对具体原型类中的引用类型的属性进行引用的复制。同时，这也可能是浅克隆所带来的弊端，因为结合该例子的原意，显然是想在班级中新增一名叫李四的学生，而非让所有的学生都改名叫李四，于是我们这里就要使用深克隆。 4.2 深克隆 创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。 @Data public class Clazz implements Cloneable, Serializable { private String name; private Student student; @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } protected Object deepClone() throws IOException, ClassNotFoundException { ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); return ois.readObject(); } } public static void main(String[] args) throws Exception{ Clazz clazz1 = new Clazz(); clazz1.setName(\"高三一班\"); Student stu1 = new Student(\"张三\", \"男\", 18); clazz1.setStudent(stu1); Clazz clazz3 = (Clazz)clazz1.deepClone(); Student stu3 = clazz3.getStudent(); stu3.setName(\"王五\"); System.out.println(clazz1); // Clazz(name=高三一班, student=Student(name=张三, sex=男, age=18)) System.out.println(clazz3); // Clazz(name=高三一班, student=Student(name=王五, sex=男, age=18)) } 可以看到，当修改了stu3的姓名时，stu1的姓名并没有被修改了，这说明stu3和stu1已经是不同的对象了，说明Clazz中的Student也被克隆了，不再指向原有对象地址，这就是深克隆。这里需要注意的是，Clazz类和Student类都需要实现Serializable接口，否则会抛出NotSerializableException异常。 4.3 克隆破坏单例与解决办法 PS：上面例子有的代码，这里便不重复写了，可以在上面的代码基础上添加以下代码 // Clazz类 private static Clazz clazz = new Clazz(); private Clazz(){} public static Clazz getInstance() {return clazz;} // 测试 public static void main(String[] args) throws Exception{ Clazz clazz1 = Clazz.getInstance(); Clazz clazz2 = (Clazz)clazz1.clone(); System.out.println(clazz1 == clazz2); // false } 可以看到clazz1和clazz2并不相等，也就是说他们并不是同一个对象，也就是单例被破坏了。 解决办法也很简单，首先第一个就是不实现Cloneable接口即可，但是不实现Cloneable接口进行clone则会抛出CloneNotSupportedException异常。第二个方法就是重写clone()方法即可，如下： @Override protected Object clone() throws CloneNotSupportedException { return clazz; } // 测试输出 System.out.println(clazz1 == clazz2) // true 可以看到，上面clazz1和clazz2是相等的，即单例没有被破坏。 另外我们知道，单例就是只有一个实例对象，如果重写了clone(）方法保证单例的话，那么通过克隆出来的对象则不可以重新修改里面的属性，因为修改以后就会连同克隆对象一起被修改，所以是需要单例还是克隆，在实际应用中需要好好衡量。 4.4 总结 适用场景： 类初始化消耗资源较多。 new产生的一个对象需要非常繁琐的过程（数据准备、访问权限等）。 构造函数比较复杂。 循环体中生产大量对象时。 优点： 性能优良，Java自带的原型模式是基于内存二进制流的拷贝，比直接new一个对象性能上提升了许多。 可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，简化了创建的过程。 缺点： 必须配备克隆（或者可拷贝）方法。 当对已有类进行改造的时候，需要修改代码，违反了开闭原则。 深克隆、浅克隆需要运用得当。 5.建造者模式（Builder）建造者模式是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。用户只需指定需要建造的类型就可以获得对象，建造过程及细节不需要了解。 建造者（Builder）模式包含如下角色： 抽象建造者类（Builder）：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的部件对象的创建。 具体建造者类（ConcreteBuilder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。 产品类（Product）：要创建的复杂对象。 指挥者类（Director）：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。 5.1 常规写法 //产品类 电脑 @Data public class Computer { private String motherboard; private String cpu; private String memory; private String disk; private String gpu; private String power; private String heatSink; private String chassis; } // 抽象 builder类（接口） 组装电脑 public interface ComputerBuilder { Computer computer = new Computer(); void buildMotherboard(); void buildCpu(); void buildMemory(); void buildDisk(); void buildGpu(); void buildHeatSink(); void buildPower(); void buildChassis(); Computer build(); } // 具体 builder类 华硕ROG全家桶电脑（手动狗头） public class AsusComputerBuilder implements ComputerBuilder { @Override public void buildMotherboard() { computer.setMotherboard(\"Extreme主板\"); } @Override public void buildCpu() { computer.setCpu(\"Inter 12900KS\"); } @Override public void buildMemory() { computer.setMemory(\"芝奇幻峰戟 16G*2\"); } @Override public void buildDisk() { computer.setDisk(\"三星980Pro 2T\"); } @Override public void buildGpu() { computer.setGpu(\"华硕3090Ti 水猛禽\"); } @Override public void buildHeatSink() { computer.setHeatSink(\"龙神二代一体式水冷\"); } @Override public void buildPower() { computer.setPower(\"雷神二代1200W\"); } @Override public void buildChassis() { computer.setChassis(\"太阳神机箱\"); } @Override public Computer build() { return computer; } } // 指挥者类 指挥该组装什么电脑 @AllArgsConstructor public class ComputerDirector { private ComputerBuilder computerBuilder; public Computer construct() { computerBuilder.buildMotherboard(); computerBuilder.buildCpu(); computerBuilder.buildMemory(); computerBuilder.buildDisk(); computerBuilder.buildGpu(); computerBuilder.buildHeatSink(); computerBuilder.buildPower(); computerBuilder.buildChassis(); return computerBuilder.build(); } } // 测试 public static void main(String[] args) { ComputerDirector computerDirector = new ComputerDirector(new AsusComputerBuilder()); // Computer(motherboard=Extreme主板, cpu=Inter 12900KS, memory=芝奇幻峰戟 16G*2, disk=三星980Pro 2T, gpu=华硕3090Ti 水猛禽, power=雷神二代1200W, heatSink=龙神二代一体式水冷, chassis=太阳神机箱) System.out.println(computerDirector.construct()); } 上面示例是建造者模式的常规用法，指挥者类ComputerDirector在建造者模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类，但是有些情况下需要简化系统结构，可以把指挥者类和抽象建造者进行结合，于是就有了下面的简化写法。 5.2 简化写法 // 把指挥者类和抽象建造者合在一起的简化建造者类 public class SimpleComputerBuilder { private Computer computer = new Computer(); public void buildMotherBoard(String motherBoard){ computer.setMotherboard(motherBoard); } public void buildCpu(String cpu){ computer.setCpu(cpu); } public void buildMemory(String memory){ computer.setMemory(memory); } public void buildDisk(String disk){ computer.setDisk(disk); } public void buildGpu(String gpu){ computer.setGpu(gpu); } public void buildPower(String power){ computer.setPower(power); } public void buildHeatSink(String heatSink){ computer.setHeatSink(heatSink); } public void buildChassis(String chassis){ computer.setChassis(chassis); } public Computer build(){ return computer; } } // 测试 public static void main(String[] args) { SimpleComputerBuilder simpleComputerBuilder = new SimpleComputerBuilder(); simpleComputerBuilder.buildMotherBoard(\"Extreme主板\"); simpleComputerBuilder.buildCpu(\"Inter 12900K\"); simpleComputerBuilder.buildMemory(\"芝奇幻峰戟 16G*2\"); simpleComputerBuilder.buildDisk(\"三星980Pro 2T\"); simpleComputerBuilder.buildGpu(\"华硕3090Ti 水猛禽\"); simpleComputerBuilder.buildPower(\"雷神二代1200W\"); simpleComputerBuilder.buildHeatSink(\"龙神二代一体式水冷\"); simpleComputerBuilder.buildChassis(\"太阳神机箱\"); // Computer(motherboard=Extreme主板, cpu=Inter 12900K, memory=芝奇幻峰戟 16G*2, disk=三星980Pro 2T, gpu=华硕3090Ti 水猛禽, power=雷神二代1200W, heatSink=龙神二代一体式水冷, chassis=太阳神机箱) System.out.println(simpleComputerBuilder.build()); } 可以看到，对比常规写法，这样写确实简化了系统结构，但同时也加重了建造者类的职责，也不是太符合单一职责原则，如果construct() 过于复杂，建议还是封装到 Director 中。 5.3 链式写法 // 链式写法建造者类 public class SimpleComputerBuilder { private Computer computer = new Computer(); public SimpleComputerBuilder buildMotherBoard(String motherBoard){ computer.setMotherboard(motherBoard); return this; } public SimpleComputerBuilder buildCpu(String cpu){ computer.setCpu(cpu); return this; } public SimpleComputerBuilder buildMemory(String memory){ computer.setMemory(memory); return this; } public SimpleComputerBuilder buildDisk(String disk){ computer.setDisk(disk); return this; } public SimpleComputerBuilder buildGpu(String gpu){ computer.setGpu(gpu); return this; } public SimpleComputerBuilder buildPower(String power){ computer.setPower(power); return this; } public SimpleComputerBuilder buildHeatSink(String heatSink){ computer.setHeatSink(heatSink); return this; } public SimpleComputerBuilder buildChassis(String chassis){ computer.setChassis(chassis); return this; } public Computer build(){ return computer; } } // 测试 public static void main(String[] args) { Computer asusComputer = new SimpleComputerBuilder().buildMotherBoard(\"Extreme主板\") .buildCpu(\"Inter 12900K\") .buildMemory(\"芝奇幻峰戟 16G*2\") .buildDisk(\"三星980Pro 2T\") .buildGpu(\"华硕3090Ti 水猛禽\") .buildPower(\"雷神二代1200W\") .buildHeatSink(\"龙神二代一体式水冷\") .buildChassis(\"太阳神机箱\").build(); System.out.println(asusComputer); } 可以看到，其实链式写法与普通写法的区别并不大，只是在建造者类组装部件的时候，同时将建造者类返回即可，使用链式写法使用起来更方便，某种程度上也可以提高开发效率。从软件设计上，对程序员的要求比较高。比较常见的mybatis-plus中的条件构造器就是使用的这种链式写法。 5.4 总结 适用场景： 适用于创建对象需要很多步骤，但是步骤顺序不一定固定。 如果一个对象有非常复杂的内部结构（属性），把复杂对象的创建和使用进行分离。 优点： 封装性好，创建和使用分离。 扩展性好，建造类之间独立、一定程度上解耦。 缺点： 产生多余的Builder对象。 产品内部发生变化，建造者都要修改，成本较大。 与工厂模式的区别： 建造者模式更注重方法的调用顺序，工厂模式更注重创建对象。 创建对象的力度不同，建造者模式创建复杂的对象，由各种复杂的部件组成，工厂模式创建出来的都一样。 关注点不同，工厂模式只需要把对象创建出来就可以了，而建造者模式中不仅要创建出这个对象，还要知道这个对象由哪些部件组成。 建造者模式根据建造过程中的顺序不一样，最终的对象部件组成也不一样。 与抽象工厂模式的区别： 抽象工厂模式实现对产品族的创建，一个产品族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。 建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。 建造者模式所有函数加到一起才能生成一个对象，抽象工厂一个函数生成一个对象 二、结构型模式1.代理模式（Proxy Pattern）代理模式是指为其他对象提供一种代理，以控制对这个对象的访问。代理对象在访问对象和目标对象之间起到中介作用。 Java中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和CGLib代理两种。 代理（Proxy）模式分为三种角色： 抽象角色（Subject）： 通过接口或抽象类声明真实角色和代理对象实现的业务方法。 真实角色（Real Subject）： 实现了抽象角色中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。 代理角色（Proxy） ： 提供了与真实角色相同的接口，其内部含有对真实角色的引用，它可以访问、控制或扩展真实角色的功能。 1.1 静态代理 静态代理就是指我们在给一个类扩展功能的时候，我们需要去书写一个静态的类，相当于在之前的类上套了一层，这样我们就可以在不改变之前的类的前提下去对原有功能进行扩展，静态代理需要代理对象和目标对象实现一样的接口。 // 火车站接口，有卖票功能 public interface TrainStation { void sellTickets(); } // 广州火车站卖票 public class GuangzhouTrainStation implements TrainStation { @Override public void sellTickets() { System.out.println(\"广州火车站卖票啦\"); } } // 代售点卖票（代理类） public class ProxyPoint implements TrainStation { // 目标对象（代理火车站售票） private TrainStation station = new GuangzhouTrainStation(); @Override public void sellTickets() { System.out.println(\"代售加收5%手续费\"); station.sellTickets(); } public static void main(String[] args) { ProxyPoint proxyPoint = new ProxyPoint(); // 代售加收5%手续费 // 广州火车站卖票啦 proxyPoint.sellTickets(); } } // 测试 public static void main(String[] args) { ProxyPoint proxyPoint = new ProxyPoint(); // 代售加收5%手续费 // 火车站卖票啦 proxyPoint.sellTickets(); } 可以从上面代码看到，我们访问的是ProxyPoint对象，也就是说ProxyPoint是作为访问对象和目标对象的中介的，同时也对sellTickets方法进行了增强（代理点收取加收5%手续费）。 静态代理的优点是实现简单，容易理解，只要确保目标对象和代理对象实现共同的接口或继承相同的父类就可以在不修改目标对象的前提下进行扩展。 而缺点也比较明显，那就是代理类和目标类必须有共同接口(父类)，并且需要为每一个目标类维护一个代理类，当需要代理的类很多时会创建出大量代理类。一旦接口或父类的方法有变动，目标对象和代理对象都需要作出调整。 1.2 动态代理 代理类在代码运行时创建的代理称之为动态代理。动态代理中代理类并不是预先在Java代码中定义好的，而是运行时由JVM动态生成，并且可以代理多个目标对象。 1.2.1 jdk动态代理 JDK动态代理是Java JDK自带的一个动态代理实现， 位于java.lang.reflect包下。 // 火车站接口，有卖票功能 public interface TrainStation { void sellTickets(); } // 广州火车站卖票 public class GuangzhouTrainStation implements TrainStation { @Override public void sellTickets() { System.out.println(\"广州火车站卖票啦\"); } } // 深圳火车站卖票 public class ShenzhenTrainStation implements TrainStation { @Override public void sellTickets() { System.out.println(\"深圳火车站卖票啦\"); } } // 代售点卖票（代理类） public class ProxyPoint implements InvocationHandler { private TrainStation trainStation; public TrainStation getProxyObject(TrainStation trainStation) { this.trainStation = trainStation; Class&lt;? extends TrainStation> clazz = trainStation.getClass(); return (TrainStation) Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this); } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\"代售火车票收取5%手续费\"); return method.invoke(this.trainStation, args); } } // 测试 public static void main(String[] args) { ProxyPoint proxy = new ProxyPoint(); TrainStation guangzhouTrainStation = proxy.getProxyObject(new GuangzhouTrainStation()); // 代售火车票收取5%手续费 // 广州火车站卖票啦 guangzhouTrainStation.sellTickets(); TrainStation shenzhenTrainStation = proxy.getProxyObject(new ShenzhenTrainStation()); // 代售火车票收取5%手续费 // 深圳火车站卖票啦 shenzhenTrainStation.sellTickets(); } 优点： 使用简单、维护成本低。 Java原生支持，不需要任何依赖。 解决了静态代理存在的多数问题。 缺点： 由于使用反射，性能会比较差。 只支持接口实现，不支持继承， 不满足所有业务场景。 1.2.2 CGLIB动态代理 CGLIB是一个强大的、高性能的代码生成库。它可以在运行期扩展Java类和接口，其被广泛应用于AOP框架中（Spring、dynaop）中， 用以提供方法拦截。CGLIB比JDK动态代理更强的地方在于它不仅可以接管Java接口， 还可以接管普通类的方法。 cglib cglib ${cglib-version} // 代售点卖票（代理类） public class ProxyPoint implements MethodInterceptor { public TrainStation getProxyObject(Class&lt;? extends TrainStation> trainStation) { //创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数 Enhancer enhancer =new Enhancer(); //设置父类的字节码对象 enhancer.setSuperclass(trainStation); //设置回调函数 enhancer.setCallback(this); //创建代理对象并返回 return (TrainStation) enhancer.create(); } @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { System.out.println(\"代售火车票收取5%手续费\"); return methodProxy.invokeSuper(o, objects); } } // 测试 public static void main(String[] args) { ProxyPoint proxy = new ProxyPoint(); TrainStation guangzhouTrainStation = proxy.getProxyObject(GuangzhouTrainStation.class); // 代售火车票收取5%手续费 // 广州火车站卖票啦 guangzhouTrainStation.sellTickets(); TrainStation shenzhenTrainStation = proxy.getProxyObject(ShenzhenTrainStation.class); // 代售火车票收取5%手续费 // 深圳火车站卖票啦 shenzhenTrainStation.sellTickets(); } 1.3 总结 应用场景： 保护目标对象。 增强目标对象。 优点： 代理模式能将代理对象与真实被调用的目标对象分离。 一定程度上降低了系统的耦合程度，易于扩展。 代理可以起到保护目标对象的作用。 增强目标对象的职责。 缺点： 代理模式会造成系统设计中类的数目增加。 在客户端和目标对象之间增加了一个代理对象，请求处理速度变慢。 增加了系统的复杂度。 两种动态代理的对比： JDK动态代理的特点： 需要实现InvocationHandler接口， 并重写invoke方法。 被代理类需要实现接口， 它不支持继承。 JDK 动态代理类不需要事先定义好， 而是在运行期间动态生成。 JDK 动态代理不需要实现和被代理类一样的接口， 所以可以绑定多个被代理类。 主要实现原理为反射， 它通过反射在运行期间动态生成代理类， 并且通过反射调用被代理类的实际业务方法。 cglib的特点： cglib动态代理中使用的是FastClass机制。 cglib生成字节码的底层原理是使用ASM字节码框架。 cglib动态代理需创建3份字节码，所以在第一次使用时会比较耗性能，但是后续使用较JDK动态代理方式更高效，适合单例bean场景。 cglib由于是采用动态创建子类的方法，对于final方法，无法进行代理。 2.适配器模式（Adapter Class/Object）适配器模式，它的功能是将一个类的接口变成客户端所期望的另一种接口，从而使原本因接口不匹配而导致无法在一起工作的两个类能够一起工作。适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。 适配器模式（Adapter）包含以下主要角色： 目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。 适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。 2.1 类适配器 类适配器是通过定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件来实现的，类图如下： 类图 // 适配者 220V电压 public class AC220 { public int output() { System.out.println(\"输出220V交流电\"); return 220; } } // 目标 5V public interface DC5 { public int output5(); } // 适配器类（电源适配器） public class PowerAdapter extends AC220 implements DC5 { @Override public int output5() { int output220 = super.output(); int output5 = output220 / 44; System.out.println(output220 + \"V适配转换成\" + output5 + \"V\"); return output5; } } // 测试 public static void main(String[] args) { PowerAdapter powerAdapter = new PowerAdapter(); // 输出220V交流电 powerAdapter.output(); // 输出220V交流电 // 220V适配转换成5V powerAdapter.output5(); } 通过上面代码例子可以看出，类适配器有一个很明显的缺点，就是违背了合成复用原则。结合上面的例子，假如我不是220V的电压了，是380V电压呢？那就要多建一个380V电压的适配器了。同理，由于Java是单继承的原因，如果不断的新增适配者，那么就要无限的新增适配器，于是就有了对象适配器。 2.2 对象适配器 对象适配器的实现方式是通过现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。 // 电源接口 public interface Power { int output(); } // 适配者 220V电压 public class AC220 implements Power { @Override public int output() { System.out.println(\"输出220V交流电\"); return 220; } } // 目标 5V public interface DC5 { public int output5(); } @AllArgsConstructor public class PowerAdapter implements DC5 { // 适配者 private Power power; @Override public int output5() { int output220 = power.output(); int output5 = output220 / 44; System.out.println(output220 + \"V适配转换成\" + output5 + \"V\"); return output5; } } // 测试 public static void main(String[] args) { DC5 powerAdapter = new PowerAdapter(new AC220()); // 输出220V交流电 // 220V适配转换成5V powerAdapter.output5(); } 可以看到，上面代码中，只实现了目标接口，并没有继承适配者，而是将适配者类实现适配者接口，在适配器中引入适配者接口，当我们需要使用不同的适配者通过适配器进行转换时，就无需再新建适配器类了，如上面例子，假如我需要380V的电源转换成5V的，那么客户端只需要调用适配器时传入380V电源的类即可，就无需再新建一个380V电源的适配器了（PS：上述逻辑代码中output220 / 44请忽略，可以根据实际情况编写实际的通用逻辑代码）。 2.3 接口适配器 接口适配器主要是解决类臃肿的问题，我们可以把所有相近的适配模式的方法都放到同一个接口里面，去实现所有方法，当客户端需要哪个方法直接调用哪个方法即可。如上面例子所示，我们只是转换成了5V电压，那假如我要转换成12V，24V，30V…呢？那按照上面的写法就需要新建12V，24V，30V…的接口，这样就会导致类过于多了。那么我们就可以把5V，12V，24V，30V…这些转换方法，通通都写到一个接口里去，这样当我们需要转换哪种就直接调用哪种即可。 // 这里例子 输出不同直流电接口 public interface DC { int output5(); int output12(); int output24(); int output30(); } // 适配器类（电源适配器） @AllArgsConstructor public class PowerAdapter implements DC { private Power power; @Override public int output5() { // 具体实现逻辑 return 5; } @Override public int output12() { // 具体实现逻辑 return 12; } @Override public int output24() { // 具体实现逻辑 return 24; } @Override public int output30() { // 具体实现逻辑 return 30; } } 2.4 总结 适用场景： 已经存在的类，它的方法和需求不匹配（方法结构相同或相似）的情况。 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。 优点： 能提高类的透明性和复用，现有的类复用但不需要改变。 目标类和适配器类解耦，提高程序的扩展性。 在很多业务场景中符合开闭原则。 缺点： 适配器编写过程需要全面考虑，可能会增加系统的复杂性。 增加代码阅读难度，降级代码可读性，过多使用适配器会使系统代码变得凌乱。 3.装饰模式（Decorator Pattern）装饰模式，是指在不改变原有对象的基础上，将功能附加到对象上，提供了比继承更有弹性的替代方案（扩展原有对象的功能） 装饰（Decorator）模式中的角色： 抽象构件（Component）角色 ：定义一个抽象接口以规范准备接收附加责任的对象。 具体构件（Concrete Component）角色 ：实现抽象构件，通过装饰角色为其添加一些职责。 抽象装饰（Decorator）角色 ： 继承或实现抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。 具体装饰（ConcreteDecorator）角色 ：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。 3.1 继承方式 举一个简单的例子，假如现在有一碟炒饭，每个人的口味不一样，有些人喜欢加鸡蛋，有些人喜欢加鸡蛋火腿，有些人喜欢加鸡蛋火腿胡萝卜等，那么就会发现，如果采用继承的方式去实现这个例子，那么没加一个配料，都需要创建新的配料类去继承上一个旧的配料类，那么久而久之，就会产生很多类了，而且还不利于扩展，代码如下： // 炒饭类 public class FriedRice { String getDesc() { return \"炒饭\"; } Integer getPrice() { return 5; } } // 炒饭加鸡蛋类 public class FriedRiceAddEgg extends FriedRice{ String getDesc() { return super.getDesc() + \"+鸡蛋\"; } Integer getPrice() { return super.getPrice() + 2; } } // 炒饭加鸡蛋加火腿类 public class FriedRiceAddEggAndHam extends FriedRiceAddEgg { String getDesc() { return super.getDesc() + \"+火腿\"; } Integer getPrice() { return super.getPrice() + 3; } } // 测试方法 public static void main(String[] args) { FriedRice friedRice = new FriedRice(); System.out.println(friedRice.getDesc() + friedRice.getPrice() + \"元\");// 炒饭5元 FriedRice friedRiceAddEgg = new FriedRiceAddEgg(); System.out.println(friedRiceAddEgg.getDesc() + friedRiceAddEgg.getPrice() + \"元\"); // 炒饭+鸡蛋7元 FriedRice friedRiceAddEggAndHam = new FriedRiceAddEggAndHam(); System.out.println(friedRiceAddEggAndHam.getDesc() + friedRiceAddEggAndHam.getPrice() + \"元\");// 炒饭+鸡蛋+火腿10元 } 可以从上面看到，如果我们只需要炒饭加火腿，那么我们还需要创建一个FriedRiceAddHam类去继承FriedRice类，所以继承的方式扩展性非常不好，且需要定义非常多的子类，下面就可以用装饰器模式去改进它。 3.2 装饰器模式方式 // 炒饭类 public class FriedRice { String getDesc() { return \"炒饭\"; } Integer getPrice() { return 5; } } // 配料表 public abstract class Ingredients extends FriedRice{ private FriedRice friedRice; public Ingredients(FriedRice friedRice) { this.friedRice = friedRice; } String getDesc() { return this.friedRice.getDesc(); } Integer getPrice() { return this.friedRice.getPrice(); } } // 鸡蛋配料 public class Egg extends Ingredients { public Egg(FriedRice friedRice) { super(friedRice); } String getDesc() { return super.getDesc() + \"+鸡蛋\"; } Integer getPrice() { return super.getPrice() + 2; } } // 火腿配料 public class Ham extends Ingredients { public Ham(FriedRice friedRice){ super(friedRice); } String getDesc() { return super.getDesc() + \"+火腿\"; } Integer getPrice() { return super.getPrice() + 3; } } // 测试方法 public static void main(String[] args) { FriedRice friedRice = new FriedRice(); System.out.println(friedRice.getDesc() + friedRice.getPrice() + \"元\"); // 炒饭5元 friedRice = new Egg(friedRice); System.out.println(friedRice.getDesc() + friedRice.getPrice() + \"元\"); // 炒饭+鸡蛋7元 friedRice = new Egg(friedRice); System.out.println(friedRice.getDesc() + friedRice.getPrice() + \"元\");// 炒饭+鸡蛋+鸡蛋9元 friedRice = new Ham(friedRice); System.out.println(friedRice.getDesc() + friedRice.getPrice() + \"元\");// 炒饭+鸡蛋+鸡蛋+火腿12元 } 可以看到，使用装饰器模式的方法实现，与普通的继承方法实现，最大的区别就是一种配料只有一个类，而且在加配料的时候，也可以直接想加多少就加多少，不需要说一个鸡蛋一个类，两个鸡蛋也要创建一个类，这样可以带来比继承更加灵活的扩展功能，使用也更加方便。 3.3 总结 装饰器模式与代理模式对比： 装饰器模式就是一种特殊的代理模式。 装饰器模式强调自身的功能扩展，用自己说了算的透明扩展，可动态定制的扩展；代理模式强调代理过程的控制。 获取目标对象构建的地方不同，装饰者是从外界传递进来的，可以通过构造方法传递；静态代理是在代理类内部创建，以此来隐藏目标对象。 适用场景： 用于扩展一个类的功能或者给一个类添加附加职责。 动态的给一个对象添加功能，这些功能同样也可以再动态的撤销。 优点： 装饰器是继承的有力补充，比继承灵活，不改变原有对象的情况下动态地给一个对象扩展功能，即插即用。 通过使用不同装饰类以及这些装饰类的排列组合，可实现不同效果。 装饰器完全遵守开闭原则。 缺点： 会出现更多的代码，更多的类，增加程序的复杂性。 动态装饰时，多层装饰会更复杂。 4.桥接模式（Bridge Pattern）桥接模式也称为桥梁模式、接口模式或者柄体（Handle and Body）模式，是将抽象部分与他的具体实现部分分离，使它们都可以独立地变化，通过组合的方式建立两个类之间的联系，而不是继承。 桥接（Bridge）模式包含以下主要角色： 抽象化（Abstraction）角色 ：定义抽象类，并包含一个对实现化对象的引用。 扩展抽象化（Refined Abstraction）角色 ：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。 实现化（Implementor）角色 ：定义实现化角色的接口，供扩展抽象化角色调用。 具体实现化（Concrete Implementor）角色 ：给出实现化角色接口的具体实现。 4.1 代码实现 下面以一个多系统多视频格式文件播放为例子： // 视频接口 public interface Video { void decode(String fileName); } // MP4格式类 public class Mp4 implements Video{ @Override public void decode(String fileName) { System.out.println(\"MP4视频文件：\"+ fileName); } } // RMVB格式类 public class Rmvb implements Video{ @Override public void decode(String fileName) { System.out.println(\"rmvb文件：\" + fileName); } } // 操作系统抽象类 @AllArgsConstructor public abstract class OperatingSystem { Video video; public abstract void play(String fileName); } // iOS系统 public class Ios extends OperatingSystem { public Ios(Video video){ super(video); } @Override public void play(String fileName) { video.decode(fileName); } } // windows系统 public class Windows extends OperatingSystem { public Windows(Video video){ super(video); } @Override public void play(String fileName) { video.decode(fileName); } } 类关系图 可以通过类图看到，视频类和操作系统类之间通过OperatingSystem类桥接关联起来。 4.2 总结 适用场景： 在抽象和具体实现之间需要增加更多的灵活性的场景。 一个类存在两个（或多个）独立变化的维度，而这两个（或多个）维度都需要独立进行扩展。 不希望使用继承，或因为多层继承导致系统类的个数剧增。 优点： 分离抽象部分及其具体实现部分。 提高了系统的扩展性。 符合开闭原型。 符合合成复用原则。 缺点： 增加了系统的理解与设计难度。 需要正确地识别系统中两个独立变化的维度。 5.外观模式（Facade）外观模式又称门面模式，提供了一个统一的接口，用来访问子系统中的一群接口。 特征：门面模式定义了一个高层接口，让子系统更容易使用。 外观（Facade）模式包含以下主要角色： 外观（Facade）角色：为多个子系统对外提供一个共同的接口。 子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。 5.1 代码实现 下面以一个智能音箱实现起床睡觉一键操作电器的场景，通过代码模拟一下这个场景： public class Light { public void on() { System.out.println(\"开灯\"); } public void off() { System.out.println(\"关灯\"); } } public class Tv { public void on() { System.out.println(\"开电视\"); } public void off() { System.out.println(\"关电视\"); } } public class Fan { public void on() { System.out.println(\"开风扇\"); } public void off() { System.out.println(\"关风扇\"); } } public class SmartSpeaker { private Light light; private Tv tv; private Fan fan; public SmartSpeaker() { light = new Light(); tv = new Tv(); fan = new Fan(); } public void say(String order) { if (order.contains(\"起床\")) { getUp(); } else if (order.contains(\"睡觉\")) { sleep(); } else { System.out.println(\"我还听不懂你说的啥！\"); } } public void getUp() { System.out.println(\"起床\"); light.on(); tv.on(); fan.off(); } public void sleep() { System.out.println(\"睡觉\"); light.off(); tv.off(); fan.on(); } } public static void main(String[] args) { SmartSpeaker smartSpeaker = new SmartSpeaker(); //睡觉 //关灯 //关电视 //开风扇 smartSpeaker.say(\"我要睡觉了!\"); //起床 //开灯 //开电视 //关风扇 smartSpeaker.say(\"我起床了!\"); //我还听不懂你说的啥！ smartSpeaker.say(\"Emmm\"); } 5.2 总结 适用场景： 对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。 当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。 当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。 优点： 简化了调用过程，无需深入了解子系统，以防给子系统带来风险。 减少系统依赖、松散耦合。 更好地划分访问层次，提高了安全性。 遵循迪米特法则，即最少知道原则。 缺点： 当增加子系统和扩展子系统行为时，可能容易带来未知风险。 不符合开闭原则。 某些情况下可能违背单一职责原则。 6.组合模式（Composite Pattern）组合模式也称为整体-部分（Part-Whole）模式，它的宗旨是通过将单个对象（叶子结点）和组合对象（树枝节点）用相同的接口进行表示。 作用：使客户端对单个对象和组合对象保持一致的方式处理。 组合模式主要包含三种角色：抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。 树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。 叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。 6.1 代码实现 下面以一个添加菜单的例子通过代码实现： // 菜单组件 public abstract class MenuComponent { String name; Integer level; public void add(MenuComponent menuComponent) { throw new UnsupportedOperationException(\"不支持添加操作!\"); } public void remove(MenuComponent menuComponent) { throw new UnsupportedOperationException(\"不支持删除操作!\"); } public MenuComponent getChild(Integer i) { throw new UnsupportedOperationException(\"不支持获取子菜单操作!\"); } public String getName() { throw new UnsupportedOperationException(\"不支持获取名字操作!\"); } public void print() { throw new UnsupportedOperationException(\"不支持打印操作!\"); } } // 菜单类 public class Menu extends MenuComponent { private List&lt;MenuComponent> menuComponentList = new ArrayList&lt;>(); public Menu(String name,int level){ this.level = level; this.name = name; } @Override public void add(MenuComponent menuComponent) { menuComponentList.add(menuComponent); } @Override public void remove(MenuComponent menuComponent) { menuComponentList.remove(menuComponent); } @Override public MenuComponent getChild(Integer i) { return menuComponentList.get(i); } @Override public void print() { for (int i = 1; i &lt; level; i++) { System.out.print(\"--\"); } System.out.println(name); for (MenuComponent menuComponent : menuComponentList) { menuComponent.print(); } } } // 子菜单类 public class MenuItem extends MenuComponent { public MenuItem(String name,int level) { this.name = name; this.level = level; } @Override public void print() { for (int i = 1; i &lt; level; i++) { System.out.print(\"--\"); } System.out.println(name); } } // 测试方法 public static void main(String[] args) { //创建一级菜单 MenuComponent component = new Menu(\"系统管理\",1); MenuComponent menu1 = new Menu(\"用户管理\",2); menu1.add(new MenuItem(\"新增用户\",3)); menu1.add(new MenuItem(\"修改用户\",3)); menu1.add(new MenuItem(\"删除用户\",3)); MenuComponent menu2 = new Menu(\"角色管理\",2); menu2.add(new MenuItem(\"新增角色\",3)); menu2.add(new MenuItem(\"修改角色\",3)); menu2.add(new MenuItem(\"删除角色\",3)); menu2.add(new MenuItem(\"绑定用户\",3)); //将二级菜单添加到一级菜单中 component.add(menu1); component.add(menu2); //打印菜单名称(如果有子菜单一块打印) component.print(); } // 测试结果 系统管理 --用户管理 ----新增用户 ----修改用户 ----删除用户 --角色管理 ----新增角色 ----修改角色 ----删除角色 ----绑定用户 6.2 总结 适用场景： 希望客户端可以忽略组合对象与单个对象的差异时。 对象层次具备整体和部分，呈树形结构（如树形菜单，操作系统目录结构，公司组织架构等）。 优点： 清楚地定义分层次的复杂对象，表示对象的全部或部分层次。 让客户端忽略了层次的差异，方便对整个层次结构进行控制。 简化客户端代码。 符合开闭原则。 缺点： 限制类型时会较为复杂。 使设计变得更加抽象。 分类： 透明组合模式 透明组合模式中，抽象根节点角色中声明了所有用于管理成员对象的方法，比如在示例中MenuComponent声明了add() 、 remove() 、getChild()方法，这样做的好处是确保所有的构件类都有相同的接口。透明组合模式也是组合模式的标准形式。 透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供 add()、remove() 等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码） 安全组合模式 在安全组合模式中，在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在树枝节点Menu类中声明并实现这些方法。安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。 7.享元模式（Flyweight Pattern）享元模式又称为轻量级模式，是对象池的一种实现，类似于线程池，线程池可以避免不停的创建和销毁多个对象，消耗性能。提供了减少对象数量从而改善应用所需的对象结构的方式。宗旨：共享细粒度对象，将多个对同一对象的访问集中起来。 享元（Flyweight ）模式中存在以下两种状态： 内部状态，即不会随着环境的改变而改变的可共享部分。 外部状态，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。 享元模式的主要有以下角色： 抽象享元角色（Flyweight）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。 具体享元（Concrete Flyweight）角色 ：它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。 非享元（Unsharable Flyweight)角色 ：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。 享元工厂（Flyweight Factory）角色 ：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。 7.1 代码实现 下面通过查询火车票的例子来用代码进行模拟实现： // 抽象接口 public interface ITicket { void show(String seat); } public class TrainTicket implements ITicket { private String from; private String to; private Integer price; public TrainTicket(String from, String to) { this.from = from; this.to = to; } @Override public void show(String seat) { this.price = new Random().nextInt(500); System.out.println(from + \"->\" + to + \":\" + seat + \"价格:\" + this.price); } } // 工厂类 public class TicketFactory { private static Map&lt;String, ITicket> pool = new ConcurrentHashMap&lt;>(); public static ITicket getTicket(String from, String to) { String key = from + \"->\" + to; if (pool.containsKey(key)) { System.out.println(\"使用缓存获取火车票:\" + key); return pool.get(key); } System.out.println(\"使用数据库获取火车票:\" + key); ITicket ticket = new TrainTicket(from, to); pool.put(key, ticket); return ticket; } } // 测试 public static void main(String[] args) { ITicket ticket = getTicket(\"北京\", \"上海\"); //使用数据库获取火车票:北京->上海 //北京->上海:二等座价格:20 ticket.show(\"二等座\"); ITicket ticket1 = getTicket(\"北京\", \"上海\"); //使用缓存获取火车票:北京->上海 //北京->上海:商务座价格:69 ticket1.show(\"商务座\"); ITicket ticket2 = getTicket(\"上海\", \"北京\"); //使用数据库获取火车票:上海->北京 //上海->北京:一等座价格:406 ticket2.show(\"一等座\"); System.out.println(ticket == ticket1);//true System.out.println(ticket == ticket2);//false } 可以看到ticket和ticket2是使用数据库查询的，而ticket1是使用缓存查询的，同时ticket == ticket1返回的是true，ticket == ticket2返回的是false，证明ticket和ticket1是共享的对象。 7.2 总结 适用场景： 一个系统有大量相同或者相似的对象，造成内存的大量耗费。 对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。 在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。 优点： 减少对象的创建，降低内存中对象的数量，降低系统的内存，提高效率。 减少内存之外的其他资源占用。 缺点： 关注内、外部状态。 关注线程安全问题。 使系统、程序的逻辑复杂化。 三、行为型模式1.模板方法模式（Template method pattern）模板方法模式通常又叫模板模式，是指定义一个算法的骨架，并允许之类为其中的一个或者多个步骤提供实现。模板方法模式使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。 模板方法（Template Method）模式包含以下主要角色： 抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。 基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种： 抽象方法(Abstract Method) ：一个抽象方法由抽象类声明、由其具体子类实现。 具体方法(Concrete Method) ：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。 钩子方法(Hook Method) ：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXxx，返回值类型为boolean类型。 具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。 1.1 代码实现 下面以一个简单的请假流程来通过代码来实现： public abstract class DayOffProcess { // 请假模板 public final void dayOffProcess() { // 领取申请表 this.pickUpForm(); // 填写申请信息 this.writeInfo(); // 签名 this.signUp(); // 提交到不同部门审批 this.summit(); // 行政部备案 this.filing(); } private void filing() { System.out.println(\"行政部备案\"); } protected abstract void summit(); protected abstract void signUp(); private void writeInfo() { System.out.println(\"填写申请信息\"); } private void pickUpForm() { System.out.println(\"领取申请表\"); } } public class ZhangSan extends DayOffProcess { @Override protected void summit() { System.out.println(\"张三签名\"); } @Override protected void signUp() { System.out.println(\"提交到技术部审批\"); } } public class Lisi extends DayOffProcess { @Override protected void summit() { System.out.println(\"李四签名\"); } @Override protected void signUp() { System.out.println(\"提交到市场部审批\"); } } // 测试方法 public static void main(String[] args) { DayOffProcess zhangsan = new ZhangSan(); //领取申请表 //填写申请信息 //提交到技术部审批 //张三签名 //行政部备案 zhangsan.dayOffProcess(); DayOffProcess lisi = new Lisi(); //领取申请表 //填写申请信息 //提交到市场部审批 //李四签名 //行政部备案 lisi.dayOffProcess(); } 1.2 总结 适用场景： 一次性实现一个算法不变的部分，并将可变的行为留给子类来实现。 各子类中公共的行为被提取出来并集中到一个公共的父类中，从而避免代码重复。 优点： 利用模板方法将相同处理逻辑的代码放到抽象父类中，可以提高代码的复用性。 将不同的代码不同的子类中，通过对子类的扩展增加新的行为，提高代码的扩展性。 把不变的行为写在父类上，去除子类的重复代码，提供了一个很好的代码复用平台，符合开闭原则。 缺点： 类数目的增加，每一个抽象类都需要一个子类来实现，这样导致类的个数增加。 类数量的增加，间接地增加了系统实现的复杂度。 继承关系自身缺点，如果父类添加新的抽象方法，所有子类都要改一遍。 2.策略模式（Strategy Pattern）策略模式又叫政策模式（Policy Pattern），它是将定义的算法家族分别封装起来，让它们之间可以互相替换，从而让算法的变化不会影响到使用算法的用户。可以避免多重分支的if……else和switch语句。 策略模式的主要角色如下： 抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。 具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为。 环境（Context）类：持有一个策略类的引用，最终给客户端调用。 2.1 普通案例（会员卡打折） // 会员卡接口 public interface VipCard { public void discount(); } public class GoldCard implements VipCard { @Override public void discount() { System.out.println(\"金卡打7折\"); } } public class SilverCard implements VipCard { @Override public void discount() { System.out.println(\"银卡打8折\"); } } public class CopperCard implements VipCard { @Override public void discount() { System.out.println(\"铜卡打9折\"); } } public class Normal implements VipCard { @Override public void discount() { System.out.println(\"普通会员没有折扣\"); } } // 会员卡容器类 public class VipCardFactory { private static Map&lt;String, VipCard> map = new ConcurrentHashMap&lt;>(); static { map.put(\"gold\", new GoldCard()); map.put(\"silver\", new SilverCard()); map.put(\"copper\", new CopperCard()); } public static VipCard getVIPCard(String level) { return map.get(level) != null ? map.get(level) : new Normal(); } } // 测试方法 public static void main(String[] args) { //金卡打7折 VipCardFactory.getVIPCard(\"gold\").discount(); //银卡打8折 VipCardFactory.getVIPCard(\"silver\").discount(); //普通会员没有折扣 VipCardFactory.getVIPCard(\"other\").discount(); } 用一个容器（Map）装起来，可以通过传进来的参数直接获取对应的策略，避免了if…else。 2.2 支付方式案例 // 支付方式抽象类 public abstract class Payment { public String pay(String uid, double money) { double balance = queryBalance(uid); if (balance &lt; money) { return \"支付失败!余额不足!欠\" + (money - balance) + \"元!\"; } return \"支付成功!支付金额:\" + money + \"余额剩余:\" + (balance - money); } protected abstract String getPaymentName(); protected abstract double queryBalance(String uid); } // 现金支付 默认方式 public class Cash extends Payment{ @Override protected String getPaymentName() { return \"现金支付\"; } @Override protected double queryBalance(String uid) { return 1000; } } // 支付宝类 public class AliPay extends Payment { @Override protected String getPaymentName() { return \"支付宝\"; } @Override protected double queryBalance(String uid) { return 500; } } // 微信支付类 public class WeChatPay extends Payment { @Override protected String getPaymentName() { return \"微信支付\"; } @Override protected double queryBalance(String uid) { return 300; } } // 支付方式容器策略类 public class PaymentStrategy { private static Map&lt;String, Payment> map = new ConcurrentHashMap&lt;>(); static { map.put(\"WeChat\", new WeChatPay()); map.put(\"Ali\", new AliPay()); } public static Payment getPayment(String payment) { return map.get(payment) == null ? new Cash() : map.get(payment); } } // 订单交易类 @AllArgsConstructor public class Order { private String uid; private double amount; public String pay() { return pay(\"cash\"); } public String pay(String key) { Payment payment = PaymentStrategy.getPayment(key); System.out.println(\"欢迎使用\" + payment.getPaymentName()); System.out.println(\"本次交易金额:\" + this.amount + \",开始扣款...\"); return payment.pay(this.uid, this.amount); } } // 测试方法 public static void main(String[] args) { Order order = new Order(\"20221014001\", 500); //欢迎使用微信支付 //本次交易金额:500.0,开始扣款... //支付失败!余额不足!欠200.0元! System.out.println(order.pay(\"WeChat\")); //欢迎使用支付宝 //本次交易金额:500.0,开始扣款... //支付成功!支付金额:500.0余额剩余:0.0 System.out.println(order.pay(\"Ali\")); //欢迎使用现金支付 //本次交易金额:500.0,开始扣款... //支付成功!支付金额:500.0余额剩余:500.0 System.out.println(order.pay()); } 2.3 总结 适用场景： 系统中有很多类，而它们的区别仅仅在于它们的行为不同。 系统需要动态地在几种算法中选择一种。 需要屏蔽算法规则。 优点： 符合开闭原则。 避免使用多重条件语句。 可以提高算法的保密性和安全性。 易于扩展。 缺点： 客户端必须知道所有的策略，并且自行决定使用哪一个策略类。 代码中会产生非常多的策略类，增加维护难度。 3.命令模式（Command Pattern）命令模式是对命令的封装，每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行操作。命令模式解耦了请求方和接收方，请求方只需请求执行命令，不用关心命令是怎样被接收，怎样被操作以及是否被执行等。本质：解耦命令的请求与处理。 命令模式包含以下主要角色： 抽象命令类（Command）角色： 定义命令的接口，声明执行的方法。 具体命令（Concrete Command）角色：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。 实现者/接收者（Receiver）角色： 接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。 调用者/请求者（Invoker）角色： 要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。 3.1 代码实现 下面以一个播放器的例子来进行代码实现： // 播放器类 public class Player { public void play() { System.out.println(\"正常播放\"); } public void pause() { System.out.println(\"暂停播放\"); } public void stop() { System.out.println(\"停止播放\"); } } // 命令接口 public interface IAction { void excuse(); } // 播放命令类 @AllArgsConstructor public class PlayAction implements IAction { private Player player; @Override public void excuse() { this.player.play(); } } // 暂停命令类 @AllArgsConstructor public class PauseAction implements IAction { private Player player; @Override public void excuse() { this.player.pause(); } } // 停止命令类 @AllArgsConstructor public class StopAction implements IAction{ private Player player; @Override public void excuse() { this.player.stop(); } } // 控制器 public class Controller { public void excuse(IAction action) { action.excuse(); } } // 测试方法 public static void main(String[] args) { // 正常播放 new Controller().excuse(new PlayAction(new Player())); // 暂停播放 new Controller().excuse(new PauseAction(new Player())); // 停止播放 new Controller().excuse(new StopAction(new Player())); } 3.2 总结 适用场景： 现实语义中具备“命令”的操作（如命令菜单，shell命令…）。 请求调用者和请求接收者需要解耦，使得调用者和接收者不直接交互。 需要抽象出等待执行的行为，比如撤销操作和恢复操作等。 需要支持命令宏（即命令组合操作）。 优点： 通过引入中间件（抽象接口），解耦了命令的请求与实现。 扩展性良好，可以很容易地增加新命令。 支持组合命令，支持命令队列。 可以在现有的命令的基础上，增加额外功能。 缺点： 具体命令类可能过多。 增加 了程序的复杂度，理解更加困难。 4.职责链模式（chain of responsibility pattern）职责链模式是将链中每一个节点看作是一个对象，每个节点处理的请求均不同，且内部自动维护一个下一节点对象。当一个请求从链式的首端发出时，会沿着链的路径依次传递给每一个节点对象，直至有对象处理这个请求为止。 职责链模式主要包含以下角色： 抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。 具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。 客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。 4.1 代码实现 下面以一个简单的登录校验流程来通过代码进行实现： // 用户实体类 @Data public class User { private String username; private String password; private String role; } // handler抽象类 public abstract class Handler { protected Handler next; // 返回handler方便链式操作 public void next(Handler next) { this.next = next; } // 流程开始的方法 public abstract void doHandler(User user); } // 校验用户名或者密码是否为空 public class ValidateHandler extends Handler { @Override public void doHandler(User user) { if (StringUtils.isBlank(user.getUsername()) || StringUtils.isBlank(user.getPassword())) { System.out.println(\"用户名或者密码为空!\"); return; } System.out.println(\"校验通过\"); next.doHandler(user); } } // 登录校验，校验用户名是否匹配密码 public class LoginHandler extends Handler { @Override public void doHandler(User user) { if (!\"pyy52hz\".equals(user.getUsername()) || !\"123456\".equals(user.getPassword())) { System.out.println(\"用户名或者密码不正确!请检查!\"); return; } user.setRole(\"admin\"); System.out.println(\"登陆成功!角色为管理员!\"); next.doHandler(user); } } // 权限校验 public class AuthHandler extends Handler { @Override public void doHandler(User user) { if (!\"admin\".equals(user.getRole())) { System.out.println(\"无权限操作!\"); return; } System.out.println(\"角色为管理员,可以进行下一步操作!\"); } } // 登录流程 public class LoginService { public void login(User user) { Handler validateHandler = new ValidateHandler(); Handler loginHandler = new LoginHandler(); Handler authHandler = new AuthHandler(); validateHandler.next(loginHandler); loginHandler.next(authHandler); validateHandler.doHandler(user); } } // 测试方法 public static void main(String[] args){ User user = new User(); //校验通过 //用户名或者密码不正确!请检查! user.setUsername(\"pyy52hz\"); user.setPassword(\"1234567\"); LoginService loginService = new LoginService(); loginService.login(user); //校验通过 //登陆成功!角色为管理员! //角色为管理员,可以进行下一步操作! user.setUsername(\"pyy52hz\"); user.setPassword(\"123456\"); loginService.login(user); } 4.3 结合建造者模式 与基础版本区别主要是Handler类中新增一个Builder的内部类，以及流程类里改用链式写法，具体如下： // handler抽象类 public abstract class Handler&lt;T> { protected Handler next; // 返回handler方便链式操作 public Handler next(Handler next) { this.next = next; return next; } // 流程开始的方法 public abstract void doHandler(User user); static class Builder&lt;T> { private Handler&lt;T> head; private Handler&lt;T> tail; public Builder&lt;T> addHandler(Handler&lt;T> handler) { if (this.head == null) { this.head = this.tail = handler; return this; } this.tail.next(handler); this.tail = handler; return this; } public Handler&lt;T> build() { return this.head; } } } public class LoginService { public void login(User user) { Handler.Builder builder = new Handler.Builder(); builder.addHandler(new ValidateHandler()) .addHandler(new LoginHandler()) .addHandler(new AuthHandler()); builder.build().doHandler(user); } } 4.4 总结 适用场景： 多个对象可以处理同一请求，但具体由哪个对象处理则在运行时动态决定。 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 可动态指定一组对象处理请求。 优点： 将请求与处理解耦。 请求处理者（节点对象）只需关注自己感兴趣的请求进行处理即可，对于不感兴趣的请求，直接转发给下一级节点对象。 具备链式传递处理请求功能，请求发送者无需知晓链路结构，只需等待请求处理结果。 链路结构灵活，可以通过改变链路结构动态地新增或删减责任。 易于扩展新的请求处理类（节点），符合开闭原则。 缺点： 责任链太长或者处理时间过长，会影响整体性能。 如果节点对象存在循环引用时，会造成死循环，导致系统崩溃。 5.状态模式（State Pattern）状态模式也称为状态机模式（State Machine Pattern），是允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。 状态模式包含以下主要角色： 环境（Context）角色：也称为上下文，它定义了客户程序需要的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。 抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。 具体状态（Concrete State）角色：实现抽象状态所对应的行为。 5.1 代码实现 // 电梯状态 public abstract class LiftState { protected Context context; public abstract void open(); public abstract void close(); public abstract void run(); public abstract void stop(); } // 开门状态 public class OpenState extends LiftState { @Override public void open() { System.out.println(\"电梯门打开了\"); } @Override public void close() { super.context.setLiftState(Context.CLOSE_STATE); super.context.close(); } @Override public void run() { } @Override public void stop() { } } // 关门状态 public class CloseState extends LiftState { @Override public void open() { super.context.setLiftState(Context.OPEN_STATE); super.context.open(); } @Override public void close() { System.out.println(\"电梯门关闭了!\"); } @Override public void run() { super.context.setLiftState(Context.RUN_STATE); super.context.run(); } @Override public void stop() { super.context.setLiftState(Context.STOP_STATE); super.context.stop(); } } // 运行状态 public class RunState extends LiftState { @Override public void open() { } @Override public void close() { } @Override public void run() { System.out.println(\"电梯正在运行...\"); } @Override public void stop() { super.context.setLiftState(Context.STOP_STATE); super.context.stop(); } } // 停止状态 public class StopState extends LiftState { @Override public void open() { super.context.setLiftState(Context.OPEN_STATE); super.context.open(); } @Override public void close() { super.context.setLiftState(Context.CLOSE_STATE); super.context.close(); } @Override public void run() { super.context.setLiftState(Context.RUN_STATE); super.context.run(); } @Override public void stop() { System.out.println(\"电梯停止了!\"); } } // 上下文 public class Context { private LiftState liftState; public static final LiftState OPEN_STATE = new OpenState(); public static final LiftState CLOSE_STATE = new CloseState(); public static final LiftState RUN_STATE = new RunState(); public static final LiftState STOP_STATE = new StopState(); public void setLiftState(LiftState liftState) { this.liftState = liftState; this.liftState.setContext(this); } public void open() { this.liftState.open(); } public void close() { this.liftState.close(); } public void run() { this.liftState.run(); } public void stop() { this.liftState.stop(); } } // 测试 public static void main(String[] args){ Context context = new Context(); context.setLiftState(new CloseState()); //电梯门打开了 //电梯门关闭了! //电梯正在运行... //电梯停止了! context.open(); context.close(); context.run(); context.stop(); } 5.2 spring的状态机 // Todo 5.3 总结 适用场景： 行为随状态改变而改变的场景。 一个操作中含有庞大的多分支结构，并且这些分支取决于对象的状态。 优点： 结构清晰：将状态独立为类，消除了冗余的if…else或switch…case语句，使代码更加简洁，提高系统可维护性。 将状态转换显示化：通常的对象内部都是使用数值类型来定义状态，状态的切换是通过赋值进行表现，不够直观；而使用状态类，在切换状态时，是以不同的类进行表示，转换目的更加明确。 状态类职责明确且具备扩展性。 缺点： 类膨胀：如果一个事物具备很多状态，则会造成状态类太多。 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 状态模式对开闭原则的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。 6.观察者模式（Observer Mode）观察者模式，又叫发布-订阅（Publish/Subscribe）模式，模型-视图（Model/View）模式，源-监听器（Source/Listener）模式或从属者（Dependents）模式。定义一种一对多的依赖关系，一个主题对象可被多个观察者同时监听，使得每当主题对象状态变化时，所有依赖于它的对象都会得到通知并被自动更新。 6.1 代码实现 通过一个微信用户（观察者）订阅公众号（被观察者）接收公众号推送消息的例子来进行简单的代码实现： // 抽象观察者接口 public interface Observer { void update(String message); } // 微信用户类 具体的观察者 @AllArgsConstructor public class WeixinUser implements Observer { private String name; @Override public void update(String message) { System.out.println(name + \"接收到了消息(观察到了):\" + message); } } // 被观察者接口 public interface Observable { // 新增用户(新增观察者) void add(Observer observer); // 移除用户,或者说用户取消订阅(移除观察者) void del(Observer observer); // 发布 推送消息 void notify(String message); } // 具体的被观察者(公众号) public class Subject implements Observable { // 观察者列表(订阅用户) private List&lt;Observer> list = new ArrayList&lt;>(); @Override public void add(Observer observer) { list.add(observer); } @Override public void del(Observer observer) { list.remove(observer); } // 给每一个观察者(订阅者)推送消息 @Override public void notify(String message) { list.forEach(observer -> observer.update(message)); } } // 测试 public static void main(String[] args){ Observable o = new Subject(); WeixinUser user1 = new WeixinUser(\"张三\"); WeixinUser user2 = new WeixinUser(\"李四\"); WeixinUser user3 = new WeixinUser(\"王五\"); o.add(user1); o.add(user2); o.add(user3); o.notify(\"薛之谦演唱会要来到广州啦!\"); // 运行结果 // 张三接收到了消息(观察到了):薛之谦演唱会要来到广州啦! // 李四接收到了消息(观察到了):薛之谦演唱会要来到广州啦! // 王五接收到了消息(观察到了):薛之谦演唱会要来到广州啦! } 6.2 JDK实现 在 Java 中，通过java.util.Observable类和 java.util.Observer接口定义了观察者模式，只要实现它们的子类就可以编写观察者模式实例。 6.2.1 Observable类 Observable类是抽象目标类（被观察者），它有一个Vector集合成员变量，用于保存所有要通知的观察者对象，下面是它最重要的 3 个方法：void addObserver(Observer o) 方法：用于将新的观察者对象添加到集合中。void notifyObservers(Object arg) 方法：调用集合中的所有观察者对象的update方法，通知它们数据发生改变。通常越晚加入集合的观察者越先得到通知。void setChange() 方法：用来设置一个boolean类型的内部标志，注明目标对象发生了变化。当它为true时，notifyObservers() 才会通知观察者。 6.2.2 Observer 接口 Observer 接口是抽象观察者，它监视目标对象的变化，当目标对象发生变化时，观察者得到通知，并调用 update 方法，进行相应的工作。 6.2.3 代码实现 下面还是通过微信用户订阅公众号的例子进行代码实现，方便对比他们之间的区别： // 具体的被观察者(公众号) @Data @AllArgsConstructor public class Subject extends Observable { // 公众号的名字 private String name; // 公众号发布消息 public void notifyMessage(String message) { System.out.println(this.name + \"公众号发布消息:\" + message + \"请关注用户留意接收!\"); super.setChanged(); super.notifyObservers(message); } } @AllArgsConstructor public class WeixinUser implements Observer { private String name; /** * @param o 被观察者 * @param arg 被观察者带过来的参数，此例子中是公众号发布的消息 */ @Override public void update(Observable o, Object arg) { System.out.println(name + \"关注了公众号(被观察者):\" + ((Subject)o).getName() + \",接收到消息:\" + arg); } } // 测试 public static void main(String[] args){ WeixinUser user1 = new WeixinUser(\"张三\"); WeixinUser user2 = new WeixinUser(\"李四\"); WeixinUser user3 = new WeixinUser(\"王五\"); Subject subject = new Subject(\"演唱会消息发布\"); subject.addObserver(user1); subject.addObserver(user2); subject.addObserver(user3); subject.notifyMessage(\"薛之谦演唱会要来到广州啦!\"); // 返回结果 // 演唱会消息发布公众号发布消息:薛之谦演唱会要来到广州啦!请关注用户留意接收! // 王五关注了公众号(被观察者):演唱会消息发布,接收到消息:薛之谦演唱会要来到广州啦! // 李四关注了公众号(被观察者):演唱会消息发布,接收到消息:薛之谦演唱会要来到广州啦! // 张三关注了公众号(被观察者):演唱会消息发布,接收到消息:薛之谦演唱会要来到广州啦! } 6.3 Google的Guava实现 EventBus 术语 解释 备注 事件（消息） 可以向事件总线（EventBus）发布的对象 通常是一个类，不同的消息事件用不同的类来代替，消息内容就是类里面的属性 订阅 向事件总线注册监听者，以接受事件的行为 EventBus.register(Object)，参数就是监听者 监听者 提供一个处理方法，希望接受和处理事件的对象 通常也是一个类，里面有消息的处理方法 处理方法 监听者提供的公共方法，事件总线使用该方法向监听者发送事件；该方法应使用 Subscribe 注解 监听者里面添加一个 Subscribe 注解的方法，就可以认为是消息的处理方法 发布消息 通过事件总线向所有匹配的监听者提供事件 EventBus.post(Object) @AllArgsConstructor public class WeixinUser { private String name; @Subscribe public void getMessage(Object arg) { System.out.println(this.name + \"接收到消息:\" + arg); } // 测试 public static void main(String[] args){ // 消息总线 EventBus eventBus = new EventBus(); eventBus.register(new WeixinUser(\"张三\")); eventBus.register(new WeixinUser(\"李四\")); eventBus.post(\"薛之谦演唱会要来到广州啦!\"); // 返回结果 // 张三接收到消息:薛之谦演唱会要来到广州啦! // 李四接收到消息:薛之谦演唱会要来到广州啦! } } 6.4 总结 适用场景： 当一个抽象模型包含两个方面内容，其中一个方面依赖于另一个方面。 其他一个或多个对象的变化依赖于另一个对象的变化。 实现类似广播机制的功能，无需知道具体收听者，只需分发广播，系统中感兴趣的对象会自动接收该广播。 多层级嵌套使用，形成一种链式触发机制，使得事件具备跨域（跨越两种观察者类型）通知。 优点： 观察者和被观察者是松耦合（抽象耦合）的，符合依赖倒置原则。 分离了表示层（观察者）和数据逻辑层（被观察者），并且建立了一套触发机制，使得数据的变化可以相应到多个表示层上。 实现了一对多的通讯机制，支持事件注册机制，支持兴趣分发机制，当被观察者触发事件时，只有感兴趣的观察者可以接收到通知。 缺点： 如果观察者数量过多，则事件通知会耗时较长。 事件通知呈线性关系，如果其中一个观察者处理事件卡壳，会影响后续的观察者接收该事件。 如果观察者和被观察者之间存在循环依赖，则可能造成两者之间的循环调用，导致系统崩溃。 7.中介者模式（mediator pattern）中介者模式又称为调解者模式或调停者模式。用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 核心：通过中介者解耦系统各层次对象的直接耦合，层次对象的对外依赖通信统统交由中介者转发。 中介者模式包含以下主要角色： 抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。 具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。 抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。 具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。 7.1 代码实现 通过一个租房例子简单实现下逻辑，房主通过中介公司发布自己的房子的信息，而租客则需要通过中介公司获取到房子的信息： // 抽象同事类 @AllArgsConstructor public class Person { protected String name; protected MediatorCompany mediatorCompany; } // 房主 public class HouseOwner extends Person { public HouseOwner(String name, MediatorCompany mediatorCompany) { super(name, mediatorCompany); } // 联络方法 public void connection(String message) { mediatorCompany.connection(this, message); } // 获取消息 public void getMessage(String message) { System.out.println(\"房主\" + name + \"获取到的信息:\" + message); } } // 租客 public class Tenant extends Person { public Tenant(String name, MediatorCompany mediatorCompany) { super(name, mediatorCompany); } public void connection(String message) { mediatorCompany.connection(this, message); } public void getMessage(String message) { System.out.println(\"租客\" + name + \"获取到的信息:\" + message); } } // 中介公司(中介者) @Data public class MediatorCompany { private HouseOwner houseOwner; private Tenant tenant; public void connection(Person person, String message) { // 房主需要通过中介获取租客信息 if (person.equals(houseOwner)) { this.tenant.getMessage(message); } else { // 反之租客通过中介获取房主信息 this.houseOwner.getMessage(message); } } } // 测试 public static void main(String[] args){ // 先创建三个角色，中介公司，房主，租客 MediatorCompany mediatorCompany = new MediatorCompany(); // 房主和租客都在同一家中介公司 HouseOwner houseOwner = new HouseOwner(\"张三\", mediatorCompany); Tenant tenant = new Tenant(\"李四\", mediatorCompany); // 中介公司获取房主和租客的信息 mediatorCompany.setHouseOwner(houseOwner); mediatorCompany.setTenant(tenant); // 房主和租客都在这家中介公司发布消息，获取到对应的消息 tenant.connection(tenant.name + \"想租一房一厅!\"); houseOwner.connection(houseOwner.name + \"这里有!来看看呗!\"); // 测试结果 // 房主张三获取到的信息:李四想租一房一厅! // 租客李四获取到的信息:张三这里有!来看看呗! } 7.2 总结 适用场景： 系统中对象之间存在复杂的引用关系，产生的我相互依赖关系结构混乱且难以理解。 交互的公共行为，如果需要改变行为则可以增加新的中介者类。 优点： 减少类间的依赖，将多对多依赖转化成了一对多，降低了类间耦合。 类间各司其职，符合迪米特法则。 缺点： 中介者模式中将原本多个对象直接的相互依赖变成了中介者和多个同事类的依赖关系。当同事类越多时，中介者就会越臃肿，变得复杂且难以维护。 8.迭代器模式（Iterator Pattern）迭代器模式又称为游标模式（Cursor Pattern），它提供一种顺序访问集合/容器对象元素的方法，而又无须暴露结合内部表示。 本质：抽离集合对象迭代行为到迭代器中，提供一致访问接口。 迭代器模式主要包含以下角色： 抽象聚合（Aggregate）角色：定义存储、添加、删除聚合元素以及创建迭代器对象的接口。 具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。 抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、next() 等方法。 具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。 8.1 代码实现 // 迭代器接口 public interface Iterator&lt;T> { Boolean hasNext(); T next(); } // 迭代器接口实现类 public class IteratorImpl&lt;T> implements Iterator&lt;T> { private List&lt;T> list; private Integer cursor; private T element; public IteratorImpl(List&lt;T> list) { this.list = list; } @Override public Boolean hasNext() { return cursor &lt; list.size(); } @Override public T next() { element = list.get(cursor); cursor++; return element; } } // 容器接口 public interface Aggregate&lt;T> { void add(T t); void remove(T t); Iterator&lt;T> iterator(); } // 容器接口实现类 public class AggregateImpl&lt;T> implements Aggregate&lt;T> { private List&lt;T> list = new ArrayList&lt;>(); @Override public void add(T t) { list.add(t); } @Override public void remove(T t) { list.remove(t); } @Override public Iterator&lt;T> iterator() { return new IteratorImpl&lt;>(list); } } PS：具体测试的话可以自己写一个集合测试一下即可 8.2 总结 适用场景： 访问一个集合对象的内容而无需暴露它的内部表示。 为遍历不同的集合结构提供一个统一的访问接口。 优点： 多态迭代：为不同的聚合结构提供一致的遍历接口，即一个迭代接口可以访问不同的聚集对象。 简化集合对象接口：迭代器模式将集合对象本身应该提供的元素迭代接口抽取到了迭代器中，使集合对象无须关心具体迭代行为。 元素迭代功能多样化：每个集合对象都可以提供一个或多个不同的迭代器，使的同种元素聚合结构可以有不同的迭代行为。 解耦迭代与集合：迭代器模式封装了具体的迭代算法，迭代算法的变化，不会影响到集合对象的架构。 缺点： 对于比较简单的遍历（像数组或者有序列表），使用迭代器方式遍历较为繁琐。 增加了类的个数，在一定程度上增加了系统的复杂性。 9.访问者模式（Visitor Pattern）访问者模式是一种将数据结构与数据操作分离的设计模式。是指封装一些作用于某种数据结构中的各元素的操作。 特征：可以在不改变数据结构的前提下定义作用于这些元素的新的操作。 访问者模式包含以下主要角色: 抽象访问者（Visitor）角色：定义了对每一个元素 （Element） 访问的行为，它的参数就是可以访问的元素，它的方法个数理论上来讲与元素类个数（Element的实现类个数）是一样的，从这点不难看出，访问者模式要求元素类的个数不能改变。 具体访问者（ConcreteVisitor）角色：给出对每一个元素类访问时所产生的具体行为。 抽象元素（Element）角色：定义了一个接受访问者的方法（ accept ），其意义是指，每一个元素都要可以被访问者访问。 具体元素（ConcreteElement）角色： 提供接受访问方法的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。 对象结构（Object Structure）角色：定义当中所提到的对象结构，对象结构是一个抽象表述，具体点可以理解为一个具有容器性质或者复合对象特性的类，它会含有一组元素（ Element ），并且可以迭代这些元素，供访问者访问。 9.1 代码实现 // 访问者接口 public interface IVisitor { void visit(Engineer engineer); void visit(Pm pm); } // 具体的访问者类,访问者角色(CEO) public class CeoVisitor implements IVisitor { @Override public void visit(Engineer engineer) { System.out.println(engineer.getName() + \"KPI为:\" + engineer.getKpi()); } @Override public void visit(Pm pm) { System.out.println(pm.getName() + \"KPI为:\" + pm.getKpi()); } } // 具体的访问者类,访问者角色(CTO) public class CtoVisitor implements IVisitor { @Override public void visit(Engineer engineer) { System.out.println(engineer.getName() + \"工作内容:\" + engineer.getCodeLine() + \"行代码\"); } @Override public void visit(Pm pm) { System.out.println(pm.getName() + \"工作内容:\" + pm.getProject() + \"个项目\"); } } @Data // 抽象元素(员工) public abstract class Employee { private String name; private Integer kpi; public Employee(String name) { this.name = name; this.kpi = new Random().nextInt(10); } public abstract void accept(IVisitor visitor); } // 具体元素(程序员) public class Engineer extends Employee { public Engineer(String name) { super(name); } @Override public void accept(IVisitor visitor) { visitor.visit(this); } public Integer getCodeLine() { return new Random().nextInt(10000); } } // 具体元素(项目经理) public class Pm extends Employee { public Pm(String name) { super(name); } @Override public void accept(IVisitor visitor) { visitor.visit(this); } public Integer getProject() { return new Random().nextInt(10); } } @AllArgsConstructor public class Report { private List&lt;Employee> employeeList; public void showReport(IVisitor visitor) { for (Employee employee : employeeList) { employee.accept(visitor); } } } // 测试 public static void main(String[] args){ List&lt;Employee> employeeList = new ArrayList&lt;>(); employeeList.add(new Engineer(\"工程师A\")); employeeList.add(new Engineer(\"工程师B\")); employeeList.add(new Pm(\"项目经理A\")); employeeList.add(new Engineer(\"工程师C\")); employeeList.add(new Engineer(\"工程师D\")); employeeList.add(new Pm(\"项目经理B\")); Report report = new Report(employeeList); System.out.println(\"=============CEO==============\"); report.showReport(new CeoVisitor()); System.out.println(\"=============CTO==============\"); report.showReport(new CtoVisitor()); // =============CEO============== // 工程师AKPI为:2 // 工程师BKPI为:4 // 项目经理AKPI为:4 // 工程师CKPI为:2 // 工程师DKPI为:0 // 项目经理BKPI为:0 // =============CTO============== // 工程师A工作内容:5811行代码 // 工程师B工作内容:9930行代码 // 项目经理A工作内容:7个项目 // 工程师C工作内容:4591行代码 // 工程师D工作内容:333行代码 // 项目经理B工作内容:4个项目 } 9.2 伪动态双分派 访问者模式用到了一种伪动态双分派的技术。 9.2.1 分派 变量被声明时的类型叫做变量的静态类型，有些人又把静态类型叫做明显类型；而变量所引用的对象的真实类型又叫做变量的实际类型。比如Map map = new HashMap() ，map变量的静态类型是Map，实际类型是 HashMap 。根据对象的类型而对方法进行的选择，就是分派(Dispatch)，分派(Dispatch)又分为两种，即静态分派和动态分派。 静态分派(Static Dispatch) 发生在编译时期，分派根据静态类型信息发生。静态分派对于我们来说并不陌生，方法重载就是静态分派。 动态分派(Dynamic Dispatch) 发生在运行时期，动态分派动态地置换掉某个方法。Java通过方法的重写支持动态分派。 9.2.2 伪动态双分派 所谓双分派技术就是在选择一个方法的时候，不仅仅要根据消息接收者（receiver）的运行时区别，还要根据参数的运行时区别。 在上面代码中，客户端将IVisitor接口做为参数传递给Employee抽象类的变量调用的方法，这里完成第一次分派，这里是方法重写，所以是动态分派，也就是执行实际类型中的方法，同时也将自己this作为参数传递进去，这里就完成了第二次分派 ，这里的IVisitor接口中有多个重载的方法，而传递进行的是this，就是具体的实际类型的对象。 双分派实现动态绑定的本质，就是在重载方法委派的前面加上了继承体系中覆盖的环节，由于覆盖是动态的，所以重载就是动态的了。 9.3 总结 适用场景： 数据结构稳定，作用于数据结构的操作经常变化的场景。 需要数据结构与数据操作分离的场景。 需要对不同数据类型（元素）进行操作，而不使用分支判断具体类型的场景。 优点： 解耦了数据结构与数据操作，使得操作集合可以独立变化。 扩展性好：可以通过扩展访问者角色，实现对数据集的不同操作。 元素具体类型并非单一，访问者均可操作。 各角色职责分离，符合单一职责原则。 缺点： 无法增加元素类型：若系统数据结构对象易于变化，经常有新的数据对象增加进来，则访问者类必须增加对应元素类型的操作，违背了开闭原则。 具体元素变更困难：具体元素增加属性，删除属性等操作会导致对应的访问者类需要进行相应的修改，尤其当有大量访问者类时，修改访问太大。 违背依赖倒置原则：为了达到“区别对待”，访问者依赖的是具体元素类型，而不是抽象。 10.备忘录模式（Memento Pattern）备忘录模式又称为快照模式（Snapshot Pattern）或令牌模式（Token Pattern），是指在不破坏封装的前提下，捕获一个对象的内部状态，并在对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态。 特征：“后悔药” 备忘录模式的主要角色如下： 发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。 备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。 管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。 备忘录有两个等效的接口： 窄接口：管理者(Caretaker)对象（和其他发起人对象之外的任何对象）看到的是备忘录的窄接口(narror Interface)，这个窄接口只允许他把备忘录对象传给其他的对象。 宽接口：与管理者看到的窄接口相反，发起人对象可以看到一个宽接口(wide Interface)，这个宽接口允许它读取所有的数据，以便根据这些数据恢复这个发起人对象的内部状态。 10.1 “白箱”备忘录模式 下面就以游戏打怪为简单的例子进行代码实现（下面“黑箱”同这个例子）： 备忘录角色对任何对象都提供一个宽接口，备忘录角色的内部所存储的状态就对所有对象公开。 // 游戏角色类 @Data public class GameRole { private Integer vit; // 生命力 private Integer atk; // 攻击力 private Integer def; // 防御力 // 初始化状态 public void init() { this.vit = 100; this.atk = 100; this.def = 100; } // 战斗到0 public void fight() { this.vit = 0; this.atk = 0; this.def = 0; } // 保存角色状态 public RoleStateMemento saveState() { return new RoleStateMemento(this.vit, this.atk, this.def); } // 回复角色状态 public void recoverState(RoleStateMemento roleStateMemento) { this.vit = roleStateMemento.getVit(); this.atk = roleStateMemento.getAtk(); this.def = roleStateMemento.getDef(); } // 展示状态 public void showState() { System.out.println(\"角色生命力:\" + this.vit); System.out.println(\"角色攻击力:\" + this.atk); System.out.println(\"角色防御力:\" + this.def); } } // 游戏状态存储类(备忘录类) @Data @AllArgsConstructor public class RoleStateMemento { private Integer vit; // 生命力 private Integer atk; // 攻击力 private Integer def; // 防御力 } // 角色状态管理者类 @Data public class RoleStateCaretaker { private RoleStateMemento roleStateMemento; } // 测试结果 public static void main(String[] args){ System.out.println(\"===========打boss前状态===========\"); GameRole gameRole = new GameRole(); gameRole.init(); gameRole.showState(); // 保存进度 RoleStateCaretaker roleStateCaretaker = new RoleStateCaretaker(); roleStateCaretaker.setRoleStateMemento(gameRole.saveState()); System.out.println(\"===========打boss后状态===========\"); gameRole.fight(); gameRole.showState(); System.out.println(\"===========恢复状态===========\"); gameRole.recoverState(roleStateCaretaker.getRoleStateMemento()); gameRole.showState(); // ===========打boss前状态=========== // 角色生命力:100 // 角色攻击力:100 // 角色防御力:100 // ===========打boss后状态=========== // 角色生命力:0 // 角色攻击力:0 // 角色防御力:0 // ===========恢复状态=========== // 角色生命力:100 // 角色攻击力:100 // 角色防御力:100 } “白箱”备忘录模式是破坏封装性的，但是通过程序员自律，同样可以在一定程度上实现大部分的用意。 10.2 “黑箱”备忘录模式 备忘录角色对发起人对象提供了一个宽接口，而为其他对象提供一个窄接口，在Java语言中，实现双重接口的办法就是将备忘录类设计成发起人类的内部成员类。 将RoleStateMemento设为GameRole的内部类，从而将RoleStateMemento对象封装在GameRole 里面；在外面提供一个标识接口Memento给RoleStateCaretaker及其他对象使用。这样GameRole类看到的是RoleStateMemento所有的接口，而RoleStateCaretaker及其他对象看到的仅仅是标识接口Memento所暴露出来的接口，从而维护了封装型。 // 窄接口,标识接口 public interface Memento { } // 角色状态管理者类 @Data public class RoleStateCaretaker { private Memento memento; } // 游戏角色类 @Data public class GameRole { private Integer vit; // 生命力 private Integer atk; // 攻击力 private Integer def; // 防御力 // 初始化状态 public void init() { this.vit = 100; this.atk = 100; this.def = 100; } // 战斗到0 public void fight() { this.vit = 0; this.atk = 0; this.def = 0; } // 保存角色状态 public RoleStateMemento saveState() { return new RoleStateMemento(this.vit, this.atk, this.def); } // 回复角色状态 public void recoverState(Memento memento) { RoleStateMemento roleStateMemento = (RoleStateMemento) memento; this.vit = roleStateMemento.getVit(); this.atk = roleStateMemento.getAtk(); this.def = roleStateMemento.getDef(); } // 展示状态 public void showState() { System.out.println(\"角色生命力:\" + this.vit); System.out.println(\"角色攻击力:\" + this.atk); System.out.println(\"角色防御力:\" + this.def); } // 备忘录内部类 @Data @AllArgsConstructor private class RoleStateMemento implements Memento { private Integer vit; // 生命力 private Integer atk; // 攻击力 private Integer def; // 防御力 } } // 测试结果 public static void main(String[] args){ System.out.println(\"===========打boss前状态===========\"); GameRole gameRole = new GameRole(); gameRole.init(); gameRole.showState(); // 保存进度 RoleStateCaretaker roleStateCaretaker = new RoleStateCaretaker(); roleStateCaretaker.setMemento(gameRole.saveState()); System.out.println(\"===========打boss后状态===========\"); gameRole.fight(); gameRole.showState(); System.out.println(\"===========恢复状态===========\"); gameRole.recoverState(roleStateCaretaker.getMemento()); gameRole.showState(); // ===========打boss前状态=========== // 角色生命力:100 // 角色攻击力:100 // 角色防御力:100 // ===========打boss后状态=========== // 角色生命力:0 // 角色攻击力:0 // 角色防御力:0 // ===========恢复状态=========== // 角色生命力:100 // 角色攻击力:100 // 角色防御力:100 } 10.3 总结 适用场景： 需要保存历史快照的场景。 希望在对象之外保存状态，且除了自己其他类对象无法访问状态保存具体内容。 优点： 简化发起人实体类职责，隔离状态存储与获取，实现了信息的封装，客户端无需关心状态的保存细节。 提供状态回滚功能。 缺点： 消耗资源：如果需要保存的状态过多时，每一次保存都会消耗很多内存。 11.解释器模式（interpreter pattern）解释器模式给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 特征：为了解释一种语言，而为语言创建的解释器。 解释器模式包含以下主要角色： 抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。 终结符表达式（Terminal Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。 非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。 环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。 客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。 11.1 代码实现 下面以简单的加减乘除为例子实现解释器模式： // 抽象角色 定义解释器 public interface Expression { int interpret(); } @AllArgsConstructor public class NumberTerminal implements Expression { private int number; @Override public int interpret() { return this.number; } } // 非终结表达式（抽象类） @AllArgsConstructor public abstract class NonTerminal implements Expression { protected Expression left; protected Expression right; } // 非终结表达式（加法） public class PlusNonTerminal extends NonTerminal implements Expression { public PlusNonTerminal(Expression left, Expression right) { super(left, right); } @Override public int interpret() { return left.interpret() + right.interpret(); } } // 非终结表达式（减法） public class MinusNonTerminal extends NonTerminal implements Expression { public MinusNonTerminal(Expression left, Expression right) { super(left, right); } @Override public int interpret() { return left.interpret() - right.interpret(); } } // 非终结表达式（乘法） public class MclNonTerminal extends NonTerminal implements Expression { public MclNonTerminal(Expression left, Expression right) { super(left, right); } @Override public int interpret() { return left.interpret() * right.interpret(); } } // 非终结表达式（除法） public class DivisionNonTerminal extends NonTerminal implements Expression { public DivisionNonTerminal(Expression left, Expression right) { super(left, right); } @Override public int interpret() { return left.interpret() / right.interpret(); } } // 计算器类（实现运算逻辑） public class Cal { private Expression left; private Expression right; private Integer result; public Cal(String expression) { this.parse(expression); } private Integer parse(String expression) { // 获取表达式元素 String [] elements = expression.split(\" \"); for (int i = 0; i &lt; elements.length; i++) { String element = elements[i]; // 判断是否是运算符号 if (OperatorUtils.isOperator(element)) { // 运算符号的右边就是右终结符 right = new NumberTerminal(Integer.valueOf(elements[++i])); //计算结果 result = OperatorUtils.getNonTerminal(left, right, element).interpret(); // 计算结果重新成为左终结符 left = new NumberTerminal(result); } else { left = new NumberTerminal(Integer.valueOf(element)); } } return result; } public Integer cal() { return result; } } // 操作工具类 public class OperatorUtils { // 判断是不是非终结符 public static boolean isOperator(String symbol) { return symbol.equals(\"+\") || symbol.equals(\"-\") || symbol.equals(\"*\")|| symbol.equals(\"/\"); } // 简单工厂 public static NonTerminal getNonTerminal(Expression left, Expression right, String symbol) { if (symbol.equals(\"+\")) { return new PlusNonTerminal(left, right); } else if (symbol.equals(\"-\")) { return new MinusNonTerminal(left, right); } else if (symbol.equals(\"*\")) { return new MclNonTerminal(left, right); } else if (symbol.equals(\"/\")) { return new DivisionNonTerminal(left, right); } return null; } } // 测试 // PS：此处进行的逻辑仅仅实现从左到右运算，并没有先乘除后加减的逻辑 public static void main(String[] args) { System.out.println(new Cal(\"10 + 20 - 40 * 60\").cal()); // -600 System.out.println(new Cal(\"20 + 50 - 60 * 2\").cal()); // 20 } 11.2 Spring中的解释器模式 public static void main(String[] args) { ExpressionParser expressionParser = new SpelExpressionParser(); org.springframework.expression.Expression expression = expressionParser.parseExpression(\"10 + 20 + 30 * 4\"); Integer value = expression.getValue(Integer.class); System.out.println(value); // 150 expression = expressionParser.parseExpression(\"(10+20+30)*4\"); value = expression.getValue(Integer.class); System.out.println(value); // 240 } 可以看到Spring中解释器写的是比较完善的，不仅有先乘除后加减和先括号进行运算的日常计算规则，而且对于空格也并没有要求，仅需要写出完整的表达式即可运算出来。 11.3 总结 适用场景： 一些重复出现的问题可以用一种简单的语言来进行表述。 一个简单语法需要解释的场景。 优点： 扩展性强：在解释器模式中由于语法是由很多类表示的，当语法规则更改时，只需修改相应的非终结符表达式即可；若扩展语法时，只需添加相应非终结符类即可。 增加了新的解释表达式的方式。 易于实现文法：解释器模式对应的文法应当是比较简单且易于实现的，过于复杂的语法并不适合使用解释器模式。 缺点： 语法规则较复杂时，会引起类膨胀。 执行效率比较低","categories":[{"name":"Java","slug":"Java","permalink":"https://liaoxingwang.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://liaoxingwang.github.io/tags/Java/"}],"author":"廖兴旺"},{"title":"职场杂谈","slug":"Blog-Open-Source-Workplace","date":"2024-04-14T21:20:00.000Z","updated":"2024-12-19T06:53:09.547Z","comments":true,"path":"2024/04/15/blog-open-source-workplace/","link":"","permalink":"https://liaoxingwang.github.io/2024/04/15/blog-open-source-workplace/","excerpt":"","text":"职场如战场，尤其在不稳定的环境下，有时候说错一句话，可能就丢了工作。尤其在面对上级或老板时。 昨天一位读者留言：今天开会时，老板谈到一个新项目，说让技术看下可行性，听了老板的一顿介绍，没等上级说话，旁边同事就顺嘴说了一句：这个我们没做过呀。上级狠狠瞪了他一眼。 这个现象在职场中经常会发生，往往祸从口出，但很多人还不知道自己错在哪里。 我们首先要明确一点，工作是来解决问题的。 说得现实一点，解决问题后能创造利润，才是你的职场价值。 其实赚钱的本质是能帮多少人解决问题，你来工作是帮老板解决问题，不是来听你抱怨，发牢骚的。 说话是一门艺术，话说对了，能让你直上青云，说错了，会被列入黑名单。 职场中这几句话是雷区，初入职场的人千万不要踩到。 1.这个我之前没做过 技能是在工作和生活中一点点积攒起来的，谁也不是天生就会，我们要适配工作，而不是让工作来适配我们。 遇到自己不会的，利用一切资源学习，积极寻求同事或领导的帮助，让大家看到你的潜力和勤奋才对。 2.这也不是我的错啊 这话听起来就是在抱怨，同时想推卸责任。 领导会觉得你不想担事，以后交代任务也害怕交到你手上。 正确的做法是，保持冷静，精简的说出事情的来龙去脉和问题所在，真实说明情况，要知道，工作态度也是很重要的。 3.这个我搞不定的 这句话表现出来的是我不会，需要帮助，但也侧面说明了你这个人很懒，喜欢依赖别人。 直面问题，面对挑战，一个一个解决，必要时寻求帮助，而不是回避问题。 在职场，谁也做不了巨婴，没有人有义务帮你完成工作。 还有诸如此类的话语，比如：“我不知道啊”，“这跟我没关系”，“我不会”。 把话语变成：“我去做做调研”，“我去了解一下情况”，最好及时给出解决方案，不要让领导觉得你事不关己，高高挂起，这很容易让领导对你失去信心。 在职场中，做到事事有回应，件件让放心，职场之路才会越走越宽。 最后，本着赚钱就是帮助别人解决问题这个原则，如果你能帮很多人解决问题，就能赚到更多的钱，你想想是不是这个道理。 提高自己解决问题的能力，远比说这些负面的话语有用。 祝好。","categories":[{"name":"Java","slug":"Java","permalink":"https://liaoxingwang.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://liaoxingwang.github.io/tags/Java/"}],"author":"廖兴旺"},{"title":"工作思考","slug":"Blog-Open-Source-Work Thinking","date":"2024-04-14T21:20:00.000Z","updated":"2024-12-19T06:53:09.547Z","comments":true,"path":"2024/04/15/blog-open-source-work-thinking/","link":"","permalink":"https://liaoxingwang.github.io/2024/04/15/blog-open-source-work-thinking/","excerpt":"","text":"工作思考，上班只是偷师学艺，如何能转型突破瓶颈平时的工作如何体现一个人的技术深度？平时工作中很多时候需求细而碎的，如何在工作中积累技术深度？又如何体现一个人的技术深度？ 思考：做需求与做需求的差异再回答问题之前，我想先抛开「技术深度」这次词，讲讲做需求这件事，说说我对做需求的理解。每一个程序员都是从刚毕业做需求开始，为什么有的人逐渐成为大牛，主导大型技术项目或走向团队管理岗位，而有的人一直还在做需求。我觉得这里面的差异在于：每一个对做需求这件事的理解有所不同。 这里面的差异在于，你是抱着一种什么样的心态去完成这个需求，是把这个需求做到极致，还是只是当做任务完成这个需求，达到产品想要的功能就行。这两个表面上看似差不多其实相差极大，差异在于，你有没有站在更高的角度，希望这件事做到完美。 从需求角度有没有思考产品设计当中的缺陷，能不能反向为产品设计提供建议，从技术角度能不能做到高质量高兼容性无bug，以及下次再有类似的需求能不能快速高效率的迭代。 用一句话来描述就是，能不能跳出自己是一个程序员是一个被动执行人的角色，而是将自己当做产品当做技术负责人的心态去做这件事。 业务需求该怎么做知易行难。如果一开始做不到，那就先着眼小事：关注细节，从需求开始的需求评审、编写技术方案文档、设计文档、到开发的代码注释、结构设计，保证高质量，完善无漏洞的代码逻辑，再到异常埋点、指标监控、线上可用性运维等等，认真对待一个需求的每一个环节。 当你自认为已经做好整个流程的每一件小事之后，接下来可以通过深入细节，思考整个流程是否存在问题。做需求过程中沟通协作的有没有问题，流程规范的有没有问题，机制环节哪方面问题，代码公共基础能力的是否有缺失，开发过程中你所遇到的问题是不是一个通用问题，能不能抽象出一个公共库解决大家的问题，能不能制定一个SOP的解决方案流程，亦或是提炼出一个最佳实践在组内外分享经验。 通过这些一件件小事来锻炼自己解决问题的能力，以及更深层级的发现问题的能力。再通过不断的发现问题，思考问题出现的原因，拿出解决方案，最终落地解决了自己或组内或协作方的问题，锻炼自己的综合能力逐步慢慢成长。 再说「技术深度」说了这么多，你可能会说，这跟我问的技术深度有什么关系？我想说：抛开业务需求谈技术深度都是耍流氓。 举一个例子，数据可视化方面3D three.js，视频直播方面的编解码压缩，客户端安全方面的攻防渗透，每一个都是有技术深度的事情，但问题是即使你掌握了这些领域拥有了非常高的技术深度之后呢，不能应用于业务需求，不能解决产品急迫要解决的问题，不能完成你老板的OKR，达成部门的战略目标，还是英雄无用武之地（当然你也可以选择一个可以用得上的团队，那是就是另外一回事了）。 由于这些单点的有技术深度的事情，不能为你带来直观和显而易见的 「回报」（也就是颜如玉、黄金屋与金榜题名），也就间接的打击了积极性（当然自己对某门技术感兴趣而钻研的不再本次讨论之列）。 所以提升自己的技术深度，最好的方式还是在公司业务中，发现有深度的事，然后去在攻克这个问题的过程中，提升了自己的技术深度，即跟随公司业务的发展的同时自身也获得了成长，你用技术能力为公司解决了业务发展过程中的问题，自然也就从公司获得了该有的回报。这是一个ROI投入产出比最高的获得技术深度的方式。 获取做有深度事情的授权当想明白获取技术深度的路径之后，接下来要解决的就是：如何让领导给你安排有技术深度的事情？ 业务发展中有很多有技术深度有技术难度的事情，为什么领导要安排你来做这件事呢？你凭什么让领导觉得你 「有能力」 也 「有意愿」 来完成这件事？能力与意愿是作为领导在分配工作当中的最重要的两个决策项。 既然你能提问如何积累技术深度，我相信你一定是有强烈意愿的，那么剩下的就是如何让领导认为你有完成这个有技术深度的事情的能力？最简单来讲就是，你能不能在开发需求中做到深度思考、追求极致、精益求精、有责任心、有主人翁意识与主R意识，在每件小事中能做到 「自闭环」，之后才会逐步让你承担更大范围更高挑战更大深度的事情，形成正向循环。 这也是我前面为什么要先重点强调做好每一件小事的重要性。 技术深度不是唯一标准作为一个程序员，在职业生涯的初期，确实是以技术深度也就是技术能力作为最大的衡量标准。 但随着职业生涯的发展，职级从L5到L8，站在从公司角度，对一个人的需求，也会从能完成一个业务需求，变成能带领一帮人完成一个更大的维度的需求，能不能为组织解决问题，为事业部达成战略目标，对人的要求的重心也会慢慢发生变化，这种变化可以参考公司的职级能力模型体系的雷达图。 所以一味的追求积累技术深度就跑偏了，但不是说技术深度不重要，技术能力是作为程序员的安身立命之本，但是在积累技术深度的同时，也需要学习锻炼技术深度以外的能力。具体到底是什么其他能力，这就够再展开好几篇文章的篇幅了，今天在这就不细说了。 人员招聘，团队的管理人员招聘如下是对于当时的人员招聘的一些感受： 小公司的人员招聘是相对比较难的，特别是还给不了多少钱的； 好在我们选择的技术方案，只要对于JS掌握的比较好就可以了，前后端都要开发一点，也方便人员工作调整，避免开发资源的浪费。 团队管理对于小团队的管理的一些个人理解： 小公司刚起步，就应该实事求是，以业务为导向； 小公司最好采取全栈的开发方式，避免任务的不协调，造成开发资源的浪费； 设置推荐的代码规范，参照大家日常的代码习惯来制定，目标就是让大家的代码相对规范； 要求按照规范的流程设计与开发、避免一些流程的问题造成管理的混乱和公司的损失； 如按照常规的业务开发流程，产品评估 =&gt; 任务分配 =&gt; 技术评估 =&gt; 开发 =&gt; 测试 =&gt; cr =&gt; 上线 =&gt; 线上问题跟踪处理； 行之有效可量化的考核规范，如开发任务的截止日期完成、核心流程开发文档的书写、是否有线上bug、严谨手动修改数据库等； 鼓励分享，相互学习，一段工作经历总要有所提升，有所收获才是有意义的； 及时沟通反馈、团队成员的个人想法、掌握开发进度、工作难点等； 最后总结及选择创业公司避坑建议!important 选择创业公司，一定要确认老板是一个靠谱的人，别是一个总是画饼的油腻老司机，或者一个优柔寡断，没有主见的人，这样的情况下，大概率事情是干不成的； 老板靠谱，即使当前的项目搞不成，也可能未来在别的地方做出一番事情； 初了上边这个，最核心的就是，怎么样赚钱，现在这种融资环境，如果自己不能赚钱，大概率是活不下去的@自己； 抓住核心矛盾，解决主要问题，业务永远是最重要的。至于说选择的开发技术、代码规范等等这些都可以往后放； 对上要及时反馈自己的工作进度，保持好沟通，老板总是站在更高一层考虑问题，肯定会有一些不一样的想法，别总自以为什么什么的； 每段经历最好都能有所收获，人生的每一步都有意义。 最后故不积跬步无以至千里，不积小流无以成江海。先从做好每一件小事开始，把每个业务需求做到120分，深度思考、发现问题、解决问题，逐步建立起靠谱、有责任心、技术牛的人设，逐步负责有技术难度的事情，跟随公司业务发展积累自己的业务领域经验与技术深度，从而获得双赢的回报。 这是我对如何积累技术深度这件事的理解，或许会有一些片面和偏激，毕竟不是谁都有一个能知人善任的好领导，不是谁都能遇到一个快速发展的业务，不是谁都能遇到有技术难度与技术挑战的场景，无论我怎么说，都会有幸存者偏差的存在。 努力与机遇并存，机遇可遇不可求，所以我们能做的事，就是学会正确做事的思路和方法，并为之坚持不懈的践行它。知易行难，学会方法容易，坚持践行难于上青天。自己该做的都做好了，机遇来了就可以抓住，即使抓不住，你也有了「选择的能力」，有了选择更好机遇、更好公司的能力。","categories":[{"name":"Java","slug":"Java","permalink":"https://liaoxingwang.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://liaoxingwang.github.io/tags/Java/"}],"author":"廖兴旺"},{"title":"代码分层","slug":"Blog-Open-Source-CodeLayering","date":"2024-03-17T21:20:00.000Z","updated":"2024-12-19T06:53:09.538Z","comments":true,"path":"2024/03/18/blog-open-source-codelayering/","link":"","permalink":"https://liaoxingwang.github.io/2024/03/18/blog-open-source-codelayering/","excerpt":"","text":"优秀的代码都是如何分层的 1.背景说起应用分层，大部分人都会认为这个不是很简单嘛 就controller，service, mapper三层。看起来简单，很多人其实并没有把他们职责划分开，在很多代码中,controller做的逻辑比service还多,service往往当成透传了，这其实是很多人开发代码都没有注意到的地方，反正功能也能用，至于放哪无所谓呗。这样往往造成后面代码无法复用，层级关系混乱，对后续代码的维护非常麻烦。 的确在这些人眼中分层只是一个形式，前辈们的代码这么写的，其他项目代码这么写的，那么我也这么跟着写。但是在真正的团队开发中每个人的习惯都不同，写出来的代码必然带着自己的标签，有的人习惯controller写大量的业务逻辑，有的人习惯在service中之间调用远程服务，这样就导致了每个人的开发代码风格完全不同，后续其他人修改的时候，一看，我靠这个人写的代码和我平常的习惯完全不同，修改的时候到底是按着自己以前的习惯改，还是跟着前辈们走，这又是个艰难的选择，选择一旦有偏差，你的后辈又维护你的代码的时候，恐怕就要骂人了。 所以一个好的应用分层需要具备以下几点: 方便后续代码进行维护扩展。 分层的效果需要让整个团队都接受 各个层职责边界清晰 2.如何进行分层2.1阿里规范在阿里的编码规范中约束的分层如下: 图片 开放接口层:可直接封装 Service 方法暴露成 RPC 接口;通过 Web 封装成 http 接口;进行 网关安全控制、流量控制等。 终端显示层:各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染， JSP 渲染，移动端展示等。 Web 层:主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。 Service 层:相对具体的业务逻辑服务层。 Manager 层:通用业务处理层，它有如下特征:1. 对第三方平台封装的层，预处理返回结果及转化异常信息;2. 对Service层通用能力的下沉，如缓存方案、中间件通用处理;3. 与DAO层交互，对多个DAO的组合复用。 DAO 层:数据访问层，与底层 MySQL、Oracle、Hbase 进行数据交互。 阿里巴巴规约中的分层比较清晰简单明了，但是描述得还是过于简单了，以及service层和manager层有很多同学还是有点分不清楚之间的关系，就导致了很多项目中根本没有Manager层的存在。下面介绍一下具体业务中应该如何实现分层 2.2优化分层从我们的业务开发中总结了一个较为的理想模型,这里要先说明一下由于我们的rpc框架选用的是thrift可能会比其他的一些rpc框架例如dubbo会多出一层,作用和controller层类似 1.最上层controller和TService是我们阿里分层规范里面的第一层:轻业务逻辑，参数校验，异常兜底。通常这种接口可以轻易更换接口类型,所以业务逻辑必须要轻，甚至不做具体逻辑。 2.Service：业务层，复用性较低，这里推荐每一个controller方法都得对应一个service,不要把业务编排放在controller中去做，为什么呢？如果我们把业务编排放在controller层去做的话，如果以后我们要接入thrift,我们这里又需要把业务编排在做一次，这样会导致我们每接入一个入口层这个代码都得重新复制一份如下图所示: 这样大量的重复工作必定会导致我们开发效率下降，所以我们需要把业务编排逻辑都得放进service中去做: 3.Mannager：可复用逻辑层。这里的Mannager可以是单个服务的，比如我们的cache,mq等等，当然也可以是复合的，当你需要调用多个Mannager的时候，这个可以合为一个Mannager，比如逻辑上的连表查询等。如果是httpMannager或rpcMannager需要在这一层做一些数据转换 4.DAO：数据库访问层。主要负责“操作数据库的某张表，映射到某个java对象”，dao应该只允许自己的Service访问，其他Service要访问我的数据必须通过对应的Service。 3.分层领域模型的转换在阿里巴巴编码规约中列举了下面几个领域模型规约: DO（Data Object）：与数据库表结构一一对应，通过DAO层向上传输数据源对象。 DTO（Data Transfer Object）：数据传输对象，Service或Manager向外传输的对象。 BO（Business Object）：业务对象。由Service层输出的封装业务逻辑的对象。 AO（Application Object）：应用对象。在Web层与Service层之间抽象的复用对象模型，极为贴近展示层，复用度不高。 VO（View Object）：显示层对象，通常是Web向模板渲染引擎层传输的对象。 Query：数据查询对象，各层接收上层的查询请求。注意超过2个参数的查询封装，禁止使用Map类来传输。 层次 领域模型 Controller/TService VO/DTO Service/Manager AO/BO DAO DO 每一个层基本都自己对应的领域模型，这样就导致了有些人过于追求每一层都是用自己的领域模型，这样就导致了一个对象可能会出现3次甚至4次转换在一次请求中，当返回的时候同样也会出现3-4次转换，这样有可能一次完整的请求-返回会出现很多次对象转换。如果在开发中真的按照这么来，恐怕就别写其他的了，一天就光写这个重复无用的逻辑算了吧。 所以我们得采取一个折中的方案: 1.允许Service/Manager可以操作数据领域模型，对于这个层级来说，本来自己做的工作也是做的是业务逻辑处理和数据组装。 2.Controller/TService层的领域模型不允许传入DAO层，这样就不符合职责划分了。 3.同理，不允许DAO层的数据传入到Controller/TService. 图片 4.总结总的来说业务分层对于代码规范是比较重要，决定着以后的代码是否可复用，是否职责清晰，边界清晰。 当然这种分层其实见仁见智, 团队中的所有人的分层习惯也不同，所以很难权衡出一个标准的准则，总的来说只要满足职责逻辑清晰，后续维护容易，就是好的分层。 最后，如果你的团队有更好的分层，或者上面所描述的有什么错误的地方还请留言指正一下。","categories":[{"name":"Java","slug":"Java","permalink":"https://liaoxingwang.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://liaoxingwang.github.io/tags/Java/"}],"author":"旺旺"},{"title":"Java之Lambda表达式详解","slug":"Blog-Open-Source-Java-Lambda","date":"2023-05-20T21:20:00.000Z","updated":"2024-12-19T06:53:09.541Z","comments":true,"path":"2023/05/21/blog-open-source-java-lambda/","link":"","permalink":"https://liaoxingwang.github.io/2023/05/21/blog-open-source-java-lambda/","excerpt":"","text":"Lambda 表达式详解1. 介绍 Lambda 表达式是 JavaSE8 中的一个重要的新特性 Lambda 表达式允许你通过表达式来代替功能接口 Lambda 表达式和方法一样，它提供了一个正常的参数列表和一个使用这些参数的主体 Lambda 表达式可以看作是一个匿名函数，基于数学中的 λ 演算得名，也可以称其为闭包 Lambda 表达式允许把函数作为一个方法的参数 2. Lambda 表达式的语法基本形式：Lambda 表达式由三部分组成：参数、-&gt;符号、方法体 (参数列表)->{ 方法体} 补充： Lambda 表达式的参数可以是零个或多个 参数的类型可以明确声明，也可以不声明，由 JVM 隐式的推断，例如 (int a) 和 (a) 效果相同 当参数只有一个，且类型可推导时，可以省略括号，例如 (a) 与 a 效果相同 如果 Lambda 表达式的方法体只有一条语句时，可以省略花括号 如果 Lambda 表达式的方法体只有一条语句，且为返回值的时候，可以省略 return 代码示例：// 不需要参数，返回值为 2 ()->2 // 接收一个参数（数字类型），返回值为其2倍的值 x->2*x // 接收两个参数（数字类型），并返回它们的和 (x,y)->x+y // 接收两个 int 类型参数，返回它们的乘积 (int x,int y)->x*y // 接收一个 String 对象，并在控制台打印 (String s)->System.out.println(s) 3. 函数接口如果一个接口中有且只有一个 abstract 方法，称这样的接口为单接口。从 JDK8 开始，Java 使用 Lambda 表达式，并将单接口称为函数接口 注意：@FunctionInterface 示例代码：@functionInterface interface A{ void test(); } 4. Lamdba 表达式的使用接下来为大家演示 Lambda 表达式的使用 // 无返回值无参数 @FunctionalInterface interface NoParameterNoReturn { void test(); } // 无返回值一个参数 @FunctionalInterface interface OneParameterNoReturn { void test(int a); } // 无返回值多个参数 @FunctionalInterface interface MoreParameterNoReturn { void test(int a,int b); } // 有返回值无参数 @FunctionalInterface interface NoParameterReturn { int test(); } // 有返回值一个参数 @FunctionalInterface interface OneParameterReturn { int test(int a); } // 有返回值多参数 @FunctionalInterface interface MoreParameterReturn { int test(int a,int b); } public class TestDemo { public static void main(String[] args) { NoParameterNoReturn noParameterNoReturn = ()->{ System.out.println(\"无参数无返回值\"); }; noParameterNoReturn.test(); OneParameterNoReturn oneParameterNoReturn = (int a)->{ System.out.println(\"无参数一个返回值：\"+ a); }; oneParameterNoReturn.test(10); MoreParameterNoReturn moreParameterNoReturn = (int a,int b)->{ System.out.println(\"无返回值多个参数：\"+a+\" \"+b); }; moreParameterNoReturn.test(20,30); NoParameterReturn noParameterReturn = ()->{ System.out.println(\"有返回值无参数！\"); return 40; }; //接收函数的返回值 int ret = noParameterReturn.test(); System.out.println(ret); OneParameterReturn oneParameterReturn = (int a)->{ System.out.println(\"有返回值有参数！\"); return a; }; ret = oneParameterReturn.test(50); System.out.println(ret); MoreParameterReturn moreParameterReturn = (int a,int b)->{ System.out.println(\"有返回值多个参数！\"); return a+b; }; ret = moreParameterReturn.test(60,70); System.out.println(ret); } } 5. 变量捕获5.1 介绍Java 中的局部类和匿名类都存在变量捕获 只有理解了什么是变量捕获之后，我们才能更好地理解 Lambda 表达式的作用域，因为 Lambda 表达式也存在变量捕获。 5.2 匿名内部类的变量捕获class A { public void func(){ System.out.println(\"func()\"); } } public class TestDemo { public static void main(String[] args) { int a = 100; new Test(){ @Override public void func() { System.out.println(\"我是内部类，且重写了func这个方法！\"); System.out.println(\"我是捕获到变量 a == \"+a +\" 我是一个常量，或者是一个没有改变过值的变量！\"); } }; } } 上述代码中的变量 a 就是捕获变量，这个变量要么是被 final 修饰，要么就要保证此变量在匿名内部类中使用时没有被修改，如果修改就会编译出错 5.3 Lambda 的变量捕获在 Lambda 中也可以进行变量捕获 @FunctionalInterface interface A { void test(); } public static void main(String[] args) { int a = 10; NoParameterNoReturn noParameterNoReturn = ()->{ // a = 99; 如果修改a，则会报错 System.out.println(\"捕获变量：\"+a); }; noParameterNoReturn.test(); } 6. Lambda 在集合中的使用为了能够让 Lambda 和 Java 的集合类集更好的一起使用，集合当中也新增了部分接口，以便与 Lambda 表达式对接 对应的接口 新增的方法 补充：Collection 的 forEach() 方法是从接口 java.lang.Interable 继承的 6.1 Collection 接口使用 forEach() 方法进行演示 forEach() 源码： 代码示例：使用匿名内部类 public class TestDemo{ public static void main(String[] args) { List list=new ArrayList(); list.add(\"aaa\"); list.add(\"bbb\"); list.add(\"ccc\"); list.forEach(new Consumer() { @Override public void accept(String s) { System.out.print(s+\" \"); } }); } } // 结果为：aaa bbb ccc 代码示例：使用 Lambda public class TestDemo{ public static void main(String[] args) { List list=new ArrayList(); list.add(\"aaa\"); list.add(\"bbb\"); list.add(\"ccc\"); list.forEach(s -> System.out.print(s+\" \")); } } // 结果为：aaa bbb ccc 6.2 List 接口使用 sort() 方法进行演示 sort() 源码： 代码示例：使用匿名内部类 public class TestDemo{ public static void main(String[] args) { List list=new ArrayList(); list.add(\"aaa\"); list.add(\"bbb\"); list.add(\"ccc\"); list.sort(new Comparator() { @Override public int compare(String o1, String o2) { return o1.compareTo(o2); } }); System.out.println(list); } } // 结果为：[aaa, bbb, ccc] 代码示例：使用 Lambda public class TestDemo{ public static void main(String[] args) { List list=new ArrayList(); list.add(\"aaa\"); list.add(\"bbb\"); list.add(\"ccc\"); list.sort((String o1,String o2)->o1.compareTo(o2)); System.out.println(list); } } // 结果为：[aaa, bbb, ccc] 6.3 Map 接口使用 HashMap 的 forEach() 方法进行演示 HashMap 的 forEach() 源码：代码示例：使用匿名内部类 public class TestDemo{ public static void main(String[] args) { Map map=new HashMap(); map.put(1,\"aaa\"); map.put(2,\"222\"); map.put(3,\"333\"); map.forEach(new BiConsumer() { @Override public void accept(Integer integer, String s) { System.out.println(\"Key=\"+integer+\" Value=\"+s); } }); } } /** 结果为： Key=1 Value=aaa Key=2 Value=222 Key=3 Value=333 */ 代码示例：使用 Lambda public class TestDemo{ public static void main(String[] args) { Map map=new HashMap(); map.put(1,\"aaa\"); map.put(2,\"222\"); map.put(3,\"333\"); map.forEach((Integer integer,String s)-> System.out.println(\"Key=\"+integer+\" Value=\"+s)); } } /** 结果为： Key=1 Value=aaa Key=2 Value=222 Key=3 Value=333 */ 7. Lambda 表达式的优点和缺点优点： 代码简洁，开发迅速 方便函数式编程 容易进行并行计算 Java 引入 Lambda，改善了集合操作 缺点： 代码可读性变差 在非并行计算中，很多计算未必有传统 for 循环性能高 虽然说，lambda表达式可以在⼀定程度上简化接口的实现。但是，并不是所有的接口都可以使用lambda表达式来简洁实现的。 lambda表达式毕竟只是⼀个匿名方法。当实现的接口中的方法过多或者多少的时候，lambda表达式都是不适用的。 lambda表达式，只能实现函数式接口。","categories":[{"name":"Java","slug":"Java","permalink":"https://liaoxingwang.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://liaoxingwang.github.io/tags/Java/"}],"author":"廖兴旺"},{"title":"MySql之SQL优化","slug":"Blog-Open-Source-SqlOptimization","date":"2023-05-20T21:20:00.000Z","updated":"2024-12-19T06:53:09.545Z","comments":true,"path":"2023/05/21/blog-open-source-sqloptimization/","link":"","permalink":"https://liaoxingwang.github.io/2023/05/21/blog-open-source-sqloptimization/","excerpt":"","text":"SQL 优化一、查询SQL尽量不要使用select *，而是具体字段1、反例 SELECT * FROM user2、正例 SELECT id,username,tel FROM user3、理由 节省资源、减少网络开销。 可能用到覆盖索引，减少回表，提高查询效率。 注意：为节省时间，下面的样例字段都用*代替了。二、避免在where子句中使用 or 来连接条件1、反例 SELECT * FROM user WHERE id=1 OR salary=50002、正例 （1）使用union all SELECT * FROM user WHERE id=1 UNION ALL SELECT * FROM user WHERE salary=5000（2）分开两条sql写 SELECT * FROM user WHERE id=1 SELECT * FROM user WHERE salary=50003、理由 使用or可能会使索引失效，从而全表扫描； 对于or没有索引的salary这种情况，假设它走了id的索引，但是走到salary查询条件时，它还得全表扫描； 也就是说整个过程需要三步：全表扫描+索引扫描+合并。如果它一开始就走全表扫描，直接一遍扫描就搞定； 虽然mysql是有优化器的，出于效率与成本考虑，遇到or条件，索引还是可能失效的； 三、尽量使用数值替代字符串类型1、正例 主键（id）：primary key优先使用数值类型int，tinyint 性别（sex）：0代表女，1代表男；数据库没有布尔类型，mysql推荐使用tinyint 2、理由 因为引擎在处理查询和连接时会逐个比较字符串中每一个字符； 而对于数字型而言只需要比较一次就够了； 字符会降低查询和连接的性能，并会增加存储开销； 四、使用varchar代替char1、反例 `address` char(100) DEFAULT NULL COMMENT &#39;地址&#39;2、正例 `address` varchar(100) DEFAULT NULL COMMENT &#39;地址&#39;3、理由 varchar变长字段按数据内容实际长度存储，存储空间小，可以节省存储空间； char按声明大小存储，不足补空格； 其次对于查询来说，在一个相对较小的字段内搜索，效率更高； 五、技术延伸，char与varchar2的区别？1、char的长度是固定的，而varchar2的长度是可以变化的。 比如，存储字符串“101”，对于char(10)，表示你存储的字符将占10个字节（包括7个空字符），在数据库中它是以空格占位的，而同样的varchar2(10)则只占用3个字节的长度，10只是最大值，当你存储的字符小于10时，按实际长度存储。 2、char的效率比varchar2的效率稍高。 3、何时用char，何时用varchar2? char和varchar2是一对矛盾的统一体，两者是互补的关系，varchar2比char节省空间，在效率上比char会稍微差一点，既想获取效率，就必须牺牲一点空间，这就是我们在数据库设计上常说的“以空间换效率”。 varchar2虽然比char节省空间，但是假如一个varchar2列经常被修改，而且每次被修改的数据的长度不同，这会引起“行迁移”现象，而这造成多余的I/O，是数据库设计中要尽力避免的，这种情况下用char代替varchar2会更好一些。char中还会自动补齐空格，因为你insert到一个char字段自动补充了空格的,但是select后空格没有删除，因此char类型查询的时候一定要记得使用trim，这是写本文章的原因。 如果开发人员细化使用rpad()技巧将绑定变量转换为某种能与char字段相比较的类型（当然，与截断trim数据库列相比，填充绑定变量的做法更好一些，因为对列应用函数trim很容易导致无法使用该列上现有的索引），可能必须考虑到经过一段时间后列长度的变化。如果字段的大小有变化，应用就会受到影响，因为它必须修改字段宽度。 正是因为以上原因，定宽的存储空间可能导致表和相关索引比平常大出许多，还伴随着绑定变量问题，所以无论什么场合都要避免使用char类型。 六、where中使用默认值代替null1、反例 SELECT * FROM user WHERE age IS NOT NULL2、正例 SELECT * FROM user WHERE age&gt;03、理由 并不是说使用了is null或者 is not null就会不走索引了，这个跟mysql版本以及查询成本都有关； 如果mysql优化器发现，走索引比不走索引成本还要高，就会放弃索引，这些条件 !=，&lt;&gt;，is null，is not null经常被认为让索引失效； 其实是因为一般情况下，查询的成本高，优化器自动放弃索引的； 如果把null值，换成默认值，很多时候让走索引成为可能，同时，表达意思也相对清晰一点； 七、避免在where子句中使用!=或&lt;&gt;操作符1、反例 SELECT * FROM user WHERE salary!=5000 SELECT * FROM user WHERE salary&lt;&gt;50002、理由 使用!=和&lt;&gt;很可能会让索引失效 应尽量避免在where子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描 实现业务优先，实在没办法，就只能使用，并不是不能使用 八、inner join 、left join、right join，优先使用inner join三种连接如果结果相同，优先使用inner join，如果使用left join左边表尽量小。 inner join 内连接，只保留两张表中完全匹配的结果集； left join会返回左表所有的行，即使在右表中没有匹配的记录； right join会返回右表所有的行，即使在左表中没有匹配的记录； 为什么？ 如果inner join是等值连接，返回的行数比较少，所以性能相对会好一点； 使用了左连接，左边表数据结果尽量小，条件尽量放到左边处理，意味着返回的行数可能比较少； 这是mysql优化原则，就是小表驱动大表，小的数据集驱动大的数据集，从而让性能更优； 九、提高group by语句的效率1、反例 先分组，再过滤 select job, avg（salary） from employee group by job having job =&#39;develop&#39; or job = &#39;test&#39;;2、正例 先过滤，后分组 select job，avg（salary） from employee where job =&#39;develop&#39; or job = &#39;test&#39; group by job;3、理由 可以在执行到该语句前，把不需要的记录过滤掉 十、清空表时优先使用truncatetruncate table在功能上与不带 where子句的 delete语句相同：二者均删除表中的全部行。但 truncate table比 delete速度快，且使用的系统和事务日志资源少。 delete语句每次删除一行，并在事务日志中为所删除的每行记录一项。truncate table通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。 truncate table删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 drop table语句。 对于由 foreign key约束引用的表，不能使用 truncate table，而应使用不带 where子句的 DELETE 语句。由于 truncate table不记录在日志中，所以它不能激活触发器。 truncate table不能用于参与了索引视图的表。 十一、操作delete或者update语句，加个limit或者循环分批次删除1、降低写错SQL的代价 清空表数据可不是小事情，一个手抖全没了，删库跑路？如果加limit，删错也只是丢失部分数据，可以通过binlog日志快速恢复的。 2、SQL效率很可能更高 SQL中加了limit 1，如果第一条就命中目标return， 没有limit的话，还会继续执行扫描表。 3、避免长事务 delete执行时,如果age加了索引，MySQL会将所有相关的行加写锁和间隙锁，所有执行相关行会被锁住，如果删除数量大，会直接影响相关业务无法使用。 4、数据量大的话，容易把CPU打满 如果你删除数据量很大时，不加 limit限制一下记录数，容易把cpu打满，导致越删越慢。 5、锁表 一次性删除太多数据，可能造成锁表，会有lock wait timeout exceed的错误，所以建议分批操作。 十二、UNION操作符UNION在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。实际大部分应用中是不会产生重复的记录，最常见的是过程表与历史表UNION。如： select username,tel from user union select departmentname from department这个SQL在运行时先取出两个表的结果，再用排序空间进行排序删除重复的记录，最后返回结果集，如果表数据量大的话可能会导致用磁盘进行排序。推荐方案：采用UNION ALL操作符替代UNION，因为UNION ALL操作只是简单的将两个结果合并后就返回。 十三、批量插入性能提升1、多条提交 INSERT INTO user (id,username) VALUES(1,&#39;哪吒编程&#39;); INSERT INTO user (id,username) VALUES(2,&#39;妲己&#39;);2、批量提交 INSERT INTO user (id,username) VALUES(1,&#39;哪吒编程&#39;),(2,&#39;妲己&#39;);3、理由 默认新增SQL有事务控制，导致每条都需要事务开启和事务提交，而批量处理是一次事务开启和提交，效率提升明显，达到一定量级，效果显著，平时看不出来。 十四、表连接不宜太多，索引不宜太多，一般5个以内1、表连接不宜太多，一般5个以内 关联的表个数越多，编译的时间和开销也就越大 每次关联内存中都生成一个临时表 应该把连接表拆开成较小的几个执行，可读性更高 如果一定需要连接很多表才能得到数据，那么意味着这是个糟糕的设计了 阿里规范中，建议多表联查三张表以下 2、索引不宜太多，一般5个以内 索引并不是越多越好，虽其提高了查询的效率，但却会降低插入和更新的效率； 索引可以理解为一个就是一张表，其可以存储数据，其数据就要占空间； 索引表的数据是排序的，排序也是要花时间的； insert或update时有可能会重建索引，如果数据量巨大，重建将进行记录的重新排序，所以建索引需要慎重考虑，视具体情况来定； 一个表的索引数最好不要超过5个，若太多需要考虑一些索引是否有存在的必要； 十五、避免在索引列上使用内置函数1、反例 SELECT * FROM user WHERE DATE_ADD(birthday,INTERVAL 7 DAY) &gt;=NOW();2、正例 SELECT * FROM user WHERE birthday &gt;= DATE_ADD(NOW(),INTERVAL 7 DAY);3、理由 使用索引列上内置函数，索引失效。 十六、组合索引排序时应按照组合索引中各列的顺序进行排序，即使索引中只有一个列是要排序的，否则排序性能会比较差。 create index IDX_USERNAME_TEL on user(deptid,position,createtime); select username,tel from user where deptid= 1 and position = &#39;java开发&#39; order by deptid,position,createtime desc; 实际上只是查询出符合 deptid= 1 and position = &#39;java开发&#39;条件的记录并按createtime降序排序，但写成order by createtime desc性能较差。 十七、复合索引最左特性1、创建复合索引 ALTER TABLE employee ADD INDEX idx_name_salary (name,salary)2、满足复合索引的最左特性，哪怕只是部分，复合索引生效 SELECT * FROM employee WHERE NAME=&#39;哪吒编程&#39;3、没有出现左边的字段，则不满足最左特性，索引失效 SELECT * FROM employee WHERE salary=50004、复合索引全使用，按左侧顺序出现 name,salary，索引生效 SELECT * FROM employee WHERE NAME=&#39;哪吒编程&#39; AND salary=50005、虽然违背了最左特性，但MySQL执行SQL时会进行优化，底层进行颠倒优化 SELECT * FROM employee WHERE salary=5000 AND NAME=&#39;哪吒编程&#39;6、理由 复合索引也称为联合索引，当我们创建一个联合索引的时候，如(k1,k2,k3)，相当于创建了（k1）、(k1,k2)和(k1,k2,k3)三个索引，这就是最左匹配原则。 联合索引不满足最左原则，索引一般会失效。 十八、优化like语句模糊查询，程序员最喜欢的就是使用like，但是like很可能让你的索引失效。 1、反例 select * from citys where name like &#39;%大连&#39; (不使用索引) select * from citys where name like &#39;%大连%&#39; (不使用索引)2、正例 select * from citys where name like &#39;大连%&#39; (使用索引) 。3、理由 首先尽量避免模糊查询，如果必须使用，不采用全模糊查询，也应尽量采用右模糊查询， 即like ‘…%’，是会使用索引的； 左模糊like ‘%...’无法直接使用索引，但可以利用reverse + function index的形式，变化成 like ‘…%’； 全模糊查询是无法优化的，一定要使用的话建议使用搜索引擎。 十九、使用explain分析你SQL执行计划1、type system：表仅有一行，基本用不到； const：表最多一行数据配合，主键查询时触发较多； eq_ref：对于每个来自于前面的表的行组合，从该表中读取一行。这可能是最好的联接类型，除了const类型； ref：对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取； range：只检索给定范围的行，使用一个索引来选择行。当使用=、&lt;&gt;、&gt;、&gt;=、&lt;、&lt;=、IS NULL、&lt;=&gt;、BETWEEN或者IN操作符，用常量比较关键字列时，可以使用range； index：该联接类型与ALL相同，除了只有索引树被扫描。这通常比ALL快，因为索引文件通常比数据文件小； all：全表扫描； 性能排名：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all。 实际sql优化中，最后达到ref或range级别。 2、Extra常用关键字 Using index：只从索引树中获取信息，而不需要回表查询； Using where：WHERE子句用于限制哪一个行匹配下一个表或发送到客户。除非你专门从表中索取或检查所有行，如果Extra值不为Using where并且表联接类型为ALL或index，查询可能会有一些错误。需要回表查询。 Using temporary：mysql常建一个临时表来容纳结果，典型情况如查询包含可以按不同情况列出列的GROUP BY和ORDER BY子句时； 二十、一些其它优化方式1、设计表的时候，所有表和字段都添加相应的注释。 2、SQL书写格式，关键字大小保持一致，使用缩进。 3、修改或删除重要数据前，要先备份。 4、很多时候用 exists 代替 in 是一个好的选择 5、where后面的字段，留意其数据类型的隐式转换。 未使用索引 SELECT * FROM user WHERE NAME=110（1） 因为不加单引号时，是字符串跟数字的比较，它们类型不匹配； （2）MySQL会做隐式的类型转换，把它们转换为数值类型再做比较； 6、尽量把所有列定义为NOT NULL NOT NULL列更节省空间，NULL列需要一个额外字节作为判断是否为 NULL的标志位。NULL列需要注意空指针问题，NULL列在计算和比较的时候，需要注意空指针问题。 7、伪删除设计 8、数据库和表的字符集尽量统一使用UTF8 （1）可以避免乱码问题； （2）可以避免，不同字符集比较转换，导致的索引失效问题； 9、select count(*) from table； 这样不带任何条件的count会引起全表扫描，并且没有任何业务意义，是一定要杜绝的。 10、避免在where中对字段进行表达式操作 （1）SQL解析时，如果字段相关的是表达式就进行全表扫描 ； （2）字段干净无表达式，索引生效； 11、关于临时表 （1）避免频繁创建和删除临时表，以减少系统表资源的消耗； （2）在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log； （3）如果数据量不大，为了缓和系统表的资源，应先create table，然后insert； （4）如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除。先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定； 12、索引不适合建在有大量重复数据的字段上，比如性别，排序字段应创建索引 13、去重distinct过滤字段要少 带distinct的语句占用cpu时间高于不带distinct的语句 当查询很多字段时，如果使用distinct，数据库引擎就会对数据进行比较，过滤掉重复数据 然而这个比较、过滤的过程会占用系统资源，如cpu时间 14、尽量避免大事务操作，提高系统并发能力 15、所有表必须使用Innodb存储引擎 Innodb「支持事务，支持行级锁，更好的恢复性」，高并发下性能更好，所以呢，没有特殊要求（即Innodb无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用Innodb存储引擎。 16、尽量避免使用游标 因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。","categories":[{"name":"MySql","slug":"MySql","permalink":"https://liaoxingwang.github.io/categories/MySql/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"https://liaoxingwang.github.io/tags/MySql/"}],"author":"廖兴旺"},{"title":"Java循环删除List中的元素","slug":"Blog-Open-Source-Circular deletion of elements in List","date":"2023-05-19T21:20:00.000Z","updated":"2024-12-19T06:53:09.537Z","comments":true,"path":"2023/05/20/blog-open-source-circular-deletion-of-elements-in-list/","link":"","permalink":"https://liaoxingwang.github.io/2023/05/20/blog-open-source-circular-deletion-of-elements-in-list/","excerpt":"","text":"循环删除 List 中的元素问题比如有以下这个 List： public List&lt;String&gt; initList = Arrays.asList(&quot;张三&quot;, &quot;李四&quot;, &quot;周一&quot;, &quot;刘四&quot;, &quot;李强&quot;, &quot;李白&quot;);怎么删除 List 中姓李的人？ 方法1、普通 for 循环删除（不可靠）/** * 普通 for 循环删除 * */ @Test public void remove1() { List&lt;String&gt; list = new ArrayList(initList); for (int i = 0; i &lt; list.size(); i++) { String str = list.get(i); if (str.startsWith(&quot;李&quot;)) { list.remove(i); } } System.out.println(list); }输出结果： [张三, 周一, 刘四, 李白] 李白没删掉 问题就出在 list.size()，因为 list.size() 和 i 都是动态变化的，i 的值一直在累加，list.size() 一直在减少，所以 list 就会早早结束了循环。 所以这种方式虽然不会报错，但存在隐患，并且不容易被察觉，不建议使用。 2、普通 for 循环提取变量删除（抛异常）把上面的示例中的 size 提出变量： /** * 普通 for 循环删除（size提出变量） * */ @Test public void remove2() { List&lt;String&gt; list = new ArrayList(initList); int size = list.size(); for (int i = 0; i &lt; size; i++) { String str = list.get(i); if (str.startsWith(&quot;李&quot;)) { list.remove(i); } } System.out.println(list); }直接干下标溢出异常了。。 这里也很明显，因为 size 变量是固定的，但 list 的实际大小是不断减小的，而 i 的大小是不断累加的，一旦 i &gt;= list 的实际大小肯定就异常了。 3、普通 for 循环倒序删除（可靠）/** * 普通 for 循环倒序删除 * */ @Test public void remove3() { List&lt;String&gt; list = new ArrayList(initList); for (int i = list.size() - 1; i &gt; 0; i--) { String str = list.get(i); if (str.startsWith(&quot;李&quot;)) { list.remove(i); } } System.out.println(list); }输出结果： [张三, 周一, 刘四] 结果输出正常，这种删除方式就算把 list.size() 提出变量也是 OK 的，因为循环中只用到了一次。 4、增强 for 循环删除（抛异常）/** * 增强 for 循环删除 * */ @Test public void remove4() { List&lt;String&gt; list = new ArrayList(initList); for (String element : list) { if (element.startsWith(&quot;李&quot;)) { list.remove(element); } } System.out.println(list); }抛异常了。不过这次的异常和上面的下标异常不太一样，这次是： java.util.ConcurrentModificationException 这个是集合操作中很常见的异常之一，即并发修改异常！ for(xx in xx) 就是增强的 for循环，即迭代器 Iterator 的加强实现，其内部是调用的 Iterator 的方法，取下个元素的时候都会去判断要修改的数量（modCount）和期待修改的数量（expectedModCount）是否一致，不一致则会报错，而 ArrayList 中的 remove 方法并没有同步期待修改的数量（expectedModCount）值，所以会抛异常了。 5、迭代器循环迭代器删除（可靠）/** * 迭代器循环删除（iterator.remove） * */ @Test public void remove5() { List&lt;String&gt; list = new ArrayList(initList); for (Iterator&lt;String&gt; iterator = list.iterator(); iterator.hasNext(); ) { String str = iterator.next(); if (str.contains(&quot;李&quot;)) { iterator.remove(); } } System.out.println(list); }输出结果： [张三, 周一, 刘四] 结果输出正常，这是因为迭代器中的 remove 方法将期待修改的数量（expectedModCount）值进行了同步：所以，这种删除方法是安全的，推荐使用。 6、迭代器循环集合删除（抛异常）/** * 迭代器循环删除（list.remove） * */ @Test public void remove6() { List&lt;String&gt; list = new ArrayList(initList); for (Iterator&lt;String&gt; ite = list.iterator(); ite.hasNext(); ) { String str = ite.next(); if (str.contains(&quot;李&quot;)) { list.remove(str); } } System.out.println(list); }又是那个并发修改异常，这个示例虽然使用了 Iterator 循环，但删除的时候却使用了 list.remove 方法，同样是有问题的，注意了，千万别用错了。 7、集合 forEach 方法循环删除（抛异常）/** * list.forEach 删除 * */ @Test public void remove7() { List&lt;String&gt; list = new ArrayList(initList); list.forEach((e) -&gt; { if (e.contains(&quot;李&quot;)) { list.remove(e); } }); System.out.println(list); }forEach 方法的背后其实就是增强的 for 循环，底层即迭代器，所以使用 list.remove 同样抛出 ConcurrentModificationException 异常。 8、stream filter 过滤（可靠）/** * stream filter 过滤 * */ @Test public void remove8() { List&lt;String&gt; list = new ArrayList(initList); list = list.stream().filter(e -&gt; !e.startsWith(&quot;李&quot;)).collect(Collectors.toList()); System.out.println(list); }总结本文总结了 8 种循环删除 List 元素的方法： 普通 for 循环删除（不可靠） 普通 for 循环提取变量删除（抛异常） 普通 for 循环倒序删除（可靠） 增强 for 循环删除（抛异常） 迭代器循环迭代器删除（可靠） 迭代器循环集合删除（抛异常） 集合 forEach 方法循环删除（抛异常） stream filter 过滤（可靠）","categories":[{"name":"Java","slug":"Java","permalink":"https://liaoxingwang.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://liaoxingwang.github.io/tags/Java/"}],"author":"廖兴旺"},{"title":"MySql基础篇","slug":"Blog-Open-Source-MySqlFoundation","date":"2023-05-19T09:20:00.000Z","updated":"2024-12-19T06:53:09.543Z","comments":true,"path":"2023/05/19/blog-open-source-mysqlfoundation/","link":"","permalink":"https://liaoxingwang.github.io/2023/05/19/blog-open-source-mysqlfoundation/","excerpt":"","text":"MyISAM和InnoDB 对比 MyISAM InnoDB 主外键 不支持 支持 事务 不支持 支持 行表锁 表锁，操作时即使操作一条记录也会锁住一整张表，不适合高并发的操作 行锁，操作时只锁住某一行，不会影响到其他行，适合高并发 缓存 只缓存索引，不缓存其他数据 缓存索引和真实数据，对内存要求较高，而且内存大小对性能有影响 表空间 小 大 关注点 性能 事务 默认安装 Y Y 性能下降SQL慢的原因： 查询语句写的差 索引失效 关联查询太多join （设计缺陷或不得已的需求） 服务器调优及各个参数设置(缓冲，线程参数) Mysql执行顺序 手写 机读先从from开始 mysql执行顺序如下： from 阶段 where 阶段 group by 阶段 having 阶段 select 阶段 order by 阶段 limit 阶段 按照以上书写顺序，完整的执行顺序应该是这样： 1、from子句识别查询表的数据； 2、where子句基于指定的条件对记录进行筛选； 3、group by 子句将数据划分成多个组别，如按性别男、女分组； 4、有聚合函数时，要使用聚集函数进行数据计算； 5、Having子句筛选满足第二条件的数据； 6、执行select语句进行字段筛选 7、筛选重复数据； 8、对数据进行排序； 9、执行limit进行结果限定 SQL优化优化目标 1.减少 IO 次数 IO永远是数据库最容易瓶颈的地方，这是由数据库的职责所决定的，大部分数据库操作中超过90%的时间都是 IO 操作所占用的，减少 IO 次数是 SQL 优化中需要第一优先考虑，当然，也是收效最明显的优化手段。 2.降低 CPU 计算 除了 IO 瓶颈之外，SQL优化中需要考虑的就是 CPU 运算量的优化了。order by, group by,distinct … 都是消耗 CPU 的大户(这些操作基本上都是 CPU 处理内存中的数据比较运算)。当我们的 IO 优化做到一定阶段之后，降低 CPU 计算也就成为了我们 SQL 优化的重要目标 优化方法 改变 SQL 执行计划 明确了优化目标之后，我们需要确定达到我们目标的方法。对于 SQL 语句来说，达到上述2个目标的方法其实只有一个，那就是改变 SQL 的执行计划，让他尽量“少走弯路”，尽量通过各种“捷径”来找到我们需要的数据，以达到 “减少 IO 次数” 和 “降低 CPU 计算” 的目标 常见误区1.count(1)和count(primary_key) 优于 count(*) 很多人为了统计记录条数，就使用 count(1) 和 count(primary_key) 而不是 count() ，他们认为这样性能更好，其实这是一个误区。对于有些场景，这样做可能性能会更差，应为数据库对 count() 计数操作做了一些特别的优化。 2.count(column) 和 count(*) 是一样的 这个误区甚至在很多的资深工程师或者是 DBA 中都普遍存在，很多人都会认为这是理所当然的。实际上，count(column) 和 count(*) 是一个完全不一样的操作，所代表的意义也完全不一样。 count(column) 是表示结果集中有多少个column字段不为空的记录 count(*) 是表示整个结果集有多少条记录 3.select a,b from … 比 select a,b,c from … 可以让数据库访问更少的数据量 这个误区主要存在于大量的开发人员中，主要原因是对数据库的存储原理不是太了解。 实际上，大多数关系型数据库都是按照行(row)的方式存储，而数据存取操作都是以一个固定大小的IO单元(被称作 block 或者 page)为单位，一般为4KB，8KB… 大多数时候，每个IO单元中存储了多行，每行都是存储了该行的所有字段(lob等特殊类型字段除外)。 所以，我们是取一个字段还是多个字段，实际上数据库在表中需要访问的数据量其实是一样的。 当然，也有例外情况，那就是我们的这个查询在索引中就可以完成，也就是说当只取 a,b两个字段的时候，不需要回表，而c这个字段不在使用的索引中，需要回表取得其数据。在这样的情况下，二者的IO量会有较大差异。 4.order by 一定需要排序操作 我们知道索引数据实际上是有序的，如果我们的需要的数据和某个索引的顺序一致，而且我们的查询又通过这个索引来执行，那么数据库一般会省略排序操作，而直接将数据返回，因为数据库知道数据已经满足我们的排序需求了。 实际上，利用索引来优化有排序需求的 SQL，是一个非常重要的优化手段 延伸阅读：MySQL ORDER BY 的实现分析，MySQL 中 GROUP BY 基本实现原理以及 MySQL DISTINCT 的基本实现原理这3篇文章中有更为深入的分析，尤其是第一篇 5.执行计划中有 filesort 就会进行磁盘文件排序 有这个误区其实并不能怪我们，而是因为 MySQL 开发者在用词方面的问题。filesort 是我们在使用 explain 命令查看一条 SQL 的执行计划的时候可能会看到在 “Extra” 一列显示的信息。 实际上，只要一条 SQL 语句需要进行排序操作，都会显示“Using filesort”，这并不表示就会有文件排序操作。 基本原则1.尽量少 join MySQL 的优势在于简单，但这在某些方面其实也是其劣势。MySQL 优化器效率高，但是由于其统计信息的量有限，优化器工作过程出现偏差的可能性也就更多。对于复杂的多表 Join，一方面由于其优化器受限，再者在 Join 这方面所下的功夫还不够，所以性能表现离 Oracle 等关系型数据库前辈还是有一定距离。但如果是简单的单表查询，这一差距就会极小甚至在有些场景下要优于这些数据库前辈。 2.尽量少排序 排序操作会消耗较多的 CPU 资源，所以减少排序可以在缓存命中率高等 IO 能力足够的场景下会较大影响 SQL 的响应时间。 对于MySQL来说，减少排序有多种办法，比如： 上面误区中提到的通过利用索引来排序的方式进行优化 减少参与排序的记录条数 非必要不对数据进行排序 … 3.尽量避免 select * 很多人看到这一点后觉得比较难理解，上面不是在误区中刚刚说 select 子句中字段的多少并不会影响到读取的数据吗? 是的，大多数时候并不会影响到 IO 量，但是当我们还存在 order by 操作的时候，select 子句中的字段多少会在很大程度上影响到我们的排序效率，这一点可以通过我之前一篇介绍 MySQL ORDER BY 的实现分析的文章中有较为详细的介绍。 此外，上面误区中不是也说了，只是大多数时候是不会影响到 IO 量，当我们的查询结果仅仅只需要在索引中就能找到的时候，还是会极大减少 IO 量的。 4.尽量用 join 代替子查询 虽然 Join 性能并不佳，但是和 MySQL 的子查询比起来还是有非常大的性能优势。MySQL 的子查询执行计划一直存在较大的问题，虽然这个问题已经存在多年，但是到目前已经发布的所有稳定版本中都普遍存在，一直没有太大改善。虽然官方也在很早就承认这一问题，并且承诺尽快解决，但是至少到目前为止我们还没有看到哪一个版本较好的解决了这一问题。 5.尽量少 or 当 where 子句中存在多个条件以“或”并存的时候，MySQL 的优化器并没有很好的解决其执行计划优化问题，再加上 MySQL 特有的 SQL 与 Storage 分层架构方式，造成了其性能比较低下，很多时候使用 union all 或者是union(必要的时候)的方式来代替“or”会得到更好的效果。 6.尽量用 union all 代替 union union 和 union all 的差异主要是前者需要将两个(或者多个)结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的 CPU 运算，加大资源消耗及延迟。所以当我们可以确认不可能出现重复结果集或者不在乎重复结果集的时候，尽量使用 union all 而不是 union。 7.尽量早过滤 这一优化策略其实最常见于索引的优化设计中(将过滤性更好的字段放得更靠前)。 在 SQL 编写中同样可以使用这一原则来优化一些 Join 的 SQL。比如我们在多个表进行分页数据查询的时候，我们最好是能够在一个表上先过滤好数据分好页，然后再用分好页的结果集与另外的表 Join，这样可以尽可能多的减少不必要的 IO 操作，大大节省 IO 操作所消耗的时间。 8.避免类型转换 这里所说的“类型转换”是指 where 子句中出现 column 字段的类型和传入的参数类型不一致的时候发生的类型转换： 人为在column_name 上通过转换函数进行转换 直接导致 MySQL(实际上其他数据库也会有同样的问题)无法使用索引，如果非要转换，应该在传入的参数上进行转换 由数据库自己进行转换 如果我们传入的数据类型和字段类型不一致，同时我们又没有做任何类型转换处理，MySQL 可能会自己对我们的数据进行类型转换操作，也可能不进行处理而交由存储引擎去处理，这样一来，就会出现索引无法使用的情况而造成执行计划问题。 9.优先优化高并发的 SQL，而不是执行频率低某些“大”SQL 对于破坏性来说，高并发的 SQL 总是会比低频率的来得大，因为高并发的 SQL 一旦出现问题，甚至不会给我们任何喘息的机会就会将系统压跨。而对于一些虽然需要消耗大量 IO 而且响应很慢的 SQL，由于频率低，即使遇到，最多就是让整个系统响应慢一点，但至少可能撑一会儿，让我们有缓冲的机会。 10.从全局出发优化，而不是片面调整 SQL 优化不能是单独针对某一个进行，而应充分考虑系统中所有的 SQL，尤其是在通过调整索引优化 SQL 的执行计划的时候，千万不能顾此失彼，因小失大。 11.尽可能对每一条运行在数据库中的SQL进行 explain 优化 SQL，需要做到心中有数，知道 SQL 的执行计划才能判断是否有优化余地，才能判断是否存在执行计划问题。在对数据库中运行的 SQL 进行了一段时间的优化之后，很明显的问题 SQL 可能已经很少了，大多都需要去发掘，这时候就需要进行大量的 explain 操作收集执行计划，并判断是否需要进行优化。 通用语法及分类 DDL: 数据定义语言，用来定义数据库对象（数据库、表、字段） DML: 数据操作语言，用来对数据库表中的数据进行增删改 DQL: 数据查询语言，用来查询数据库中表的记录 DCL: 数据控制语言，用来创建数据库用户、控制数据库的控制权限 DDL（数据定义语言）数据库操作查询所有数据库：SHOW DATABASES;查询当前数据库：SELECT DATABASE();创建数据库：CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];删除数据库：DROP DATABASE [ IF EXISTS ] 数据库名;使用数据库：USE 数据库名; 注意事项 UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集 表操作查询当前数据库所有表：SHOW TABLES; mysql> show tables; +----------------+ | Tables_in_mydb | +----------------+ | Course | | Score | | Student | | Teacher | +----------------+ 查询表结构：DESC 表名; mysql> desc Student; +---------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +---------+-------------+------+-----+---------+-------+ | s_id | varchar(20) | NO | PRI | NULL | | | s_name | varchar(20) | NO | | | | | s_birth | varchar(20) | NO | | | | | s_sex | varchar(10) | NO | | | | +---------+-------------+------+-----+---------+-------+ 查询指定表的建表语句：SHOW CREATE TABLE 表名; 创建表： CREATE TABLE 表名( 字段1 字段1类型 [COMMENT 字段1注释], 字段2 字段2类型 [COMMENT 字段2注释], 字段3 字段3类型 [COMMENT 字段3注释], ... 字段n 字段n类型 [COMMENT 字段n注释] )[ COMMENT 表注释 ]; 最后一个字段后面没有逗号 添加字段：ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];例：ALTER TABLE emp ADD nickname varchar(20) COMMENT &#39;昵称&#39;; 修改数据类型：ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);修改字段名和字段类型：ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];例：将emp表的nickname字段修改为username，类型为varchar(30)ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT &#39;昵称&#39;; 删除字段：ALTER TABLE 表名 DROP 字段名; 修改表名：ALTER TABLE 表名 RENAME TO 新表名 删除表：DROP TABLE [IF EXISTS] 表名;删除表，并重新创建该表：TRUNCATE TABLE 表名; DML（数据操作语言）添加数据指定字段：INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);全部字段：INSERT INTO 表名 VALUES (值1, 值2, ...); 批量添加数据： INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...); INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...); 注意事项 字符串和日期类型数据应该包含在引号中 插入的数据大小应该在字段的规定范围内 更新和删除数据修改数据：UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ];例：UPDATE emp SET name = &#39;Jack&#39; WHERE id = 1; 删除数据：DELETE FROM 表名 [ WHERE 条件 ]; DQL（数据查询语言）语法： SELECT 字段列表 FROM 表名字段 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后的条件列表 ORDER BY 排序字段列表 LIMIT 分页参数 基础查询查询多个字段：SELECT 字段1, 字段2, 字段3, ... FROM 表名;SELECT * FROM 表名; 设置别名：SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名;SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名; 去除重复记录：SELECT DISTINCT 字段列表 FROM 表名; 例如： mysql> SELECT * FROM Score; +------+------+---------+ | s_id | c_id | s_score | +------+------+---------+ | 01 | 01 | 80 | | 01 | 02 | 90 | | 01 | 03 | 99 | | 02 | 01 | 70 | | 02 | 02 | 60 | | 02 | 03 | 80 | | 03 | 01 | 80 | | 03 | 02 | 80 | | 03 | 03 | 80 | | 04 | 01 | 50 | | 04 | 02 | 30 | | 04 | 03 | 20 | | 05 | 01 | 76 | | 05 | 02 | 87 | | 06 | 01 | 31 | | 06 | 03 | 34 | | 07 | 02 | 89 | | 07 | 03 | 98 | | 07 | 04 | 87 | +------+------+---------+ -- 去除重复学号 mysql> SELECT DISTINCT s_id FROM Score; +------+ | s_id | +------+ | 01 | | 02 | | 03 | | 04 | | 05 | | 06 | | 07 | +------+ 转义：SELECT * FROM 表名 WHERE name LIKE &#39;/_张三&#39; ESCAPE &#39;/&#39;/ 之后的_不作为通配符 条件查询语法：SELECT 字段列表 FROM 表名 WHERE 条件列表; 条件： 比较运算符 功能 &gt; 大于 &gt;= 大于等于 &lt; 小于 &lt;= 小于等于 = 等于 &lt;&gt; 或 != 不等于 BETWEEN … AND … 在某个范围内（含最小、最大值） IN(…) 在in之后的列表中的值，多选一，和or查询结果等价 LIKE 占位符 模糊匹配（_匹配单个字符，%匹配任意个字符） IS NULL 是NULL 逻辑运算符 功能 AND 或 &amp;&amp; 并且（多个条件同时成立） OR 或 || 或者（多个条件任意一个成立） NOT 或 ! 非，不是 例子： -- 年龄等于30 select * from employee where age = 30; -- 年龄小于30 select * from employee where age &lt; 30; -- 小于等于 select * from employee where age &lt;= 30; -- 没有身份证 select * from employee where idcard is null or idcard = ''; -- 有身份证 select * from employee where idcard; select * from employee where idcard is not null; -- 不等于 select * from employee where age != 30; -- 年龄在20到30之间 select * from employee where age between 20 and 30; select * from employee where age >= 20 and age &lt;= 30; -- 下面语句不报错，但查不到任何信息 select * from employee where age between 30 and 20; -- 性别为女且年龄小于30 select * from employee where age &lt; 30 and gender = '女'; -- 年龄等于25或30或35 select * from employee where age = 25 or age = 30 or age = 35; select * from employee where age in (25, 30, 35); -- 姓名为两个字 select * from employee where name like '__'; -- 下滑线代表单个字符 -- 身份证最后为X select * from employee where idcard like '%X'; -- 百分号代表任意字符 聚合查询（聚合函数）搭配分组查询使用。 将一列数据作为一个整体，进行纵向计算。 常见聚合函数： 函数 功能 count 统计数量 max 最大值 min 最小值 avg 平均值 sum 求和 语法：SELECT 聚合函数(字段列表) FROM 表名;例： -- 01学生的课程号和分数都是不同的，所以聚合时不能筛选，而共有的重复数据则可以选择 mysql> SELECT * from Score WHERE s_id = \"01\"; +------+------+---------+ | s_id | c_id | s_score | +------+------+---------+ | 01 | 01 | 80 | | 01 | 02 | 90 | | 01 | 03 | 99 | +------+------+---------+ -- 计算学号01学生的平均成绩 mysql> SELECT s_id, avg(s_score) as \"平均成绩\" from Score WHERE s_id = \"01\"; +------+--------------+ | s_id | 平均成绩 | +------+--------------+ | 01 | 89.6667 | +------+--------------+ 分组查询一般求分组字段和聚合函数的字段。 语法：SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ]; where 和 having 的区别： 执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。 判断条件不同：where不能对聚合函数进行判断，而having可以。 例子： mysql> SELECT * FROM Student; +------+--------+------------+-------+ | s_id | s_name | s_birth | s_sex | +------+--------+------------+-------+ | 01 | 赵雷 | 1990-01-01 | 男 | | 02 | 钱电 | 1990-12-21 | 男 | | 03 | 孙风 | 1990-05-20 | 男 | | 04 | 李云 | 1990-08-06 | 男 | | 05 | 周梅 | 1991-12-01 | 女 | | 06 | 吴兰 | 1992-03-01 | 女 | | 07 | 郑竹 | 1989-07-01 | 女 | | 08 | 王菊 | 1990-01-20 | 女 | +------+--------+------------+-------+ -- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女） mysql> SELECT count(*) FROM Student GROUP BY s_sex; +----------+ | count(*) | +----------+ | 4 | | 4 | +----------+ -- 根据性别分组，统计男性和女性数量 mysql> SELECT s_sex, count(*) as \"人数\" FROM Student GROUP BY s_sex; +-------+--------+ | s_sex | 人数 | +-------+--------+ | 男 | 4 | | 女 | 4 | +-------+--------+ -- 年龄小于45，并根据工作地址分组 select workaddress, count(*) from employee where age &lt; 45 group by workaddress; -- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址 select workaddress, count(*) as address_count from employee where age &lt; 45 group by workaddress `having address_count >= 3`; -- having 后可以使用聚合函数的结果而where不可以 注意事项 执行顺序：where &gt; 聚合函数 &gt; having 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义 排序查询语法：SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1 [, 字段2 排序方式2]; 排序方式： ASC: 升序（默认） DESC: 降序 例子： -- 根据年龄升序排序 SELECT * FROM employee ORDER BY age ASC; SELECT * FROM employee ORDER BY age; -- 两字段排序，根据年龄升序排序，入职时间降序排序 SELECT * FROM employee ORDER BY age ASC, entrydate DESC; 注意事项如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 分页查询语法：SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数; 例子： -- 查询第一页数据，展示10条 SELECT * FROM employee LIMIT 0, 10; -- 查询第二页 SELECT * FROM employee LIMIT 10, 10; 注意事项 起始索引从0开始，起始索引 = （查询页码 - 1） * 每页显示记录数 分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT 如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10 DQL执行顺序from先找到表，where确定数据范围，group by对所选数据进行分组，select选择要返回的字段，order by指定排序，最后根据limit的索引和范围返回数据。 FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT DCL管理用户查询用户： USE mysql; SELECT * FROM user; 创建用户:CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;; 修改用户密码：ALTER USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39;; 删除用户：DROP USER &#39;用户名&#39;@&#39;主机名&#39;; 例子： -- 创建用户test，只能在当前主机localhost访问 create user 'test'@'localhost' identified by '123456'; -- 创建用户test，能在任意主机访问 create user 'test'@'%' identified by '123456'; create user 'test' identified by '123456'; -- 修改密码 加密方式：mysql_native_password alter user 'test'@'localhost' identified with mysql_native_password by '1234'; -- 删除用户 drop user 'test'@'localhost'; 注意事项 主机名可以使用 % 通配 权限控制常用权限： 权限 说明 ALL, ALL PRIVILEGES 所有权限 SELECT 查询数据 INSERT 插入数据 UPDATE 修改数据 DELETE 删除数据 ALTER 修改表 DROP 删除数据库/表/视图 CREATE 创建数据库/表 查询权限：SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;; 授予权限：GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;; 撤销权限：REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;; mysql> SHOW GRANTS FOR 'ravi'@'localhost'; +------------------------------------------+ | Grants for ravi@localhost | +------------------------------------------+ | GRANT USAGE ON *.* TO `ravi`@`localhost` | +------------------------------------------+ mysql> GRANT ALL ON myDb.* to 'ravi'@'localhost'; Query OK, 0 rows affected (0.00 sec) mysql> GRANT ALL ON checkup.* to 'ravi'@'localhost'; Query OK, 0 rows affected (0.01 sec) -- 登陆 mysql -u ravi -p Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 18 mysql> show databases; +--------------------+ | Database | +--------------------+ | checkup | | information_schema | | myDb | +--------------------+ -- 撤销权限 mysql> REVOKE ALL ON checkup.* FROM 'ravi'@'localhost'; Query OK, 0 rows affected (0.01 sec) mysql> show databases; +--------------------+ | Database | +--------------------+ | information_schema | | myDb | +--------------------+ 2 rows in set (0.00 sec) 注意事项 多个权限用逗号分隔 授权时，数据库名和表名可以用 * 进行通配，代表所有 函数 字符串函数 数值函数 日期函数 流程函数 字符串函数常用函数： 函数 功能 CONCAT(s1, s2, …, sn) 字符串拼接，将s1, s2, …, sn拼接成一个字符串 LOWER(str) 将字符串全部转为小写 UPPER(str) 将字符串全部转为大写 LPAD(str, n, pad) 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度 RPAD(str, n, pad) 右填充，用字符串pad对str的右边进行填充，达到n个字符串长度 TRIM(str) 去掉字符串头部和尾部的空格 SUBSTRING(str, start, len) 返回从字符串str从start位置起的len个长度的字符串 使用示例： -- 拼接 SELECT CONCAT('Hello', 'World'); -- 小写 SELECT LOWER('Hello'); -- 大写 SELECT UPPER('Hello'); -- 左填充 mysql> SELECT LPAD('01', 5, '-'); +--------------------+ | LPAD('01', 5, '-') | +--------------------+ | ---01 | +--------------------+ -- 右填充 mysql> SELECT RPAD('01', 5, '-'); +--------------------+ | RPAD('01', 5, '-') | +--------------------+ | 01--- | +--------------------+ -- 去除空格 SELECT TRIM(' Hello World '); -- 切片（起始索引为1） SELECT SUBSTRING('Hello World', 1, 5); -- Hello 数值函数常见函数： 函数 功能 CEIL(x) 向上取整 FLOOR(x) 向下取整 MOD(x, y) 返回x/y的模 RAND() 返回0~1内的随机数 ROUND(x, y) 求参数x的四舍五入值，保留y位小数 mysql> SELECT LPAD(ROUND(RAND() * 1000000, 0), 6, '0') as \"验证码\"; +-----------+ | 验证码 | +-----------+ | 022516 | +-----------+ 日期函数常用函数： 函数 功能 CURDATE() 返回当前日期 CURTIME() 返回当前时间 NOW() 返回当前日期和时间 YEAR(date) 获取指定date的年份 MONTH(date) 获取指定date的月份 DAY(date) 获取指定date的日期 DATE_ADD(date, INTERVAL expr type) 返回一个日期/时间值加上一个时间间隔expr后的时间值 DATEDIFF(date1, date2) 返回起始时间date1和结束时间date2之间的天数 FROM_DAYS(number) 将日子总数转换为年月日 例子： -- CURDATE mysql> SELECT CURDATE() as \"today\"; +------------+ | today | +------------+ | 2022-09-17 | +------------+ -- CURTIME mysql> SELECT CURTIME() as \"time\"; +----------+ | time | +----------+ | 20:26:02 | +----------+ -- NOW mysql> SELECT NOW() as \"now\"; +---------------------+ | now | +---------------------+ | 2022-09-17 20:26:33 | +---------------------+ -- year mysql> SELECT YEAR(NOW()) as \"year\"; +------+ | year | +------+ | 2022 | +------+ -- DATE_ADD mysql> SELECT DATE_ADD(NOW(), INTERVAL 70 YEAR) as \"70years later\"; +---------------------+ | 70years later | +---------------------+ | 2092-09-17 20:28:56 | +---------------------+ -- DATEDIFF mysql> SELECT DATEDIFF('2022-9-17', '2021-12-10') as \"diff\"; +------+ | diff | +------+ | 281 | +------+ -- 查询所有学生的年龄，并且根据年龄倒叙排序 mysql> SELECT s_id, s_name, YEAR(FROM_DAYS(DATEDIFF(CURDATE(), s_birth))) as s_age FROM Student; mysql> SELECT s_id, s_name, TIMESTAMPDIFF(YEAR,s_birth,CURDATE()) as s_age FROM Student; +------+--------+-------+ | s_id | s_name | s_age | +------+--------+-------+ | 01 | 赵雷 | 32 | | 02 | 钱电 | 31 | | 03 | 孙风 | 32 | | 04 | 李云 | 32 | | 05 | 周梅 | 30 | | 06 | 吴兰 | 30 | | 07 | 郑竹 | 33 | | 08 | 王菊 | 32 | +------+--------+-------+ 流程函数常用函数： 函数 功能 IF(value, t, f) 如果value为true，则返回t，否则返回f IFNULL(value1, value2) 如果value1不为空，返回value1，否则返回value2 CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END 如果val1为true，返回res1，… 否则返回default默认值 CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END 如果expr的值等于val1，返回res1，… 否则返回default默认值 例子： -- IFNULL mysql> SELECT IFNULL('ok','default'); -- 不为空 +------------------------+ | IFNULL('ok','default') | +------------------------+ | ok | +------------------------+ mysql> SELECT IFNULL('','default'); -- 空串，返回空串 +----------------------+ | IFNULL('','default') | +----------------------+ | | +----------------------+ mysql> SELECT IFNULL(null,'default'); -- null +------------------------+ | IFNULL(null,'default') | +------------------------+ | default | +------------------------+ select name, (case when age > 30 then '中年' else '青年' end) from employee; select name, (case workaddress when '北京市' then '一线城市' when '上海市' then '一线城市' else '二线城市' end) as '工作地址' from employee; 约束分类： 约束 描述 关键字 非空约束 限制该字段的数据不能为null NOT NULL 唯一约束 保证该字段的所有数据都是唯一、不重复的 UNIQUE 主键约束 主键是一行数据的唯一标识，要求非空且唯一 PRIMARY KEY 默认约束 保存数据时，如果未指定该字段的值，则采用默认值 DEFAULT 检查约束（8.0.1版本后） 保证字段值满足某一个条件 CHECK 外键约束 用来让两张图的数据之间建立连接，保证数据的一致性和完整性 FOREIGN KEY 约束是作用于表中字段上的，可以再创建表/修改表的时候添加约束。 常用约束 约束条件 关键字 主键 PRIMARY KEY 自动增长 AUTO_INCREMENT 不为空 NOT NULL 唯一 UNIQUE 逻辑条件 CHECK 默认值 DEFAULT 例子： create table user( id int primary key auto_increment, name varchar(10) not null unique, age int check(age > 0 and age &lt; 120), status char(1) default '1', gender char(1) ); 外键约束添加外键： CREATE TABLE 表名( 字段名 字段类型, ... [CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名) ); ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名); -- 例子 alter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id); 删除外键：ALTER TABLE 表名 DROP FOREIGN KEY 外键名; 删除/更新行为 行为 说明 NO ACTION 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与RESTRICT一致） RESTRICT 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与NO ACTION一致） CASCADE 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除/更新外键在子表中的记录 SET NULL 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null） SET DEFAULT 父表有变更时，子表将外键设为一个默认值（Innodb不支持） 更改删除/更新行为：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为; 多表查询多表关系 一对多（多对一） 多对多 一对一 一对多案例：部门与员工关系：一个部门对应多个员工，一个员工对应一个部门实现：在多的一方建立外键，关联一的一方的主键 多对多案例：学生与课程关系：一个学生可以选多门课程，一门课程也可以供多个学生选修实现：建立第三张中间表student_course，中间表至少包含两个外键，分别关联两方主键 一对一案例：用户与用户详情关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE） 查询合并查询（笛卡尔积，会展示所有组合结果）：select * from employee, dept; 笛卡尔积：两个集合A集合和B集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积） 消除无效笛卡尔积：select * from employee, dept where employee.dept = dept.id; 内连接查询内连接查询的是两张表交集的部分 如果有数据不满足相交条件，则不会被查询到。 隐式内连接：SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...; 显式内连接：SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...; 显式性能比隐式高 例子： -- 查询员工姓名，及关联的部门的名称 -- 隐式 select e.name, d.name from employee as e, dept as d where e.dept = d.id; -- 显式 select e.name, d.name from employee as e inner join dept as d on e.dept = d.id; 外连接查询左外连接：查询左表所有数据，以及两张表交集部分数据SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ...;相当于查询表1的所有数据，包含表1和表2交集部分数据 右外连接：查询右表所有数据，以及两张表交集部分数据SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...; 例子： -- 左 select e.*, d.name from employee as e left outer join dept as d on e.dept = d.id; select d.name, e.* from dept d left outer join emp e on e.dept = d.id; -- 这条语句与下面的语句效果一样 -- 右 select d.name, e.* from employee as e right outer join dept as d on e.dept = d.id; 左连接可以查询到没有dept的employee，右连接可以查询到没有employee的dept 自连接查询当前表与自身的连接查询，自连接必须使用表别名 语法：SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...; 自连接查询，可以是内连接查询，也可以是外连接查询 例子： -- 查询员工及其所属领导的名字 select a.name, b.name from employee a, employee b where a.manager = b.id; -- 没有领导的也查询出来 select a.name, b.name from employee a left join employee b on a.manager = b.id; 联合查询 union, union all把多次查询的结果合并，形成一个新的查询集 语法： SELECT 字段列表 FROM 表A ... UNION [ALL] SELECT 字段列表 FROM 表B ... 薪资低于5k的员工和年龄大于50的员工。 注意事项 UNION ALL 会有重复结果，UNION 不会 多张表的列数和类型保持一致 联合查询比使用or效率高，不会使索引失效 子查询SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);子查询外部的语句可以是 INSERT / UPDATE / DELETE / SELECT 的任何一个 根据子查询结果可以分为： 标量子查询（子查询结果为单个值） 列子查询（子查询结果为一列） 行子查询（子查询结果为一行） 表子查询（子查询结果为多行多列） 根据子查询位置可分为： WHERE 之后 FROM 之后 SELECT 之后 标量子查询子查询返回的结果是单个值（数字、字符串、日期等）。常用操作符：- &lt; &gt; &gt; &gt;= &lt; &lt;= 例子： -- 查询销售部所有员工 -- 查询销售部的部门ID select id from dept where name = '销售部'; -- 根据销售部部门ID，查询员工信息 select * from employee where dept = 4; -- 合并（子查询） select * from employee where dept = (select id from dept where name = '销售部'); -- 查询xxx入职之后的员工信息 select * from employee where entrydate > (select entrydate from employee where name = 'xxx'); 列子查询返回的结果是一列（可以是多行）。 常用操作符： 操作符 描述 IN 在指定的集合范围内，多选一 NOT IN 不在指定的集合范围内 ANY 子查询返回列表中，有任意一个满足即可 SOME 与ANY等同，使用SOME的地方都可以使用ANY ALL 子查询返回列表的所有值都必须满足 例子： -- 查询销售部和市场部的所有员工信息 select * from employee where dept in (select id from dept where name = '销售部' or name = '市场部'); -- 查询比财务部 【所有人】all 工资都高的员工信息 select * from employee where salary > all(select salary from employee where dept = (select id from dept where name = '财务部')); -- 查询比研发部任意一人工资高的员工信息 select * from employee where salary > any (select salary from employee where dept = (select id from dept where name = '研发部')); 行子查询返回的结果是一行（可以是多列）。常用操作符：=, &lt;, &gt;, IN, NOT IN 例子： -- 查询与xxx的薪资及直属领导相同的员工信息 select * from employee where salary = 12500 and manager = 1; select * from employee where (salary, manager) = (12500, 1); select * from employee where (salary, manager) = (select salary, manager from employee where name = 'xxx'); 表子查询子查询结果是一张表 返回的结果是多行多列常用操作符：IN 例子： -- 查询与xxx1，xxx2的职位和薪资相同的员工 select * from employee where (job, salary) in (select job, salary from employee where name = 'xxx1' or name = 'xxx2'); -- 查询入职日期是2006-01-01之后的员工，及其部门信息 select e.*, d.* from (select * from employee where entrydate > '2006-01-01') as e left join dept as d on e.dept = d.id; 事务事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。 基本操作： -- 1. 查询张三账户余额 select * from account where name = '张三'; -- 2. 将张三账户余额-1000 update account set money = money - 1000 where name = '张三'; -- 此语句出错后张三钱减少但是李四钱没有增加 模拟sql语句错误 -- 3. 将李四账户余额+1000 update account set money = money + 1000 where name = '李四'; -- 查看事务提交方式 SELECT @@AUTOCOMMIT; -- 默认为1 -- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效 SET @@AUTOCOMMIT = 0; -- 提交事务 COMMIT; -- 回滚事务 ROLLBACK; -- 设置手动提交后上面代码改为： select * from account where name = '张三'; update account set money = money - 1000 where name = '张三'; update account set money = money + 1000 where name = '李四'; commit; 操作方式二： 开启事务：START TRANSACTION 或 BEGIN TRANSACTION;提交事务：COMMIT;回滚事务：ROLLBACK; 操作实例： start transaction; select * from account where name = '张三'; update account set money = money - 1000 where name = '张三'; update account set money = money + 1000 where name = '李四'; commit; 四大特性ACID 原子性(Atomicity)：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败 一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态 隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行 持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的 并发事务 问题 描述 脏读 一个事务读到另一个事务还没提交的数据 不可重复读 一个事务先后读取同一条记录，但两次读取的数据不同 幻读 一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在 并发隔离级别并发事务隔离级别： 隔离级别 脏读 不可重复读 幻读 Read uncommitted √ √ √ Read committed × √ √ Repeatable Read(默认) × × √ Serializable × × × √表示在当前隔离级别下该问题会出现 Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差 查看事务隔离级别：SELECT @@TRANSACTION_ISOLATION;设置事务隔离级别：SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE };SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效 Read Uncommitted设置隔离级别为Read uncommitted 脏读开启两个事务； 事务A查询余额表；事务B给其中一个用户U1的账户余额做修改，但未提交事务；此时事务A再次查询余额表，发现U1的余额和之前的查询不一致。 Read Committed不可重复读事务A查询余额表中U1的余额；事务B给U1的账户余额+100，并commit；事务A再次查询U1余额，发现U1账户有变化。 Repeatable Read解决不可重复读，即使事务B已经进行更新操作，但是事务A并未提交时，数据就不会更新，依然是事务A最初已知的值。 幻读事务A在余额表中查询id=3的记录，查到空集；【未提交】 事务B向余额表中插入id=3的记录，并提交；【已提交】 事务A向余额表中插入id=3的记录；【未提交】——报错 事务A第二次在余额表中查询id=3的记录，查到空集；【未提交】——产生幻读 Serializable解决幻读： 事务A在余额表中查询id=4的记录，查到空集；【未提交】 事务B向余额表中插入id=3的记录，并提交——此时被阻塞，只有事务A提交，才允许提交。 Linux操作服务端下载服务端：sudo apt-get install mysql-server下载客户端：sudo apt-get install mysql-client查看服务状态：sudo service mysql status停止服务：sudo service mysql stop启动服务：sudo service mysql start重启服务：sudo service mysql restartmysql配置文件：/etc/mysql/mysql.conf.d/mysqld.cnf 端口号：3306 bind-address：127.0.0.1默认 datadir：/var/lib/mysql log_error：/var/log/mysql/error.log Linux操作客户端连接服务端：mysql -uroot -p显示时间：select now（）退出连接：exit/quitMysql数据库操作 查看所有数据库：show databases； 创建数据库：create database 数据库名 charset = ‘utf8’； 使用数据库：use 数据库名； 查看当前使用的数据库：select database（）； 删除数据库：drop 数据库名； Mysql表操作 查看当前库中所有表：show tables； 创建表：create table 表名(字段名，类型，可选约束条件…)； 修改表字段：alter table 表名 modify 列名 类型 约束； 删除表：drop table 表名； 查看表结构：desc 表名； Mysql-CRUD操作 select：查询 select * from 表名 where 条件； insert：插入 全列插入：insert into 表名 values (…)； 部分插入：insert into 表名(列1…) values (值1…)； update：更新 update TABLENAME set ITEM1 = ‘VALUE’ delete：删除 delete from TABLENAME; Mysql备份和恢复 备份：mysqldump -u用户名 -p密码 数据库名 表名 data.sql - --all：所有数据库 恢复：source data.sql","categories":[{"name":"MySql","slug":"MySql","permalink":"https://liaoxingwang.github.io/categories/MySql/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"https://liaoxingwang.github.io/tags/MySql/"}],"author":"廖兴旺"},{"title":"日常开发中，提升技术建议","slug":"Blog-Open-Source-Promotion","date":"2023-05-17T09:20:00.000Z","updated":"2024-12-19T06:53:09.544Z","comments":true,"path":"2023/05/17/blog-open-source-promotion/","link":"","permalink":"https://liaoxingwang.github.io/2023/05/17/blog-open-source-promotion/","excerpt":"","text":"日常开发中，提升技术建议1. 打好基础,深入学习语言特性先打好基础 比如，对于Java程序员来说,要了解Java语言的基本概念和核心特性，包括面向对象编程、集合框架、异常处理、多线程等等。可以通过阅读Java的官方文档、教程、参考书籍或在线资源来学习。 如果最基本的基础都不扎实，就不要谈什么提升技术啦。 比如说： 你知道HashMap和ConcurrentHashMap的区别嘛? 在什么时候使用ConcurrentHashMap？ 操作文件的时候，你知道在finally块中释放资源嘛? 你知道在哪些场景适合用泛型嘛? 因此,要提升自身技术,首先就是要把基础打扎实。有些小伙伴说,上班没时间学基础呀,其实不是这样的,基础这玩意,每天地铁上下班看看,下班后回到家再看看,周末在家看看，多点写写代码,一般一两个月,你的基础就很好啦。 又有些小伙伴说，如何提升Java基础呢？有哪些教程推荐呢？可以： 阅读Java相关书籍或教程，如Java编程思想、Java核心技术、Java虚拟机、菜鸟教程等 阅读Java博客和社区参与讨论：关注Java领域的博客、论坛和社区，了解最新的技术动态和解决方案，与其他开发者交流。 多实践，多敲代码：在B站找个Java基础视频看，平时多实践、多敲代码 2. 熟悉掌握常用的开发工具工欲善其事，必先利其器. 所以一位好的程序员,往往编码效率就更高。而提升编码效率,一般要求熟悉并灵活应用工具.比如Eclipse、IntelliJ IDEA、Maven、Navicat等。熟悉运用这些工具，可以提高开发效率。 我举个例子,比如你熟悉掌握IntelliJ IDEA的快捷键,三两下就把实体类的setter和getter方法生成了,而有些的程序员,还在一行一行慢慢敲。。 3. 日常工作中，总结你踩过的坑优秀的程序员,之所以优秀,是因为他会总结踩过的坑,避免重蹈覆辙。所以 ，日常开发中,如果你踩了哪些坑,就需要总结下来.茶余饭后,再温习温习. 比如,你知道： Redis分布式锁使用,可能会有哪些坑嘛? 线程池使用有哪些坑? Java日期处理有哪些坑嘛? Arrays.asList使用可能有哪些坑? 如果一时间忘记的话,可以看下我以前的这些文章: 细数线程池的10个坑 Redis分布式锁的10个坑 Java日常开发的21个坑，你踩过几个？ 程序员必备：Java日期处理的十个坑 这些都是我工作总结出来的,也希望你们日常开发中,遇到哪些坑,都总结下来哈。 4.工作中,阅读你们系统优秀的代码和设计文档孔子说,三人行,必有我师。大家平时在看代码的时候,不要总吐槽着项目的烂代码。其实,可以多点关注写得优秀的代码,然后看懂别人为什么这些写,仿造着来写。 当然,一些好的设计文档也是:人家为什么这么设计,好处在哪里,不足又在哪里,如果是你来设计,你如何思考等等。把好的设计,读懂后,记录下来,变成自己的知识.学习优秀的代码和设计文档 5.日常工作中,总结一些通用的技术方案.在日常工作中呢,注意整理一些通用的技术方案。 比如幂等设计、分布式锁如何设计、分布式事务设计、接口优化、限流设计、分库分表设计、深分页问题解决等等. 大家可以看下我之前的一些通用方案设计的文章哈: 后端思想篇：设计好接口的36个锦囊！ 我们为什么要分库分表？ 面试必备：聊聊分布式锁的多种实现！ 聊聊幂等设计 实战！聊聊如何解决MySQL深分页问题 当然，日常开发中，把自己遇到的一些通用设计方案总结下来，熟悉掌握这些通用技术方案。 6.参与技术讨论,积极技术分享参与技术讨论和交流，可以有助于你与其他Java开发者分享经验、解决问题和学习新知识。进行技术分享，可以加深自己的理解、建立专业声誉、促进个人成长、为技术社区做贡献等等。 比如你做需求遇到的一些难题，都可以跟有经验的同事、或者技术leader讨论讨论。一些常见的难题，讨论完可以记录下来，然后做技术分享。 7. 主人翁意识,积极攻克项目的难题作为一名开发工程师，具备主人翁意识并积极攻克项目的难题，是非常重要的。遇到项目中的比较棘手问题时，先不管是谁的问题，我们都要持有主人翁意识，积极主动地找到解决方案并采取行动。 而在找技术解决方案的过程，我们也就成长了。当攻克问题后，你也获得领导的认可，好绩效不远了，一举多得！ 8. 思考项目中,哪些可以提升效率日常开发中，几乎大多数程序员都是在进行增删改查。如何如何避免自己成为平凡的增删改查程序员呢。 我觉得可以这样做：平时工作中，思考项目中，有哪些可以提升的效率。包括熟悉开发工具、掌握适当的调试技巧、熟悉常用框架、持续学习和关注技术发展 多思考，提升开发效率等等。 比如： 好的的debug调试技巧，可以让你快速找到问题 再比如一个插件easyyapi可以一键让你快速生成yapi接口文档，而不用一个一个字段手工敲接口文档。 当然，日常开发中，还有很多可以提升效率的技巧/工具，等待我们去发现。 9. 熟悉你的业务,让自己不容易被替代我们普通程序员，多数都是做业务的。一般工作个五年以上，水平差不了太多。如何避免自己被淘汰呢？我个人建议是，尽量做到熟悉你们做的业务，让自己变得不容易被替代。 10. 多看看你的系统，可能存在哪些问题，如接口耗时、慢SQL等等一般的系统，多多少少都有些问题。比如接口耗时过长、慢SQL、fullGC频繁等等。 首先需要掌握这些技能，比如如何优化接口，如何优化慢SQL、fullGC如何排查等等。大家可以看下这几篇文章哈： 实战总结！18种接口优化方案的总结 盘点MySQL慢查询的12个原因 SQL优化思路+经典案例分析 JAVA线上故障排查全家桶 线上服务的FGC问题排查，看这篇就够了！ 11. 学以致用，将理论知识应用到实际项目中很多小伙伴说，看过很多计算机相关的书，阅读过很多博客，背了很多八股文，依然做不好一个系统。 我觉得，大家可以多点思考，把平时积累的东西，应用到实际项目中。背八股文不是没用，你可以把它应用到实际开发中的。比如说，IO模型详解 这个表面看起来就是一个常见的八股文知识点，工作中似乎没用到。但是我在工作中，就用到这种类似的异步思想： 比如发起一笔批量转账，但是批量转账处理比较耗时，这时候后端可以先告知前端转账提交成功，等到结果处理完，再通知前端结果即可。 再比如MySQL索引15连问，抗住！，你是不是可以回头看看，你的系统中，那些sql的索引加的是否合理呢？是不是可以思考一下如何优化，对吧。因此，就是要学以致用。 12. 阅读一些优秀框架的源码，如spring、rockectMq等等如果你有空余的时间，就建议你看看一些优化框架的源码，比如spring、rockectMq等等。 对于spring源码的话，可以按模块来呀，比如aop，控制反转，spring事务等，你先写个demo，然后debug跟踪流程，通过调试器逐步跟踪源码执行过程，观察各个方法的调用关系和数据变化。最好是结合电子书一起，如（Spring源码深度解析这本书一起） 优秀框架的源码，我们可以学习到很多编码思想的，加油。 13. 多编码，少偷懒，养成编程的好习惯作为程序员，一定要多打代码，不要偷懒，代码敲多了，你就会了。还有就是，少点偷懒，坚持！努力！养成热爱编程的好习惯。 总之，提升技术需要不断学习、实践、总结和积累经验。","categories":[{"name":"Java","slug":"Java","permalink":"https://liaoxingwang.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://liaoxingwang.github.io/tags/Java/"}],"author":"廖兴旺"},{"title":"Git学习之常用命令","slug":"Blog-Open-Source-GitLearn","date":"2023-05-15T09:20:00.000Z","updated":"2024-12-19T06:53:09.540Z","comments":true,"path":"2023/05/15/blog-open-source-gitlearn/","link":"","permalink":"https://liaoxingwang.github.io/2023/05/15/blog-open-source-gitlearn/","excerpt":"","text":"实际工作中常用命令汇总： 查看远程分支：$ git branch -a 查看本地分支：$ git branch 切换分支：$ git checkout 分支名 更新到指定版本：$ git reset –hard 39c9064fe34a1331e3624fbbef33a3f66df8f6ba 更新到上个版本：$ git reset –hard HEAD^ 将远程分支下载到本地：$ git checkout -b branch1 origin/branch1 创建新分支，并立即切换到此新分支：$ git checkout -b branchname 从远程分支下载指定的分支：$ git pull origin branchname 查看某个文件作了哪些修改：$ git diff src/a.cpp 在合并进仓库之前，修改上次的提交：$ git commit –amend 撤销为提交的修改：$ git checkout – a.cpp 撤销当前目录下所有文件的修改(慎用)：$ git checkout . 查看某个文件详细的修改信息：$ git blame src/a.cpp 删除本地所有未提交的新增的文件(如果文件已经被staged不会被回退)：$ git clean -df 撤销本地所有未提交的更改(包括已经被staged的文件，但不包括新增的文件)：$ git reset –hard 修改指定文件的名字，如将a.cpp重命名为b.cpp：$ git mv a.cpp b.cpp 删除远程仓库中指定的文件src/a.cpp：$ git rm src/a.cpp 删除远程仓库中指定的目录src/aa：$ git rm src/aa -r -f 假如之前基于master新建了一个分支dev，但是后来master有了多于一次的提交，但是dev一直没有改动，假如现在想把master的提交更新到dev分支上，因为dev分支一直没有改动过，假如master提交了两次，除了手动调整改动的文件外还可以这样操作，当前在dev分支：$ git merge master , $ git reset HEAD^^，因为master多于一次的提交，直接git merge master,在git push是不行的 如果一个项目的提交记录太多，直接使用git log并不太方便查看提交历史，此时可通过tree的方式输出，执行如下命令后，每次查看时终端执行 $ git lg 即可 git config –global alias.lg “log –graph –abbrev-commit –decorate –format=format:’%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)’ –all”21. 本地执行git branch -a查看远程分支时出现了一些实际远程仓库中已不存在的分支，此时可在本地执行：git pull –prune命令清理远程仓库中已不存在的分支 从另一个分支dev拷贝文件funset.hpp或目录到现在的分支master，则执行：$ git checkout dev funset.hpp ,执行后funset.hpp在master分支中默认是暂存状态；若取消暂存，可执行: $ get reset HEAD 1.git clone当我们要进行开发，第一步就是克隆远程版本库到本地呢 git clone url 克隆远程版本库 2.git checkout -b dev克隆完之后呢，开发新需求的话，我们需要新建一个开发分支，比如新建开发分支dev 创建分支： git checkout -b dev 创建开发分支dev，并切换到该分支下 3.git addgit add的使用格式： git add .添加当前目录的所有文件到暂存区 git add [dir]添加指定目录到暂存区，包括子目录 git add [file1]添加指定文件到暂存区 有了开发分支dev之后，我们就可以开始开发啦，假设我们开发完HelloWorld.java，可以把它加到暂存区，命令如下 git add Hello.java 把HelloWorld.java文件添加到暂存区去 4.git commitgit commit的使用格式： git commit -m [message] 提交暂存区到仓库区,message为说明信息 git commit [file1] -m [message] 提交暂存区的指定文件到本地仓库 git commit --amend -m [message] 使用一次新的commit，替代上一次提交 把HelloWorld.java文件加到暂存区后，我们接着可以提交到本地仓库啦~ git commit -m 'helloworld开发' 5.git statusgit status,表示查看工作区状态，使用命令格式： git status 查看当前工作区暂存区变动 git status -s 查看当前工作区暂存区变动，概要信息 git status --show-stash 查询工作区中是否有stash（暂存的文件） 当你忘记是否已把代码文件添加到暂存区或者是否提交到本地仓库，都可以用git status看看哦~ 6.git loggit log，这个命令用得应该比较多，表示查看提交历史/提交日志~ git log 查看提交历史 git log --oneline 以精简模式显示查看提交历史 git log -p &lt;file> 查看指定文件的提交历史 git blame &lt;file> 一列表方式查看指定文件的提交历史 嘻嘻，看看dev分支上的提交历史吧要回滚代码就经常用它喵喵提交历史 7.git diffgit diff 显示暂存区和工作区的差异 git diff filepath filepath路径文件中，工作区与暂存区的比较差异 git diff HEAD filepath 工作区与HEAD ( 当前工作分支)的比较差异 git diff branchName filepath 当前分支的文件与branchName分支的文件的比较差异 git diff commitId filepath 与某一次提交的比较差异 如果你想对比一下你改了哪些内容，可以用git diff对比一下文件修改差异哦 8.git pull/git fetchgit pull 拉取远程仓库所有分支更新并合并到本地分支。 git pull origin master 将远程master分支合并到当前本地分支 git pull origin master:master 将远程master分支合并到当前本地master分支，冒号后面表示本地分支 git fetch --all 拉取所有远端的最新代码 git fetch origin master 拉取远程最新master分支代码 我们一般都会用git pull拉取最新代码看看的，解决一下冲突，再推送代码到远程仓库的。 有些伙伴可能对使用git pull还是git fetch有点疑惑，其实 git pull = git fetch+ git merge。pull的话，拉取远程分支并与本地分支合并，fetch只是拉远程分支，怎么合并，可以自己再做选择。 9.git pushgit push 可以推送本地分支、标签到远程仓库，也可以删除远程分支哦。 git push origin master 将本地分支的更新全部推送到远程仓库master分支。 git push origin -d 删除远程branchname分支 git push --tags 推送所有标签 如果我们在dev开发完，或者就想把文件推送到远程仓库，给别的伙伴看看，就可以使用git push origin dev~ Git 的相关理论基础1.Git的四大工作区域先复习Git的几个工作区域哈： Workspace：你电脑本地看到的文件和目录，在Git的版本控制下，构成了工作区。 Index/Stage：暂存区，一般存放在 .git目录下，即.git/index,它又叫待提交更新区，用于临时存放你未提交的改动。比如，你执行git add，这些改动就添加到这个区域啦。 Repository：本地仓库，你执行git clone 地址，就是把远程仓库克隆到本地仓库。它是一个存放在本地的版本库，其中HEAD指向最新放入仓库的版本。当你执行git commit，文件改动就到本地仓库来了~ Remote：远程仓库，就是类似github，码云等网站所提供的仓库，可以理解为远程数据交换的仓库~ 2.Git的工作流程上一小节介绍完Git的四大工作区域，这一小节呢，介绍Git的工作流程咯，把git的操作命令和几个工作区域结合起来，个人觉得更容易理解一些。 git 的正向工作流程一般就这样： 从远程仓库拉取文件代码回来； 在工作目录，增删改查文件； 把改动的文件放入暂存区； 将暂存区的文件提交本地仓库； 将本地仓库的文件推送到远程仓库； 3.Git文件的四种状态根据一个文件是否已加入版本控制，可以把文件状态分为：Tracked(已跟踪)和Untracked(未跟踪)，而tracked(已跟踪)又包括三种工作状态：Unmodified，Modified，Staged Untracked: 文件还没有加入到git库，还没参与版本控制，即未跟踪状态。这时候的文件，通过git add 状态，可以变为Staged状态 Unmodified：文件已经加入git库, 但是呢，还没修改, 就是说版本库中的文件快照内容与文件夹中还完全一致。Unmodified的文件如果被修改, 就会变为Modified. 如果使用git remove移出版本库, 则成为Untracked文件。 Modified：文件被修改了，就进入modified状态啦，文件这个状态通过stage命令可以进入staged状态 staged：暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodified状态. 4.一张图解释Git的工作原理 Git 进阶之分支处理Git一般都是存在多个分支的，开发分支，回归测试分支以及主干分支等，所以Git分支处理的命令也需要很熟悉的呀~ git branch git checkout git merge 1.git branchgit branch用处多多呢，比如新建分支、查看分支、删除分支等等 新建分支： git checkout -b dev2 新建一个分支，并且切换到新的分支dev2 git branch dev2 新建一个分支，但是仍停留在原来分支 查看分支： git branch 查看本地所有的分支 git branch -r 查看所有远程的分支 git branch -a 查看所有远程分支和本地分支 删除分支： git branch -D 删除本地branchname分支 2.git checkout切换分支： git checkout master 切换到master分支 3.git merge我们在开发分支dev开发、测试完成在发布之前，我们一般需要把开发分支dev代码合并到master，所以git merge也是程序员必备的一个命令。 git merge master 在当前分支上合并master分支过来 git merge --no-ff origin/dev 在当前分支上合并远程分支dev git merge --abort 终止本次merge，并回到merge前的状态 比如，你开发完需求后，发版需要把代码合到主干master分支，如下： Git 进阶之处理冲突Git版本控制，是多个人一起搞的，多个分支并存的，这就难免会有冲突出现~ 1.Git合并分支，冲突出现同一个文件，在合并分支的时候，如果同一行被多个分支或者不同人都修改了，合并的时候就会出现冲突。 举个粟子吧，我们现在在dev分支，修改HelloWorld.java文件，假设修改了第三行，并且commit提交到本地仓库，修改内容如下： public class HelloWorld { public static void main(String[] args) { System.out.println(\"Hello，捡田螺的小男孩！\"); } } 我们切回到master分支，也修改HelloWorld.java同一位置内容，如下： public class HelloWorld { public static void main(String[] args) { System.out.println(\"Hello，jay！！\"); } } 再然后呢，我们提交一下master分支的这个改动，并把dev分支合并过下，就出现冲突啦，如图所示： 2.Git解决冲突Git 解决冲突步骤如下： 查看冲突文件内容 确定冲突内容保留哪些部分，修改文件 重新提交，done 1）查看冲突文件内容git merge提示冲突后，我们切换到对应文件，看看冲突内容哈，，如下： 2）确定冲突内容保留哪些部分，修改文件 Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容， &lt;&lt;&lt;&lt;&lt;&lt;&lt;HEAD是指主分支修改的内容，&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev是指dev分支上修改的内容 所以呢，我们确定到底保留哪个分支内容，还是两个分支内容都保留呢，然后再去修改文件冲突内容~ 3）修改完冲突文件内容，我们重新提交，冲突done Git 进阶之撤销与回退Git的撤销与回退，在日常工作中使用的比较频繁。比如我们想将某个修改后的文件撤销到上一个版本，或者想撤销某次多余的提交，都要用到git的撤销和回退操作。 代码在Git的每个工作区域都是用哪些命令撤销或者回退的呢，如下图所示： 有关于Git的撤销与回退，一般就以下几个核心命令 git checkout git reset git revert 1.git checkout如果文件还在工作区，还没添加到暂存区，可以使用git checkout撤销 git checkout [file] 丢弃某个文件file git checkout . 丢弃所有文件 以下demo，使用git checkout – test.txt 撤销了test.txt的修改 2.git resetgit reset的理解 git reset的作用是修改HEAD的位置，即将HEAD指向的位置改变为之前存在的某个版本. 为了更好地理解git reset，我们来回顾一下,Git的版本管理及HEAD的理解 Git的所有提交，会连成一条时间轴线，这就是分支。如果当前分支是master，HEAD指针一般指向当前分支，如下： 假设执行git reset，回退到版本二之后，版本三不见了哦,如下： git reset的使用Git Reset的几种使用模式 git reset HEAD --file 回退暂存区里的某个文件，回退到当前版本工作区状态 git reset –-soft 目标版本号 可以把版本库上的提交回退到暂存区，修改记录保留 git reset –-mixed 目标版本号 可以把版本库上的提交回退到工作区，修改记录保留 git reset –-hard 可以把版本库上的提交彻底回退，修改的记录全部revert。 先看一个粟子demo吧，代码git add到暂存区，并未commit提交,可以酱紫回退，如下： git reset HEAD file 取消暂存 git checkout file 撤销修改 再看另外一个粟子吧，代码已经git commit了，但是还没有push： git log 获取到想要回退的commit_id git reset --hard commit_id 想回到过去，回到过去的commit_id 如果代码已经push到远程仓库了呢，也可以使用reset回滚哦(这里大家可以自己操作实践一下哦)~ git log git reset --hard commit_id git push origin HEAD --force 3.git revert 与git reset不同的是，revert复制了那个想要回退到的历史版本，将它加在当前分支的最前端。 revert之前： revert 之后： 当然，如果代码已经推送到远程的话，还可以考虑revert回滚呢 git log 得到你需要回退一次提交的commit id git revert -n &lt;commit_id> 撤销指定的版本，撤销也会作为一次提交进行保存 Git 进阶之标签 tag打tag就是对发布的版本标注一个版本号，如果版本发布有问题，就把该版本拉取出来，修复bug，再合回去。 git tag 列出所有tag git tag [tag] 新建一个tag在当前commit git tag [tag] [commit] 新建一个tag在指定commit git tag -d [tag] 删除本地tag git push origin [tag] 推送tag到远程 git show [tag] 查看tag git checkout -b [branch] [tag] 新建一个分支，指向某个tag Git 其他一些经典命令1.git rebaserebase又称为衍合，是合并的另外一种选择。 假设有两个分支master和test D---E test / A---B---C---F--- master 执行 git merge test得到的结果 D--------E / \\ A---B---C---F----G--- test, master 执行git rebase test，得到的结果 A---B---D---E---C‘---F‘--- test, master rebase好处是： 获得更优雅的提交树，可以线性的看到每一次提交，并且没有增加提交节点。所以很多时候，看到有些伙伴都是这个命令拉代码：git pull –rebase，就是因为想更优雅，哈哈 2.git stashstash命令可用于临时保存和恢复修改 git stash 把当前的工作隐藏起来 等以后恢复现场后继续工作 git stash list 显示保存的工作进度列表 git stash pop stash@{num} 恢复工作进度到工作区 git stash show ：显示做了哪些改动 git stash drop stash@{num} ：删除一条保存的工作进度 git stash clear 删除所有缓存的stash。 3.git reflog显示当前分支的最近几次提交 4.git blame filepathgit blame 记录了某个文件的更改历史和更改人，可以查看背锅人，哈哈 5.git remotegit remote 查看关联的远程仓库的名称 git remote add url 添加一个远程仓库 git remote show [remote] 显示某个远程仓库的信息","categories":[{"name":"Git","slug":"Git","permalink":"https://liaoxingwang.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://liaoxingwang.github.io/tags/Git/"}],"author":"廖兴旺"},{"title":"MyBatis-Plus学习记录","slug":"Blog-Open-Source-MyBatis-Plus","date":"2023-05-12T09:20:00.000Z","updated":"2024-12-19T06:53:09.542Z","comments":true,"path":"2023/05/12/blog-open-source-mybatis-plus/","link":"","permalink":"https://liaoxingwang.github.io/2023/05/12/blog-open-source-mybatis-plus/","excerpt":"","text":"MyBatis-Plus通用查询CRUD接口service接口：service继承BaseMapper 1、查询/* 1、Get：查询一个 */ // 根据 ID 查询 T getById(Serializable id); // 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(\"LIMIT 1\") T getOne(Wrapper&lt;T> queryWrapper); // 根据 Wrapper，查询一条记录 T getOne(Wrapper&lt;T> queryWrapper, boolean throwEx); // 根据 Wrapper，查询一条记录 Map&lt;String, Object> getMap(Wrapper&lt;T> queryWrapper); /* 2、List：查询多条 */ // 查询所有 List&lt;T> list(); // 查询列表 List&lt;T> list(Wrapper&lt;T> queryWrapper); // 查询（根据ID 批量查询） Collection&lt;T> listByIds(Collection&lt;? extends Serializable> idList); // 查询（根据 columnMap 条件） Collection&lt;T> listByMap(Map&lt;String, Object> columnMap); // 查询所有列表 List&lt;Map&lt;String, Object>> listMaps(); // 查询列表 List&lt;Map&lt;String, Object>> listMaps(Wrapper&lt;T> queryWrapper); /* 3、Page：分页查询 */ // 无条件分页查询 IPage&lt;T> page(IPage&lt;T> page); // 条件分页查询 IPage&lt;T> page(IPage&lt;T> page, Wrapper&lt;T> queryWrapper); // 无条件分页查询 IPage&lt;Map&lt;String, Object>> pageMaps(IPage&lt;T> page); // 条件分页查询 IPage&lt;Map&lt;String, Object>> pageMaps(IPage&lt;T> page, Wrapper&lt;T> queryWrapper); /* 4、Count：条数 // 查询总记录数 int count(); // 根据 Wrapper 条件，查询总记录数 int count(Wrapper&lt;T> queryWrapper); 2、添加/* 1、Save */ // 插入一条记录（选择字段，策略插入） boolean save(T entity); // 插入（批量） boolean saveBatch(Collection&lt;T> entityList); // 插入（批量） boolean saveBatch(Collection&lt;T> entityList, int batchSize); /* 2、SaveOrUpdate */ // TableId 注解存在更新记录，否插入一条记录 boolean saveOrUpdate(T entity); // 根据updateWrapper尝试更新，否继续执行saveOrUpdate(T)方法 boolean saveOrUpdate(T entity, Wrapper&lt;T> updateWrapper); // 批量修改插入 boolean saveOrUpdateBatch(Collection&lt;T> entityList); // 批量修改插入 boolean saveOrUpdateBatch(Collection&lt;T> entityList, int batchSize); 3、修改// 根据 UpdateWrapper 条件，更新记录 需要设置sqlset boolean update(Wrapper&lt;T> updateWrapper); // 根据 whereEntity 条件，更新记录 boolean update(T entity, Wrapper&lt;T> updateWrapper); // 根据 ID 选择修改 boolean updateById(T entity); // 根据ID 批量更新 boolean updateBatchById(Collection&lt;T> entityList); // 根据ID 批量更新 boolean updateBatchById(Collection&lt;T> entityList, int batchSize); 4、删除// 根据 entity 条件，删除记录 boolean remove(Wrapper&lt;T&gt; queryWrapper); // 根据 ID 删除 boolean removeById(Serializable id); // 根据 columnMap 条件，删除记录 boolean removeByMap(Map&lt;String, Object&gt; columnMap); // 删除（根据ID 批量删除） boolean removeByIds(Collection&lt;? extends Serializable&gt; idList); 5、链式操作// 链式查询 普通 QueryChainWrapper&lt;T&gt; query(); // 链式查询 lambda 式。注意：不支持 Kotlin LambdaQueryChainWrapper&lt;T&gt; lambdaQuery(); // 示例： query().eq(&quot;column&quot;, value).one(); lambdaQuery().eq(Entity::getId, value).list(); // 链式更改 普通 UpdateChainWrapper&lt;T&gt; update(); // 链式更改 lambda 式。注意：不支持 Kotlin LambdaUpdateChainWrapper&lt;T&gt; lambdaUpdate(); // 示例： update().eq(&quot;column&quot;, value).remove(); lambdaUpdate().eq(Entity::getId, value).update(entity); Lambda官方表示，3.x支持Lambda表达式，那应该怎么使用呢？我们来看个例子： QueryWrapper&lt;Student> queryWrapper = new QueryWrapper&lt;>(); queryWrapper.lambda().eq(Student::getName, \"廖兴旺\"); List&lt;Student> studentList = list(queryWrapper); for (Student student : studentList) Console.info(student); 条件查询【1】多eq QueryWrapper&lt;Student&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.lambda() .eq(Student::getName, &quot;廖兴旺&quot;) .eq(Student::getAge, 26); List&lt;Student&gt; studentList = list(queryWrapper); for (Student student : studentList) Console.info(new Gson().toJson(student));对于这部分的测试，我想结果是毫无因为，那么你应该关注什么呢？没错，SQL，所以，我们直接看SQL。当然，结果也是可以看到的。 ==&gt; Preparing: SELECT id,name,age,info,is_delete,create_time,update_time,gender,idcard_id,city_id FROM t_student WHERE name = ? AND age = ? ==&gt; Parameters: 廖兴旺(String), 26(Integer) &lt;== Columns: id, name, age, info, is_delete, create_time, update_time, gender, idcard_id, city_id &lt;== Row: 1035789714459471874, 廖兴旺, 26, &lt;&lt;BLOB&gt;&gt;, 0, 2018-09-01 15:21:26.0, 2018-09-01 15:21:26.0, 1, 1035789714388168706, 1035762001753501698 &lt;== Total: 1我们还可以这样写： QueryWrapper&lt;Student&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.lambda() .and(obj -&gt; obj.eq(Student::getName, &quot;廖兴旺&quot;) .eq(Student::getAge, 26)); List&lt;Student&gt; studentList = list(queryWrapper); for (Student student : studentList) Console.info(new Gson().toJson(student));【2】or 第一种： QueryWrapper&lt;Student&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.lambda() .or(obj1 -&gt; obj1.eq(Student::getName, &quot;廖兴旺&quot;)) .or(obj2 -&gt; obj2.eq(Student::getName, &quot;1&quot;)); List&lt;Student&gt; studentList = list(queryWrapper); for (Student student : studentList) Console.info(new Gson().toJson(student));sql: SELECT * FROM t_student WHERE ( name = ? ) OR ( name = ? ) 第二种： QueryWrapper&lt;Student&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.lambda() .eq(Student::getName, &quot;廖兴旺&quot;) .or() .eq(Student::getName, &quot;1&quot;); List&lt;Student&gt; studentList = list(queryWrapper); for (Student student : studentList) Console.info(new Gson().toJson(student));SQL: SELECT * FROM t_student WHERE name = ? OR name = ? 这样的话，我们就可以拼接各种条件了。那么问题来了：到底有哪些关键字呢？性能如何呢？ 条件构造器条件参数说明 查询方式 说明 setSqlSelect 设置 SELECT 查询字段 where WHERE 语句，拼接 + WHERE 条件 and AND 语句，拼接 + AND 字段=值 andNew AND 语句，拼接 + AND (字段=值) or OR 语句，拼接 + OR 字段=值 orNew OR 语句，拼接 + OR (字段=值) eq 等于= allEq 基于 map 内容等于= ne 不等于&lt;&gt; gt 大于&gt; ge 大于等于&gt;= lt 小于&lt; le 小于等于&lt;= like 模糊查询 LIKE notLike 模糊查询 NOT LIKE in IN 查询 notIn NOT IN 查询 isNull NULL 值查询 isNotNull IS NOT NULL groupBy 分组 GROUP BY having HAVING 关键词 orderBy 排序 ORDER BY orderAsc ASC 排序 ORDER BY orderDesc DESC 排序 ORDER BY exists EXISTS 条件语句 notExists NOT EXISTS 条件语句 between BETWEEN 条件语句 notBetween NOT BETWEEN 条件语句 addFilter 自由拼接 SQL last 拼接在最后，例如：last(“LIMIT 1”) 注意！ xxNew 都是另起 ( ... ) 括号包裹。 自定义sql如果官方提供的满足不了你的需求，或者你的需求很复杂，导致你不知道如何使用条件构造器，那应该怎么办呢？ 很简单。 第一步：找到 Dao，写一个数据库操作接口 public interface StudentDao extends BaseMapper&lt;Student> { List&lt;Student> selectAll(); } 第二步：在xml文件中写sql &lt;!--List&lt;Student&gt; selectAll();--&gt; &lt;select id=&quot;selectAll&quot; resultMap=&quot;BaseResultMap&quot;&gt; select * from t_student &lt;/select&gt;这样我们就可以使用了： @Resource StudentDao studentDao; List&lt;Student&gt; studentList = studentDao.selectAll(); for (Student student : studentList) Console.info(new Gson().toJson(student));测试： 封装我们自己的Service前面我们就说了，我是很不喜欢MP的查询接口的，我们就把他弄成我们喜欢的吧，我这里借鉴 JPA接口了，哈哈 interface: /** * 查询所有数据 * @return List&lt;Student&gt; */ List&lt;Student&gt; findAll(); /** * 查询部分数据 * @return List&lt;Student&gt; */ List&lt;Student&gt; findList(); /** * 查询一条数据 * @return Student */ Student findOne(); /** * 根据主键ID查询数据 * @param id 主键ID，为null，返回null * @return Student */ Student findById(Long id);impl: @Override public List&lt;Student&gt; findAll() { return list(null); } @Override public List&lt;Student&gt; findList() { return list(null); } @Override public Student findOne() { return getOne(null); } @Override public Student findById(Long id) { ExceptionUtil.notNull(id, &quot;id must not null.&quot;); return getById(id); } 预览一、条件构造器关系介绍 条件构造器关系介绍 ：上图绿色框为抽象类abstract蓝色框为正常class类，可new对象黄色箭头指向为父子类关系，箭头指向为父类 wapper介绍 ： Wrapper ： 条件构造抽象类，最顶端父类 AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件 QueryWrapper ： Entity 对象封装操作类，不是用lambda语法 UpdateWrapper ： Update 条件封装，用于Entity对象更新操作 AbstractLambdaWrapper ： Lambda 语法使用 Wrapper统一处理解析 lambda 获取 column。 LambdaQueryWrapper ：看名称也能明白就是用于Lambda语法使用的查询Wrapper LambdaUpdateWrapper ： Lambda 更新封装Wrapper 先了解一下内外连接：什么是连接表？多表查询原理：将多个表通过笛卡尔积形成一个虚表，再根据查询条件筛选符合条件的数据。在关系数据库中，数据分布在多个逻辑表中。 要获得完整有意义的数据集，需要使用连接来查询这些表中的数据。 SQL Server支持多种连接包括INNER JOIN:内连接,关键字在表中存在至少一个匹配时返回行。left join : 左连接，返回左表中所有的记录以及右表中连接字段相等的记录。right join : 右连接，返回右表中所有的记录以及左表中连接字段相等的记录。inner join : 内连接，又叫等值连接，只返回两个表中连接字段相等的行。full join : 外连接，返回两个表中的行：left join + right join。cross join : 结果是笛卡尔积，就是第一个表的行数乘以第二个表的行数。GROUP BY:全外连接， 子句必须放在 WHERE 子句中的条件之后，必须放在 ORDER BY 子句之前每种连接类型指定SQL Server如何使用一个表中的数据来选择另一个表中的行 SQL内连接(INNER JOIN)返回两张表中符合连接条件的数据行 内连接是从结果表中删除与被连接表中未匹配行的所有行，所以内连接可能会丢失信息 SQL外连接（OUTER JOIN） 外连接（OUTER JOIN）分 为左连接、右连接和全连接 左连接：返回左表中的所以行，如果左表中行在右表中没有匹配行，则结果中右表中的列返回空值NULL 语法：SELECT * FROM 表1 LEFT OUTER JOIN 表2 ON 条件eg：我们左连接Student表、Score表查询学生的成绩，SQL 语句如下：SELECT * FROM Student LEFT OUTER JOIN Score ON Student.id = Score.studentID 右 连 接：返回右表中的所以行，如果右表中行在左表中没有匹配行，则结果中左表中的列返回空值NULL 语法：SELECT * FROM 表1 RIGHT OUTER JOIN 表2 ON 条件eg：我们右连接Student表、Score表查询学生的成绩，SQL 语句如下：SELECT * FROM Student RIGHT OUTER JOIN Score ON Student.id = Score.studentID 全连接：返回左表和右表中的所有行，当某行在另一表中没有匹配行，则另一表中的补NULL","categories":[{"name":"MyBatis-Plus","slug":"MyBatis-Plus","permalink":"https://liaoxingwang.github.io/categories/MyBatis-Plus/"}],"tags":[{"name":"MyBatis-Plus","slug":"MyBatis-Plus","permalink":"https://liaoxingwang.github.io/tags/MyBatis-Plus/"}],"author":"廖兴旺"},{"title":"Linu命令总结","slug":"Blog-Open-Source-Linux","date":"2023-05-12T09:20:00.000Z","updated":"2024-12-19T06:53:09.542Z","comments":true,"path":"2023/05/12/blog-open-source-linux/","link":"","permalink":"https://liaoxingwang.github.io/2023/05/12/blog-open-source-linux/","excerpt":"","text":"简易的命令行入门教程:Git 全局设置: git config --global user.name &quot;sky&quot; git config --global user.email &quot;807928930@qq.com&quot;创建 git 仓库: mkdir luyun cd luyun git init touch README.md git add README.md git commit -m &quot;first commit&quot; git remote add origin https://gitee.com/log6j/luyun.git git push -u origin &quot;master&quot;已有仓库? cd existing_git_repo git remote add origin https://gitee.com/log6j/luyun.git git push -u origin &quot;master&quot;Linux关机,重启# 关机 shutdown -h now # 重启 shutdown -r now 查看系统,CPU信息# 查看系统内核信息 uname -a # 查看系统内核版本 cat /proc/version # 查看当前用户环境变量 env cat /proc/cpuinfo # 查看有几个逻辑cpu, 包括cpu型号 cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c # 查看有几颗cpu,每颗分别是几核 cat /proc/cpuinfo | grep physical | uniq -c # 查看当前CPU运行在32bit还是64bit模式下, 如果是运行在32bit下也不代表CPU不支持64bit getconf LONG_BIT # 结果大于0, 说明支持64bit计算. lm指long mode, 支持lm则是64bit cat /proc/cpuinfo | grep flags | grep ' lm ' | wc -l 建立软连接ln -s /usr/local/jdk1.8/ jdk rpm相关# 查看是否通过rpm安装了该软件 rpm -qa | grep 软件名 sshkey# 创建sshkey ssh-keygen -t rsa -C your_email@example.com #id_rsa.pub 的内容拷贝到要控制的服务器的 home/username/.ssh/authorized_keys 中,如果没有则新建(.ssh权限为700, authorized_keys权限为600) 命令重命名# 在各个用户的.bash_profile中添加重命名配置 alias ll='ls -alF' 同步服务器时间sudo ntpdate -u ntp.api.bz 后台运行命令# 后台运行,并且有nohup.out输出 nohup xxx &amp; # 后台运行, 不输出任何日志 nohup xxx > /dev/null &amp; # 后台运行, 并将错误信息做标准输出到日志中 nohup xxx >out.log 2>&amp;1 &amp; 强制活动用户退出# 命令来完成强制活动用户退出.其中TTY表示终端名称 pkill -kill -t [TTY] 查看命令路径which &lt;命令> 查看进程所有打开最大fd数ulimit -n 配置dnsvim /etc/resolv.conf nslookup,查看域名路由表nslookup google.com last, 最近登录信息列表# 最近登录的5个账号 last -n 5 设置固定ip搜索公纵号：MarkerHub，关注回复[ vue ]获取前后端入门教程！ ifconfig em1 192.168.5.177 netmask 255.255.255.0 查看进程内加载的环境变量# 也可以去 cd /proc 目录下, 查看进程内存中加载的东西 ps eww -p XXXXX(进程号) 查看进程树找到服务器进程ps auwxf 查看进程启动路径cd /proc/xxx(进程号) ls -all # cwd对应的是启动路径 添加用户, 配置sudo权限# 新增用户 useradd 用户名 passwd 用户名 #增加sudo权限 vim /etc/sudoers # 修改文件里面的 # root ALL=(ALL) ALL # 用户名 ALL=(ALL) ALL 强制关闭进程名包含xxx的所有进程ps aux|grep xxx | grep -v grep | awk '{print $2}' | xargs kill -9 磁盘,文件,目录相关操作vim操作#normal模式下 g表示全局, x表示查找的内容, y表示替换后的内容 :%s/x/y/g #normal模式下 0 # 光标移到行首(数字0) $ # 光标移至行尾 shift + g # 跳到文件最后 gg # 跳到文件头 # 显示行号 :set nu # 去除行号 :set nonu # 检索 /xxx(检索内容) # 从头检索, 按n查找下一个 ?xxx(检索内容) # 从尾部检索 打开只读文件,修改后需要保存时(不用切换用户即可保存的方式)# 在normal模式下 :w !sudo tee % 查看磁盘, 文件目录基本信息# 查看磁盘挂载情况 mount # 查看磁盘分区信息 df # 查看目录及子目录大小 du -H -h # 查看当前目录下各个文件, 文件夹占了多少空间, 不会递归 du -sh * wc命令# 查看文件里有多少行 wc -l filename # 看文件里有多少个word wc -w filename # 文件里最长的那一行是多少个字 wc -L filename # 统计字节数 wc -c 常用压缩, 解压缩命令压缩命令tar czvf xxx.tar 压缩目录 zip -r xxx.zip 压缩目录 解压缩命令tar zxvf xxx.tar # 解压到指定文件夹 tar zxvf xxx.tar -C /xxx/yyy/ unzip xxx.zip 变更文件所属用户, 用户组chown eagleye.eagleye xxx.log cp, scp, mkdir#复制 cp xxx.log # 复制并强制覆盖同名文件 cp -f xxx.log # 复制文件夹 cp -r xxx(源文件夹) yyy(目标文件夹) # 远程复制 scp -P ssh端口 username@10.10.10.101:/home/username/xxx /home/xxx # 级联创建目录 mkdir -p /xxx/yyy/zzz # 批量创建文件夹, 会在test,main下都创建java, resources文件夹 mkdir -p src/{test,main}/{java,resources} 比较两个文件diff -u 1.txt 2.txt 日志输出的字节数,可以用作性能测试# 如果做性能测试, 可以每执行一次, 往日志里面输出 “.” , 这样日志中的字节数就是实际的性能测试运行的次数, 还可以看见实时速率. tail -f xxx.log | pv -bt 查看, 去除特殊字符# 查看特殊字符 cat -v xxx.sh # 去除特殊字符 sed -i 's/^M//g’ env.sh 去除文件的特殊字符, 比如^M: 需要这样输入: ctrl+v+enter 处理因系统原因引起的文件中特殊字符的问题# 可以转换为该系统下的文件格式 cat file.sh > file.sh_bak # 先将file.sh中文件内容复制下来然后运行, 然后粘贴内容, 最后ctrl + d 保存退出 cat > file1.sh # 在vim中通过如下设置文件编码和文件格式 :set fileencodings=utf-8 ，然后 w （存盘）一下即可转化为 utf8 格式， :set fileformat=unix # 在mac下使用dos2unix进行文件格式化 find . -name \"*.sh\" | xargs dos2unix tee, 重定向的同时输出到屏幕awk ‘{print $0}’ xxx.log | tee test.log 检索相关grep# 反向匹配, 查找不包含xxx的内容 grep -v xxx # 排除所有空行 grep -v '^$' # 返回结果 2,则说明第二行是空行 grep -n “^$” 111.txt # 查询以abc开头的行 grep -n “^abc” 111.txt # 同时列出该词语出现在文章的第几行 grep 'xxx' -n xxx.log # 计算一下该字串出现的次数 grep 'xxx' -c xxx.log # 比对的时候，不计较大小写的不同 grep 'xxx' -i xxx.log awk# 以':' 为分隔符,如果第五域有user则输出该行 awk -F ':' '{if ($5 ~ /user/) print $0}' /etc/passwd # 统计单个文件中某个字符（串）(中文无效)出现的次数 awk -v RS='character' 'END {print --NR}' xxx.txt find检索命令# 在目录下找后缀是.mysql的文件 find /home/eagleye -name '*.mysql' -print # 会从 /usr 目录开始往下找，找最近3天之内存取过的文件。 find /usr -atime 3 –print # 会从 /usr 目录开始往下找，找最近5天之内修改过的文件。 find /usr -ctime 5 –print # 会从 /doc 目录开始往下找，找jacky 的、文件名开头是 j的文件。 find /doc -user jacky -name 'j*' –print # 会从 /doc 目录开始往下找，找寻文件名是 ja 开头或者 ma开头的文件。 find /doc \\( -name 'ja*' -o- -name 'ma*' \\) –print # 会从 /doc 目录开始往下找，找到凡是文件名结尾为 bak的文件，把它删除掉。-exec 选项是执行的意思，rm 是删除命令，{ } 表示文件名，“\\;”是规定的命令结尾。 find /doc -name '*bak' -exec rm {} \\; 网络相关查看什么进程使用了该端口lsof -i:port 获取本机ip地址/sbin/ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk '{print $2}'|tr -d \"addr:\" iptables# 查看iptables状态 service iptables status # 要封停一个ip iptables -I INPUT -s ***.***.***.*** -j DROP # 要解封一个IP，使用下面这条命令： iptables -D INPUT -s ***.***.***.*** -j DROP 备注: 参数-I是表示Insert（添加），-D表示Delete（删除）。后面跟的是规则，INPUT表示入站，***.***.***.***表示要封停的IP，DROP表示放弃连接。 #开启9090端口的访问 /sbin/iptables -I INPUT -p tcp --dport 9090 -j ACCEPT # 防火墙开启、关闭、重启 /etc/init.d/iptables status /etc/init.d/iptables start /etc/init.d/iptables stop /etc/init.d/iptables restart nc命令, tcp调试利器#给某一个endpoint发送TCP请求,就将data的内容发送到对端 nc 192.168.0.11 8000 &lt; data.txt #nc可以当做服务器，监听某个端口号,把某一次请求的内容存储到received_data里 nc -l 8000 > received_data #上边只监听一次，如果多次可以加上-k参数 nc -lk 8000 tcpdump# dump出本机12301端口的tcp包 tcpdump -i em1 tcp port 12301 -s 1500 -w abc.pcap 跟踪网络路由路径# traceroute默认使用udp方式, 如果是-I则改成icmp方式 traceroute -I www.163.com # 从ttl第3跳跟踪 traceroute -M 3 www.163.com # 加上端口跟踪 traceroute -p 8080 192.168.10.11 ss# 显示本地打开的所有端口 ss -l # 显示每个进程具体打开的socket ss -pl # 显示所有tcp socket ss -t -a # 显示所有的UDP Socekt ss -u -a # 显示所有已建立的SMTP连接 ss -o state established '( dport = :smtp or sport = :smtp )' # 显示所有已建立的HTTP连接 ss -o state established '( dport = :http or sport = :http )' 找出所有连接X服务器的进程 ss -x src /tmp/.X11-unix/* 列出当前socket统计信息 ss -s 解释：netstat是遍历/proc下面每个PID目录，ss直接读/proc/net下面的统计信息。所以ss执行的时候消耗资源以及消耗的时间都比netstat少很多 netstat# 输出每个ip的连接数，以及总的各个状态的连接数 netstat -n | awk '/^tcp/ {n=split($(NF-1),array,\":\");if(n&lt;=2)++S[array[(1)]];else++S[array[(4)]];++s[$NF];++N} END {for(a in S){printf(\"%-20s %s\\n\", a, S[a]);++I}printf(\"%-20s %s\\n\",\"TOTAL_IP\",I);for(a in s) printf(\"%-20s %s\\n\",a, s[a]);printf(\"%-20s %s\\n\",\"TOTAL_LINK\",N);}' # 统计所有连接状态, # CLOSED：无连接是活动的或正在进行 # LISTEN：服务器在等待进入呼叫 # SYN_RECV：一个连接请求已经到达，等待确认 # SYN_SENT：应用已经开始，打开一个连接 # ESTABLISHED：正常数据传输状态 # FIN_WAIT1：应用说它已经完成 # FIN_WAIT2：另一边已同意释放 # ITMED_WAIT：等待所有分组死掉 # CLOSING：两边同时尝试关闭 # TIME_WAIT：主动关闭连接一端还没有等到另一端反馈期间的状态 # LAST_ACK：等待所有分组死掉 netstat -n | awk '/^tcp/ {++state[$NF]} END {for(key in state) print key,\"\\t\",state[key]}' # 查找较多time_wait连接 netstat -n|grep TIME_WAIT|awk '{print $5}'|sort|uniq -c|sort -rn|head -n20 监控linux性能命令top按大写的 F 或 O 键，然后按 a-z 可以将进程按照相应的列进行排序, 然后回车。而大写的 R 键可以将当前的排序倒转 列名 含义 PID 进程id PPID 父进程id RUSER Real user name UID 进程所有者的用户id USER 进程所有者的用户名 GROUP 进程所有者的组名 TTY 启动进程的终端名。不是从终端启动的进程则显示为 ? PR 优先级 NI nice值。负值表示高优先级，正值表示低优先级 P 最后使用的CPU，仅在多CPU环境下有意义 %CPU 上次更新到现在的CPU时间占用百分比 TIME 进程使用的CPU时间总计，单位秒 TIME+ 进程使用的CPU时间总计，单位1/100秒 %MEM 进程使用的物理内存百分比 VIRT 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES SWAP 进程使用的虚拟内存中，被换出的大小，单位kb。 RES 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA CODE 可执行代码占用的物理内存大小，单位kb DATA 可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb SHR 共享内存大小，单位kb nFLT 页面错误次数 nDRT 最后一次写入到现在，被修改过的页面数。 S 进程状态。D=不可中断的睡眠状态,R=运行,S=睡眠,T=跟踪/停止,Z=僵尸进程 COMMAND 命令名/命令行 WCHAN 若该进程在睡眠，则显示睡眠中的系统函数名 Flags 任务标志，参考 sched.h dmesg,查看系统日志dmesg iostat,磁盘IO情况监控iostat -xz 1 # r/s, w/s, rkB/s, wkB/s：分别表示每秒读写次数和每秒读写数据量（千字节）。读写量过大，可能会引起性能问题。 # await：IO操作的平均等待时间，单位是毫秒。这是应用程序在和磁盘交互时，需要消耗的时间，包括IO等待和实际操作的耗时。如果这个数值过大，可能是硬件设备遇到了瓶颈或者出现故障。 # avgqu-sz：向设备发出的请求平均数量。如果这个数值大于1，可能是硬件设备已经饱和（部分前端硬件设备支持并行写入）。 # %util：设备利用率。这个数值表示设备的繁忙程度，经验值是如果超过60，可能会影响IO性能（可以参照IO操作平均等待时间）。如果到达100%，说明硬件设备已经饱和。 # 如果显示的是逻辑设备的数据，那么设备利用率不代表后端实际的硬件设备已经饱和。值得注意的是，即使IO性能不理想，也不一定意味这应用程序性能会不好，可以利用诸如预读取、写缓存等策略提升应用性能。 free,内存使用情况free -m eg: total used free shared buffers cached Mem: 1002 769 232 0 62 421 -/+ buffers/cache: 286 715 Swap: 1153 0 1153 第一部分Mem行: total 内存总数: 1002M used 已经使用的内存数: 769M free 空闲的内存数: 232M shared 当前已经废弃不用,总是0 buffers Buffer 缓存内存数: 62M cached Page 缓存内存数:421M 关系：total(1002M) = used(769M) + free(232M) 第二部分(-/+ buffers/cache): (-buffers/cache) used内存数：286M (指的第一部分Mem行中的used – buffers – cached) (+buffers/cache) free内存数: 715M (指的第一部分Mem行中的free + buffers + cached) 可见-buffers/cache反映的是被程序实实在在吃掉的内存,而+buffers/cache反映的是可以挪用的内存总数. 第三部分是指交换分区 sar,查看网络吞吐状态# sar命令在这里可以查看网络设备的吞吐率。在排查性能问题时，可以通过网络设备的吞吐量，判断网络设备是否已经饱和 sar -n DEV 1 # # sar命令在这里用于查看TCP连接状态，其中包括： # active/s：每秒本地发起的TCP连接数，既通过connect调用创建的TCP连接； # passive/s：每秒远程发起的TCP连接数，即通过accept调用创建的TCP连接； # retrans/s：每秒TCP重传数量； # TCP连接数可以用来判断性能问题是否由于建立了过多的连接，进一步可以判断是主动发起的连接，还是被动接受的连接。TCP重传可能是因为网络环境恶劣，或者服务器压力过大导致丢包 sar -n TCP,ETCP 1 vmstat, 给定时间监控CPU使用率, 内存使用, 虚拟内存交互, IO读写# 2表示每2秒采集一次状态信息, 1表示只采集一次(忽略既是一直采集) vmstat 2 1 eg: r b swpd free buff cache si so bi bo in cs us sy id wa 1 0 0 3499840 315836 3819660 0 0 0 1 2 0 0 0 100 0 0 0 0 3499584 315836 3819660 0 0 0 0 88 158 0 0 100 0 0 0 0 3499708 315836 3819660 0 0 0 2 86 162 0 0 100 0 0 0 0 3499708 315836 3819660 0 0 0 10 81 151 0 0 100 0 1 0 0 3499732 315836 3819660 0 0 0 2 83 154 0 0 100 0 r 表示运行队列(就是说多少个进程真的分配到CPU)，我测试的服务器目前CPU比较空闲，没什么程序在跑，当这个值超过了CPU数目，就会出现CPU瓶颈了。这个也和top的负载有关系，一般负载超过了3就比较高，超过了5就高，超过了10就不正常了，服务器的状态很危险。top的负载类似每秒的运行队列。如果运行队列过大，表示你的CPU很繁忙，一般会造成CPU使用率很高。 b 表示阻塞的进程,这个不多说，进程阻塞，大家懂的。 swpd 虚拟内存已使用的大小，如果大于0，表示你的机器物理内存不足了，如果不是程序内存泄露的原因，那么你该升级内存了或者把耗内存的任务迁移到其他机器。 free 空闲的物理内存的大小，我的机器内存总共8G，剩余3415M。 buff Linux/Unix系统是用来存储，目录里面有什么内容，权限等的缓存，我本机大概占用300多M cache cache直接用来记忆我们打开的文件,给文件做缓冲，我本机大概占用300多M(这里是Linux/Unix的聪明之处，把空闲的物理内存的一部分拿来做文件和目录的缓存，是为了提高 程序执行的性能，当程序使用内存时，buffer/cached会很快地被使用。) si 每秒从磁盘读入虚拟内存的大小，如果这个值大于0，表示物理内存不够用或者内存泄露了，要查找耗内存进程解决掉。我的机器内存充裕，一切正常。 so 每秒虚拟内存写入磁盘的大小，如果这个值大于0，同上。 bi 块设备每秒接收的块数量，这里的块设备是指系统上所有的磁盘和其他块设备，默认块大小是1024byte，我本机上没什么IO操作，所以一直是0，但是我曾在处理拷贝大量数据(2-3T)的机器上看过可以达到140000/s，磁盘写入速度差不多140M每秒 bo 块设备每秒发送的块数量，例如我们读取文件，bo就要大于0。bi和bo一般都要接近0，不然就是IO过于频繁，需要调整。 in 每秒CPU的中断次数，包括时间中断 cs 每秒上下文切换次数，例如我们调用系统函数，就要进行上下文切换，线程的切换，也要进程上下文切换，这个值要越小越好，太大了，要考虑调低线程或者进程的数目,例如在apache和nginx这种web服务器中，我们一般做性能测试时会进行几千并发甚至几万并发的测试，选择web服务器的进程可以由进程或者线程的峰值一直下调，压测，直到cs到一个比较小的值，这个进程和线程数就是比较合适的值了。系统调用也是，每次调用系统函数，我们的代码就会进入内核空间，导致上下文切换，这个是很耗资源，也要尽量避免频繁调用系统函数。上下文切换次数过多表示你的CPU大部分浪费在上下文切换，导致CPU干正经事的时间少了，CPU没有充分利用，是不可取的。 us 用户CPU时间，我曾经在一个做加密解密很频繁的服务器上，可以看到us接近100,r运行队列达到80(机器在做压力测试，性能表现不佳)。 sy 系统CPU时间，如果太高，表示系统调用时间长，例如是IO操作频繁。 id 空闲 CPU时间，一般来说，id + us + sy = 100,一般我认为id是空闲CPU使用率，us是用户CPU使用率，sy是系统CPU使用率。 wt 等待IO CPU时间。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://liaoxingwang.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://liaoxingwang.github.io/tags/Linux/"}],"author":"廖兴旺"},{"title":"微信小程序","slug":"Blog-Open-Source-Wechat mini program","date":"2023-05-12T09:20:00.000Z","updated":"2024-12-19T06:53:09.546Z","comments":true,"path":"2023/05/12/blog-open-source-wechat-mini-program/","link":"","permalink":"https://liaoxingwang.github.io/2023/05/12/blog-open-source-wechat-mini-program/","excerpt":"","text":"微信小程序篇 打开微信小程序导入一个项目时，控制台弹出下面的错误： HBuilder X—运行—运行到小程序模拟器 微信开发者工具 编译后生成 一，注册微信小程序1.打开 微信公众平台 2.注册开发者账号 可以选择注册服务号/小程序号，如果有公司资质可选择注册服务号，在服务号里快速复用公司资质直接注册小程序号，一个服务号可以关联注册10个同主体或关联主体的小程序,3个非同主体小程序。 服务号：企业资质，在服务号里可直接快速注册多个小程序号 小程序：企业资质、个人资质··· 注册需要用到的资料 个人注册：身份证姓名、身份证号码、管理员手机、短信验证、管理员身份验证等等 企业注册：企业类型、营业执照注册号、管理员身份证姓名、管理员身份证号码、管理员手机号码、短信验证等 ​ 小程序注册 3.微信公众平台注册完成后，既可登录微信公众平台，填写小程序信息、小程序类目，填写完整既可在设置中找到小程序AppId以及配置小程序秘钥。 在里面版本管理、成员管理、添加开发域名、管理插件、查看核心数据等， 二，微信开发者工具下载微信web开发者工具，根据自己的操作系统下载对应的安装包进行安装即可。 2.1.创建工程 登录微信公众平台，填写好小程序信息后，去设置里面找到账号信息，找到小程序AppID 打开微信开发者工具，点击加号创建工程 填写好AppID等信息，选择工程模板，确定 进入工程 2.2.界面介绍 微信开发工具界面 项目工程目录 2.3 全局配置 小程序配置项 微信开发文档 小程序根目录下的 app.json 文件用来对微信小程序进行全局配置。文件内容为一个 JSON 对象 配置项 属性 类型 必填 描述 最低版本 entryPagePath string 否 小程序默认启动首页 pages string[] 是 页面路径列表 window Object 否 全局的默认窗口表现 tabBar Object 否 底部 tab 栏的表现 networkTimeout Object 否 网络超时时间 debug boolean 否 是否开启 debug 模式，默认关闭 functionalPages boolean 否 是否启用插件功能页，默认关闭 2.1.0 subpackages Object[] 否 分包结构配置 1.7.3 workers string 否 Worker 代码放置的目录 1.9.90 requiredBackgroundModes string[] 否 需要在后台使用的能力，如「音乐播放」 plugins Object 否 使用到的插件 1.9.6 preloadRule Object 否 分包预下载规则 2.3.0 resizable boolean 否 PC 小程序是否支持用户任意改变窗口大小（包括最大化窗口）；iPad 小程序是否支持屏幕旋转。默认关闭 2.3.0 usingComponents Object 否 全局自定义组件配置 开发者工具 1.02.1810190 permission Object 否 小程序接口权限相关设置 微信客户端 7.0.0 sitemapLocation string 是 指明 sitemap.json 的位置 style string 否 指定使用升级后的weui样式 2.8.0 useExtendedLib Object 否 指定需要引用的扩展库 2.2.1 entranceDeclare Object 否 微信消息用小程序打开 微信客户端7.0.9 darkmode boolean 否 小程序支持 DarkMode 2.11.0 themeLocation string 否 指明 theme.json 的位置，darkmode为true为必填 开发者工具 1.03.2004271 lazyCodeLoading string 否 配置自定义组件代码按需注入 2.11.1 singlePage Object 否 单页模式相关配置 2.12.0 pages配置 用于指定小程序由哪些页面组成，每一项都对应一个页面的 路径（含文件名） 信息。文件名不需要写文件后缀，框架会自动去寻找对应位置的 .json, .js, .wxml, .wxss 四个文件进行处理。 \"pages\": [ \"pages/index/index\", \"pages/next-bus/next-bus\", \"pages/park-map/park-map\", \"pages/park/park\", \"pages/route-info/route-info\", \"pages/glory-futian/glory-futian\", \"pages/glory-futian/details/vehicle-road/vehicle-road\", \"pages/glory-futian/details/station/station\", \"pages/glory-futian/details/smart-road/smart-road\", \"pages/glory-futian/details/slow/slow\", \"pages/bind-car/bind-car\", \"pages/offiaccount-login/offiaccount-login\", \"pages/construction/construction\" ], window配置 用于设置小程序的状态栏、导航条、标题、窗口背景色等。 属性 类型 默认值 描述 navigationBarBackgroundColor HexColor #000000 导航栏背景颜色，如 #000000 navigationBarTextStyle string white 导航栏标题颜色，仅支持 black / white navigationBarTitleText string 导航栏标题文字内容 navigationStyle string default 导航栏样式，仅支持以下值：default 默认样式custom 自定义导航栏，只保留右上角胶囊按钮。参见注 2。 homeButton boolean default 在非首页、非页面栈最底层页面或非 tabbar 内页面中的导航栏展示 home 键 backgroundColor HexColor #ffffff 窗口的背景色 backgroundTextStyle string dark 下拉 loading 的样式，仅支持 dark / light backgroundColorTop string #ffffff 顶部窗口的背景色，仅 iOS 支持 backgroundColorBottom string #ffffff 底部窗口的背景色，仅 iOS 支持 enablePullDownRefresh boolean false 是否开启全局的下拉刷新。 onReachBottomDistance number 50 页面上拉触底事件触发时距页面底部距离，单位为 px。 pageOrientation string portrait 屏幕旋转设置，支持 auto / portrait / landscape restartStrategy string homePage 重新启动策略配置 initialRenderingCache string 页面初始渲染缓存配置，支持 static / dynamic visualEffectInBackground string none 切入系统后台时，隐藏页面内容，保护用户隐私。支持 hidden / none handleWebviewPreload string static 控制预加载下个页面的时机 支持 static / manual / auto tabBar配置 客户端窗口的底部或顶部有 tab 栏可以切换页面，可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。 属性 类型 必填 默认值 描述 color HexColor 是 tab 上的文字默认颜色，仅支持十六进制颜色 selectedColor HexColor 是 tab 上的文字选中时的颜色，仅支持十六进制颜色 backgroundColor HexColor 是 tab 的背景色，仅支持十六进制颜色 borderStyle string 否 black tabbar 上边框的颜色， 仅支持 black / white list Array 是 tab 的列表，详见 list 属性说明，最少 2 个、最多 5 个 tab position string 否 bottom tabBar 的位置，仅支持 bottom / top custom boolean 否 false 自定义 tabBar 其中 list 接受一个数组，只能配置最少 2 个、最多 5 个 tab。tab 按数组的顺序排序，每个项都是一个对象，其属性值如下： 属性 类型 必填 说明 pagePath string 是 页面路径，必须在 pages 中先定义 text string 是 tab 上按钮文字 iconPath string 否 图片路径，icon 大小限制为 40kb，建议尺寸为 81px * 81px，不支持网络图片。当 position 为 top 时，不显示 icon。 selectedIconPath string 否 选中时的图片路径，icon 大小限制为 40kb，建议尺寸为 81px * 81px，不支持网络图片。当 position 为 top 时，不显示 icon。 networkTimeout 网络请求超时配置 各类网络请求的超时时间，单位均为毫秒。 分包加载加载 某些情况下，开发者需要将小程序划分成不同的子包，在构建时打包成不同的分包，用户在使用时按需进行加载。 在构建小程序分包项目时，构建会输出一个或多个分包。每个使用分包小程序必定含有一个主包。所谓的主包，即放置默认启动页面/TabBar 页面，以及一些所有分包都需用到公共资源/JS 脚本；而分包则是根据开发者的配置进行划分。 在小程序启动时，默认会下载主包并启动主包内页面，当用户进入分包内某个页面时，客户端会把对应分包下载下来，下载完成后再进行展示。 目前小程序分包大小有以下限制： 整个小程序所有分包大小不超过 20M 单个分包/主包大小不能超过 2M 2.4 小程序页面配置页面配置地址 小程序中，可以在页面对应的 .json 文件来对本页面的表现进行配置。如：导航栏样式、自定义组件注入等。 注意：app.json 中的部分配置，可以再页面对应的.json进行重新配置，页面中配置项在当前页面会覆盖 app.json 中相同的配置项。 配置项 属性 类型 默认值 描述 navigationBarBackgroundColor HexColor #000000 导航栏背景颜色，如 #000000 navigationBarTextStyle string white 导航栏标题颜色，仅支持 black / white navigationBarTitleText string 导航栏标题文字内容 navigationStyle string default 导航栏样式，仅支持以下值：default 默认样式custom 自定义导航栏，只保留右上角胶囊按钮。 homeButton boolean false 在非首页、非页面栈最底层页面或非 tabbar 内页面中的导航栏展示 home 键 backgroundColor HexColor #ffffff 窗口的背景色 backgroundTextStyle string dark 下拉 loading 的样式，仅支持 dark / light backgroundColorTop string #ffffff 顶部窗口的背景色，仅 iOS 支持 backgroundColorBottom string #ffffff 底部窗口的背景色，仅 iOS 支持 enablePullDownRefresh boolean false 是否开启当前页面下拉刷新 onReachBottomDistance number 50 页面上拉触底事件触发时距页面底部距离，单位为px pageOrientation string portrait 屏幕旋转设置，支持 auto / portrait / landscape disableScroll boolean false 设置为 true 则页面整体不能上下滚动。只在页面配置中有效，无法在 app.json 中设置 usingComponents Object 否 页面自定义组件配置 initialRenderingCache string 页面初始渲染缓存配置，支持 static / dynamic style string default 启用新版的组件样式 singlePage Object 否 单页模式相关配置 restartStrategy string homePage 重新启动策略配置 handleWebviewPreload string static 控制预加载下个页面的时机。支持 static / manual / auto visualEffectInBackground string 否 切入系统后台时，隐藏页面内容，保护用户隐私。支持 hidden / none，若对页面单独设置则会覆盖全局的配置 enablePassiveEvent Object或boolean 否 事件监听是否为 passive，若对页面单独设置则会覆盖全局的配置 renderer string 否 渲染后端 三、小程序语法网页编程采用的是 HTML + CSS + JS 这样的组合，小程序也是如此 WXML + WXSS+ JS 。 3.1.wxml和html没什么区别，只是标签名称不同。 多了一些表达式 &lt;!-- 渲染 --> &lt;text>{{parkType}}&lt;/text> &lt;image data-text=\"{{index}}\" bindtap=\"clickParkMap\" class=\"item-poi\" src=\"{{img_server_url}}/pos_icon.png\">&lt;/image> &lt;view style=\"height:50rpx;\">{{msg.length}}&lt;/view> &lt;!-- 条件渲染 --> &lt;block wx:if=\"{{selRegionIndex==1}}\"> &lt;view class=\"select_result0\">数据加载中···请稍后!&lt;/view> &lt;/block> &lt;block wx:elif=\"{{selRegionIndex==2}}\"> &lt;view class=\"select_result0\">数据加载中···请稍后!&lt;/view> &lt;/block> &lt;block wx:else> &lt;view class=\"select_result0\">数据加载中···请稍后!&lt;/view> &lt;/block> &lt;!-- 列表渲染 --> &lt;view class=\"item\" wx:for=\"{{selSort}}\" wx:key=\"index\" wx:for-index=\"index\" wx:for-item=\"item\" data-text=\"{{index}}\" bindtap='selSort'> &lt;text class=\"{{selSortIndex==index?'sel_text':''}}\">{{item.name}}&lt;/text> &lt;image wx:if=\"{{selSortIndex==index}}\" src=\"{{img_server_url}}/radio_icon_sel.png\">&lt;/image> &lt;/view> &lt;!-- 引入过滤器 --> &lt;wxs module=\"filters\" src=\"../../utils/filter.wxs\">&lt;/wxs> &lt;!-- 使用过滤器 --> &lt;checkbox class=\"radio\" color=\"#fff\" wx:key=\"*this\" wx:for=\"{{fieldsInfo.live_reason}}\" wx:for-item=\"item\" value=\"{{item}}\" checked=\"{{ filters.setChecked(allData.live_reason,item) }}\" > &lt;text>{{item}}&lt;/text> &lt;/checkbox> &lt;!-- 使用自定义组件 --> &lt;nav-bar header='{{nvabarData}}'>&lt;/nav-bar> &lt;view>{{\"hello\" + name}}&lt;/view> &lt;template is=\"objectCombine\" data=\"{{...obj1, ...obj2, a, c: 6}}\">&lt;/template> &lt;template is=\"objectCombine\" data=\"{{...obj1, ...obj2, e: 5}}\">&lt;/template> wxml模板使用 定义item.wxml &lt;template name=\"item\"> &lt;text>{{text}}&lt;/text> &lt;/template> 使用模板 &lt;!-- 引入 --> &lt;import src=\"item.wxml\"/> &lt;!-- 使用 --> &lt;template is=\"item\" data=\"{{text: 'forbar'}}\"/> include 可以将目标文件除了 外的整个代码引入，相当于是拷贝到 include 位置， &lt;!-- header.wxml --> &lt;view> header &lt;/view> &lt;!-- footer.wxml --> &lt;view> footer &lt;/view> &lt;!-- index.wxml --> &lt;include src=\"header.wxml\"/> &lt;view> body &lt;/view> &lt;include src=\"footer.wxml\"/> = &lt;view> header &lt;/view> &lt;view> body &lt;/view> &lt;view> footer &lt;/view> 注意事项 当 wx:for 的值为字符串时，会将字符串解析成字符串数组 &lt;view wx:for=\"array\"> {{item}} &lt;/view> = &lt;view wx:for=\"{{['a','r','r','a','y']}}\"> {{item}} &lt;/view> 当花括号和引号之间如果有空格，将最终被解析成为字符串 &lt;view wx:for=\"{{[1,2,3]}} \"> {{item}} &lt;/view> = &lt;view wx:for=\"{{[1,2,3] + ' '}}\" > {{item}} &lt;/view> 3.2.wxssWXSS 具有 CSS 大部分的特性，小程序在 WXSS 也做了一些扩充和修改。 新增了单位尺寸：rpx .body{ width:100%; height:100%; background:rgba(243,247,249,1); overflow: hidden; display: flex; flex-direction: column; } .top-panel{ height:160rpx; padding:20rpx; border-radius:4px; position: relative; } /* 选项面板 */ .top-panel .sel-panel{ height:calc( 100% - 40rpx ); position: relative; padding:20rpx; background:rgba(255,255,255,1); } /* 输入 */ .top-panel .sel-panel .input-c{ height:65rpx; display: flex; flex-direction: row; align-items: center; } 3.3.wxs小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。包含 wxs模块、变量、注释、运算符、语句、数据类型、基础类库 wxs文件定义 // /pages/tools.wxs 定义 var foo = \"'hello world' from tools.wxs\"; var bar = function (d) { return d; } module.exports = { FOO: foo, bar: bar, }; module.exports.msg = \"some msg\"; wxs标签使用 // 使用 &lt;wxs src=\"./../tools.wxs\" module=\"tools\" /> &lt;view> {{tools.msg}} &lt;/view> &lt;view> {{tools.bar(tools.FOO)}} &lt;/view> 示例： var filters = { // 设置复选框选中 setChecked: function (selArr,fields) { if (selArr == null || selArr == undefined || selArr == '') { return false; } if (selArr.indexOf(fields) != -1) { return true; } return false; }, strToArr: function (strArr, index) { return strArr.split('，')[index]; } } module.exports = { setChecked: filters.setChecked, strToArr: filters.strToArr } &lt;!-- 引入过滤器 --> &lt;wxs module=\"filters\" src=\"../../utils/filter.wxs\">&lt;/wxs> &lt;view class=\"field-item\"> &lt;checkbox-group class=\"radio-group-col\" bindchange=\"radioChange\" data-field=\"live_reason\"> &lt;checkbox wx:key=\"*this\" wx:for=\"{{fieldsInfo.live_reason}}\" wx:for-item=\"item\" value=\"{{item}}\" checked=\"{{ filters.setChecked(allData.live_reason,item) }}\" > &lt;text>{{item}}&lt;/text> &lt;/checkbox> &lt;/checkbox-group> &lt;/view> 3.4. js 3.4.1 App.js 使用App()注册小程序。接受一个 Object 参数，其指定小程序的生命周期回调、定义全局变量等。 全局变量如何使用后面会说。 //app.js App({ // 小程序初始化完成时触发，全局只触发一次 onLaunch: function () { //获取手机导航栏高度 wx.getSystemInfo({ success: res => { var isIos = res.system.indexOf('iOS') > -1; this.globalData.statusHeight = res.statusBarHeight; this.globalData.navHeight = isIos ? 44 : 48; this.globalData.fontSize = res.fontSizeSetting; //设置低版本不显示自定义导航栏 if (res.SDKVersion &amp;&amp; res.SDKVersion.split('.')[0] * 1 &lt;= 2 &amp;&amp; res.SDKVersion.split('.')[1] * 1 &lt; 5){ this.globalData.navHeightHidden=true; } }, fail(err) { console.log(err); } }) // 位置授权 wx.getSetting({ success(res) { if (!res.authSetting['scope.userLocation']) { wx.authorize({ scope: 'scope.userLocation', success() {} }) } } }) }, // 监听小程序启动或切前台 onShow (options) { // Do something when show. }, // 监听小程序切后台 onHide () { // Do something when hide. }, // 错误监听函数。 onError (msg) { console.log(msg) }, // 页面不存在监听函数 onPageNotFound(){ // 小程序要打开的页面不存在时触发 }, // 未处理的 Promise 拒绝事件监听函数。 onUnhandledRejection(){ // 小程序有未处理的 Promise 拒绝时触发。 }, // 监听系统主题变化 onThemeChange(){ // 系统切换主题时触发。也可以使用 wx.onThemeChange 绑定监听 }, globalData: { //标题 header:'交通行为与意愿调查系统', //自定义导航组件高度 navHeightHidden:false, statusHeight:null, navHeight:null, fontSize:null, /**发布版-请求数据地址 */ request_server_url: 'https://l***', /**开发版-请求数据地址本地 */ // request_server_url: 'http:/***', /**发布版-图片地址 */ img_server_url: 'https://***', /**开发版-图片地址 */ // img_server_url: '../../images', //地图相关 selMap:null, mapKey: 'YPNBZ-PMSCX-G664V-7XBWG-SYFB6-KRBUO', referer: '深研居民调查', category: '生活服务,娱乐休闲', //用户信息 openid:null, userInfo:null, surveyJob:false, //版本号 version: 'v1.4.7', } }) 3.4.2 页面page.js 使用Page() 注册小程序中的一个页面。接受一个 Object 类型参数，其指定页面的初始数据、生命周期回调、事件处理函数等。 // pages/ceshi/ceshi.js // 引入公用函数 const Common = require(\"../../utils/common.js\"); //获取应用实例 const app = getApp(); Page({ /** * 页面的初始数据 */ data: { // 图片链接 img_server_url: app.globalData.img_server_url, }, /** * 生命周期函数--监听页面加载 */ onLoad(options) { }, /** * 生命周期函数--监听页面初次渲染完成 */ onReady() { }, /** * 生命周期函数--监听页面显示 */ onShow() { }, /** * 生命周期函数--监听页面隐藏 */ onHide() { }, /** * 生命周期函数--监听页面卸载 */ onUnload() { }, /** * 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh() { }, /** * 页面上拉触底事件的处理函数 */ onReachBottom() { }, /** * 用户点击右上角分享 */ onShareAppMessage() { } }) 3.4.3 数据绑定使用 &lt;!-- index.wxml--> &lt;text wx:if=\"{{text}}\">{{text}}&lt;/text> &lt;input model:value=\"{{text}}\" /> &lt;view wx:for=\"{{persons}}\" wx:key=\"*this\" wx:for-index=\"index\" wx:for-item=\"item\"> &lt;view class=\"item-person\" data-value=\"{{item.value}}\" bindtap=\"setCheck\"> &lt;text>{{item.name}}&lt;/text> &lt;text>{{item.value}}&lt;/text> &lt;/view> &lt;/view> // index.js // 获取应用实例 const app = getApp() Page({ data: { text:null, active:1, list:[ { name:'',value:'' }, { name:'',value:'' }, { name:'',value:'' }, ] }, onShow: function () { this.setData({ text:11 }) }, // 事件处理函数 setCheck(e) { var value = e.currentTarget.dataset.value; this.setData({ active:value, text:'1111' }) } }) 3.4.4 事件介绍 事件列表 点击事件（单击）：tap 长按事件：longpress、longtap 键盘输入事件：input 回车事件：confirm 输入框聚焦：focus 输入框失焦：blur value改变事件：change 触摸动作开始：touchstart 触摸动作结束：touchend 触摸过程移动：touchmove 触摸动作被打断：touchcancel 提交表单事件：submit 重置表单事件：reset 事件对象属性列表 BaseEvent基础事件对象属性列表 属性 类型 说明 type String 事件类型 timeStamp Integer 事件生成时的时间戳 target Object 触发事件的源组件的一些属性值集合 currentTarget Object 当前组件的一些属性值集合 CustomEvent 自定义事件对象属性列表（继承 BaseEvent） 属性 类型 说明 detail Object 额外的信息 TouchEvent 触摸事件对象属性列表（继承 BaseEvent） 属性 类型 说明 touches Array 触摸事件，当前停留在屏幕中的触摸点信息的数组 changedTouches Array 触摸事件，当前变化的触摸点信息的数组 事件对象属性说明 type 通用事件类型 timeStamp 该页面打开到触发事件所经过的毫秒数。 target 触发事件的源组件 属性 类型 说明 id String 事件源组件的id tagName String 当前组件的类型 dataset Object 事件源组件上由data-开头的自定义属性组成的集合 currentTarget 事件绑定的当前组件 属性 类型 说明 id String 当前组件的id tagName String 当前组件的类型 dataset Object 当前组件上由data-开头的自定义属性组成的集合 dataset 在组件中可以定义数据，这些数据将会通过事件传递给 SERVICE。书写方式：以data-开头，多个单词由连字符-链接，不能有大写(大写会自动转成小写) 如data-element-type，最终在 event.target.dataset 中会将连字符转成驼峰 elementType。 如data-elementType，最终在 e.currentTarget.dataset.elementtype 大写会自动转成小写elementtype。 事件绑定 事件绑定的写法同组件的属性，以key、value的形式 key以bind或catch开头，然后跟上事件的类型，如bindtap, catchtouchstart value是一个字符串，需要在对应的Page中定义同名的函数。不然当触发事件的时候会报错 &lt;view bindtap=\"bindViewTap\" data-field=\"name\" data-text=\"aa\">&lt;/view> &lt;view bind:tap=\"bindViewTap\" data-field=\"name\" data-text=\"aa\">&lt;/view> &lt;view catch:tap=\"bindViewTap\" data-field=\"name\" data-text=\"aa\">&lt;/view> &lt;view catchtap=\"bindViewTap\" data-field=\"name\" data-text=\"aa\">&lt;/view> bind与catch的区别 bind事件绑定不会阻止冒泡事件往上冒泡，简单来说，bind所绑定的事件对应会向上传递，让自己的父组件响应对应的事件。 catch事件会把对应的事件阻拦在自己这里，只有自己能够响应对应事件。 事件的使用 &lt;!--index.wxml--> &lt;view bindtap=\"bindViewTap\" data-field=\"name\" data-text=\"aa\">&lt;/view> // index.js Page({ // 事件处理函数 bindViewTap(e) { var field= e.currentTarget.dataset.field; var aa= e.currentTarget.dataset.text; }, }) 事件参数 使用：dataset 注意：事件携带参数 dataset使用的时候 ，数据名尽量用小写，不要使用驼峰 &lt;!--index.wxml--> &lt;view bindtap=\"bindViewTap\" data-element-type=\"name\" data-elementType=\"aa\">&lt;/view> // index.js Page({ // 事件处理函数 bindViewTap(e) { // 获取时候 data-element-type = e.currentTarget.dataset.elementType // 获取时候 data-elementType= e.currentTarget.dataset.elementtype }, }) 使用wxs响应事件 支持使用 WXS 函数绑定事件，WXS函数接受2个参数： event，在原有的 event 的基础上加了event.instance对象， ownerInstance，和event.instance一样是一个ComponentDescriptor对象 在组件中绑定和注册事件处理的 WXS 函数 &lt;!-- text.wxml --> &lt;wxs module=\"test\" src=\"./test.wxs\">&lt;/wxs> &lt;!-- 绑定wxs中函数 --> &lt;view id=\"tapTest\" data-hi=\"Weixin\" bindtap=\"{{test.tapName}}\"> Click me! &lt;/view> &lt;!-- prop 属性改变的时候调用 propObserver --> &lt;view change:prop=\"{{test.propObserver}}\" prop=\"{{propValue}}\" class=\"movable\">&lt;/view> test.wxs文件实现 tapName 函数 // test.wxs module.exports = { tapName: function(event, ownerInstance) { var hi= e.currentTarget.dataset.hi; }, // 监听prop属性变化 propObserver: function(newValue, oldValue, ownerInstance, instance) { console.log('prop observer', newValue, oldValue) } } 3.4.5 App.js中全局变量使用 可在App.js中定义全局变量 定义 // app.js App({ onLaunch() { }, globalData: { userInfo: null, dataList:[] } }) 使用 //获取应用实例 const app = getApp(); Page({ /** * 页面的初始数据 */ data: { // 图片链接 img_server_url: app.globalData.img_server_url, }, /* 修改全局变量 */ updateRecord(data){ //保存全局数据 app.globalData.dataList= data; // 注意，修改后，此页面如果又用到了，重新获取app，不然值不会变。 var app = getApp(); }, 3.4.6 模块化 可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过module.exports或者 exports 才能对外暴露接口。 定义公用变量 base.js const accountInfo = wx.getAccountInfoSync(); let webViewSrc = 'http://cBus'; let pathWebViewSrc = 'https://***/index'; let userSubscribeUrl = 'https://i***e/app/user'; let SogoEnvVersion = 'trial'; //跳转到体验版 // let SogoEnvVersion = \"release\"; //跳转到生产版本 if (accountInfo.miniProgram.envVersion === 'trial') { webViewSrc = 'https://****tcBus'; pathWebViewSrc = 'https://****ndex'; userSubscribeUrl = 'https://****/user'; } else if (accountInfo.miniProgram.envVersion === 'release') { webViewSrc = 'https://***/ftcBus'; pathWebViewSrc = 'https:/***/#/index'; maasBaseUrl = 'https://***/entry'; userSubscribeUrl = 'https://***/app/user'; } module.exports = { webViewSrc, pathWebViewSrc, maasBaseUrl, SogoEnvVersion, userSubscribeUrl, }; 使用 import { maasBaseUrl, SogoEnvVersion } from \"/utils/base.js\" Page({ onLoad() { let ceshi = maasBaseUrl ... } }) 定义公用函数 methods.js /*** * 转换距离 转换成相应的展示单位 * */ function computedDistance(distance) { if (distance > 1000) { return (distance / 1000) + 'km' } else { return distance + '米' } }; /** * 判断用户滑动 * 上滑还是下滑 */ function getTouchData(endX, endY, startX, startY) { let turn = \"\"; if (endY - startY > 50 &amp;&amp; Math.abs(endX - startX) &lt; 50) { //下滑 turn = \"bottom\"; } else if (endY - startY &lt; -50 &amp;&amp; Math.abs(endX - startX) &lt; 50) { //上滑 turn = \"top\"; } return turn; }; module.exports = { computedDistance, getTouchData } 使用 import { computedDistance, getTouchData } from \"/utils/methods.js\" Page({ onLoad() { let ceshi = computedDistance('') } }) 3.4.7 封装 wx-request.js function tansParams(obj){ var str = \"\"; for(var k in obj){ str+=k+\"=\"+obj[k]+\"&amp;\"; } //移除最后一个&amp; return str.slice(0,-1); } function wxRequest(option){ var url = option.url; // 选项里面有params（get传入的参数） if(option.params){ // 如果有参数，把参数转换为url编码形式加入 url+=\"?\"+tansParams(option.params); } // 02 可以添加请求头 var header = { }; var contentType = option.contentType || 'form'; header ['Content-Type'] = { form: 'application/x-www-form-urlencoded', json: 'application/json', }[contentType]; header = { header, ...option.header } header.Authorization =\"Bearer \"+wx.getStorageSync('token'); // 添加加载提示 if(option.loading){ wx.showToast({ title: option.loading.title, icon:option.loading.icon, }) } // 返回一个Promise return new Promise((resolve,reject)=>{ wx.request({ // 请求的地址如果一http开头直接用url不是http开头添加我们 baseUrL url: url, method:option.method||\"GET\",//请求的方法 默认get data:option.data, //post出入的参数 header, success(res){ // 请求成功 resolve(res.data); }, fail(err){ // 04 对错误进行处理 wx.showToast({title:\"加载失败\",icon:\"none\"}) // 请求失败 reject(err); }, complete(){ // 关闭加载提示 wx.hideToast(); } }) }) } // 定义get简易方法 wxRequest.get= (url,config)=>{ return request({url,method:\"get\",...config}) } // 定义post简易方法 wxRequest.post= (url,data,config)=>{ return request({url,method:\"post\",data,...config}) } // 导入request module.exports={ wxRequest } 使用 import { wxRequest } from \"/utils/wx-request.js\" Page({ onLoad() { wxRequest({ method: \"POST\", url: `${maasBaseUrl}/trp/api/v1/openResource/getRouteInfo`, data: routeNo }).then((res) => { if (res) { } }) } }) 3.4.8 组件封装与使用 自定义组件 将页面内的功能模块抽象成自定义组件，以便在不同的页面中重复使用；在自定义组件的 js 文件中，需要使用 Component() 来注册组件，并提供组件的属性定义、内部数据和自定义方法。 组件的文件夹结构应和页面一样：.wxml .wxss .js .json 定义组件 .json****************** 中配置这是一个组件 { \"component\": true } .wxml****************** &lt;view class=\"inner\"> {{innerText}} &lt;/view> &lt;slot>&lt;/slot> .wxss****************** .inner { color: red; } .js****************** Component({ properties: { // 这里定义了 innerText 属性，属性值可以在组件使用时指定 innerText: { type: String, value: 'default value', } }, data: { // 这里是一些组件内部数据 someData: {} }, methods: { // 这里是一个自定义方法 customMethod: function(){} } }) 使用组件 // index.json 中引入组件 { \"usingComponents\": { \"component-tag-name\": \"path/to/the/custom/component\" } } // index.wxml 中使用组件 &lt;view> &lt;!-- 以下是对一个自定义组件的引用 --> &lt;component-tag-name inner-text=\"Some text\"> &lt;view>11111&lt;/view> &lt;/component-tag-name> &lt;/view> 开启多插槽模式（自定义组件默认是单插槽） .js********* Component({ options: { multipleSlots: true // 在组件定义时的选项中启用多 slot 支持 }, properties: { /* ... */ }, methods: { /* ... */ } }) .wxml********** &lt;!-- 组件模板 --> &lt;view class=\"wrapper\"> &lt;slot name=\"before\">&lt;/slot> &lt;view>这里是组件的内部细节&lt;/view> &lt;slot name=\"after\">&lt;/slot> &lt;/view> index.wxml 使用********* &lt;view> &lt;component-tag-name> &lt;!-- 这部分内容将被放置在组件 &lt;slot name=\"before\"> 的位置上 --> &lt;view slot=\"before\">这里是插入到组件slot name=\"before\"中的内容&lt;/view> &lt;!-- 这部分内容将被放置在组件 &lt;slot name=\"after\"> 的位置上 --> &lt;view slot=\"after\">这里是插入到组件slot name=\"after\"中的内容&lt;/view> &lt;/component-tag-name> &lt;/view> 组件样式 默认情况下，自定义组件的样式只受到自定义组件 wxss 的影响，但是，可以配置页面和组件之间样式是否互相影响。 Component({}) 对象配置 options中有个属性styleIsolation： isolated 表示启用样式隔离，互不影响。 apply-shared 表示页面 wxss 样式将影响到自定义组件，但自定义组件 wxss 中指定的样式不会影响页面； shared 表示页面wxss样式和组件wxss样式 相互影响。 .js********* Component({ options: { styleIsolation: 'isolated' } }) 数据传输 可以再组件properties 定义接收参数 Component({ properties: { name: { type: 'String' }, type: { type: 'String' }, index:{ type:'Number' } } )} &lt;component-nav index=\"{{index}}\" type=\"person\" name=\"点击编辑【个人特征】{{index+1}}\"/> 事件沟通 自定义组件触发事件时，需要使用 triggerEvent 方法，接收参数参数：指定事件名、detail对象、事件选项； 触发事件的选项包括： 选项名 类型 是否必填 默认值 描述 bubbles Boolean 否 false 事件是否冒泡 composed Boolean 否 false 事件是否可以穿越组件边界，为false时，事件将只能在引用组件的节点树上触发，不进入其他任何组件内部 capturePhase Boolean 否 false 事件是否拥有捕获阶段 代码示例： 组件********************** &lt;view> &lt;!-- 定义事件 --> &lt;button bindtap=\"onTap\">点击这个按钮将触发“myevent”事件&lt;/button> &lt;slot>&lt;/slot> &lt;/view> Component({ methods: { onTap: function(){ // detail对象，提供给事件监听函数 传输数据 var myEventDetail = {} // 触发事件的选项 var myEventOption = { } // 组件通信 this.triggerEvent('myevent', myEventDetail, myEventOption) } } }) 使用********************** &lt;component-nav bindmyevent=\"onMyEvent\">&lt;/component-nav> Page({ onMyEvent: function(e){ e.detail // 自定义组件触发事件时提供的 detail 对象 } } 获取组件实例 可在父组件里调用 this.selectComponent ，获取子组件的实例对象，调用时需要传入一个匹配选择器 selector。 如：this.selectComponent(“.my-component”)，父组件将会获取 class 为 my-component 的子组件实例对象，即子组件的 this 。 // .wxml*********** &lt;component-nav class=\"component-nav\"/> // .js*********** Page({ data: {}, getChildComponent: function () { const child = this.selectComponent('.my-component'); console.log(child) } }) 示例创建自定义组件Nav nav.json { \"component\": true } nav.wxml &lt;view class=\"nav-item\" bindtap=\"routeToFamily\"> &lt;image src='{{img_server_url}}/ic_status_{{imgName}}.png' mode=\"aspectFit\">&lt;/image> &lt;view class=\"name\">{{name}}&lt;/view> &lt;!-- 定义事件 --> &lt;button bindtap=\"onTap\">点击这个按钮将触发“myevent”事件&lt;/button> &lt;slot name=\"before\">&lt;/slot> &lt;slot name=\"after\">&lt;/slot> &lt;/view> nav.wxss .nav-item{ width:100%; height:70rpx; display: flex; flex-direction: row; align-items: center; } ... nav.js //获取应用实例 const app = getApp(); Component({ options: { // 在组件定义时的选项中启用多 slot 支持 multipleSlots: true, // isolated 表示启用样式隔离 // apply-shared 表示页面 wxss 样式将影响到自定义组件，但自定义组件 wxss 中指定的样式不会影响页面； // shared 表示页面 wxss 和 组件wxss 相互影响 styleIsolation: 'isolated' }, // 接收参数 properties: { name: { type: 'String' }, type: { type: 'String' }, index:{ type:'Number' } }, data: { img_server_url: app.globalData.img_server_url, imgName:0, setIcon:false }, pageLifetimes: { // 页面被展示 show: function () { this.setData({ setIcon:true }); this.setIcon(); } }, ready(){ }, methods: { onTap: function(){ var myEventDetail = {} // detail对象，提供给事件监听函数 var myEventOption = {} // 触发事件的选项 // 组件通信 this.triggerEvent('myevent', myEventDetail, myEventOption) // 出发事件时，可传入配置 // { bubbles：事件是否冒泡，composed： 事件是否可以穿越组件边界，为 false 时，事件将只能在引用组件的节点树上触发，不进入其他任何组件内部，capturePhase：事件是否拥有捕获阶段} this.triggerEvent('myevent', {}, { bubbles: true, composed: true }) }, setIcon:function(){ } ... } }) 在index页面中使用自定义组件Nav // index.json { \"navigationBarTitleText\": \"样本\", \"navigationStyle\": \"custom\", \"usingComponents\": { \"component-nav\": \"../../component/nav/nav\", \"nav-bar\": \"../../component/navbar/index\" } } // index.wxml &lt;component-nav class=\"component-nav\" bindmyevent=\"onMyEvent\" type=\"family\" name=\"点击编辑【户特征】\"> &lt;!-- 这部分内容将被放置在组件 &lt;slot name=\"before\"> 的位置上 --> &lt;view slot=\"before\">这里是插入到组件slot name=\"before\"中的内容&lt;/view> &lt;!-- 这部分内容将被放置在组件 &lt;slot name=\"after\"> 的位置上 --> &lt;view slot=\"after\">这里是插入到组件slot name=\"after\"中的内容&lt;/view> &lt;/component-nav> // index.js Page({ // 这样可以获取到子组件 getChildComponent: function () { // 调用组件时候，给起一个 id、class 都可以 const child = this.selectComponent('.component-nav'); // # console.log(child) } onMyEvent: function(e){ // 自定义组件触发事件时提供的 detail 对象 数据 e.detail } }) 3.4.9 页面跳转 使用API跳转 路由方式 功能描述 路由前页面 路由后页面 navigateTo 打开新页面 onHide onLoad, onShow redirectTo 页面重定向 onUnload onLoad, onShow navigateBack 页面返回 onUnload onShow switchTab Tab 切换 onHide onUnload.. onLoad B.onShow.. reLaunch 重启动 onUnload onLoad, onShow 共有 switchTab reLaunch redirectTo navigateTo navigateBack 五个方法，可以通过 this.pageRouter、 this.router、wx对象 wxNavAction ， 获得当前页面或自定义组件的路由器对象，进行跳转，功能相同；但有区别。 注意： navigateTo,redirectTo只能打开非 tabBar 页面。 switchTab 只能打开 tabBar 页面。 reLaunch 可以打开任意页面。 页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。 调用页面路由带的参数可以在目标页面的onLoad中获取。 非tabba页面跳转 navigateTo、redirectTo、navigateBack等 // 保留当前页面，跳转到应用内的某个页面。 wx.navigateTo({ url: '/pages/calculator/calculator', }) this.pageRouter.navigateTo({ url: '/pages/calculator/calculator', }) this.router.navigateTo({ url: '/pages/calculator/calculator', }) // 关闭当前页面，跳转到应用内的某个页面。 wx.redirectTo({ url: '/pages/calculator/calculatort?id=1' }) this.pageRouter.redirectTo({ url: '/pages/calculator/calculatort?id=1' }) // 关闭当前页面，返回上一页面或多级页面 参数是后退数 wx.navigateBack({ delta: 1 // 2 3 }) ... tabbar页面跳转 wx.switchTab wx.switchTab({ url: '/pages/calculator/calculator', }) this.pageRouter.switchTab({ url: '/pages/calculator/calculator', }) 唯一的区别是，页面路由器中的方法调用时，相对路径永远相对于 this 指代的页面或自定义组件，比wx.navigateTo等方法稳定。 在使用相对路径跳转的时候 页面 index/index 的 js 代码如下所示。如果此时已经跳转到了一个新页面 pack/index ，然后才调用到上面的 wxNavAction 方法，跳转的新页面路径将是 pack/new-page ；而如果调用的是 routerNavAction 方法，跳转的新页面路径仍然是 index/new-page。 // com/index.js Page({ wxNavAction: function () { wx.navigateTo({ url: './new-page' }) }, routerNavAction: function () { // this.pageRouter this.pageRouter.navigateTo({ url: './new-page' }) } }) this.pageRouter 和 this.router区别 this.pageRouter 和 this.router 在页面中将获得同样的页面路由器对象。 但如果在自定义组件中调用， this.pageRouter 将相对于自定义组件所在的页面来进行路由跳转，而 this.router 相对于自定义组件自身的路径。 // components/ceshi/index.js Component({ /** * 组件的方法列表 */ methods: { goto(){ //路径：index/logs/logs // wx.navigateTo({ // url: './logs/logs' // }) //路径：index/logs/logs // this.pageRouter.navigateTo({ // url: './logs/logs' // }) //路径：ceshi/logs/logs this.router.navigateTo({ url: './logs/logs' }) } } }) // 使用组件 &lt;!--index.wxml--> &lt;view class=\"container\"> &lt;ceshi/> &lt;button bindtap=\"bindViewTap\">2222&lt;/button> &lt;!-- 引入 --> &lt;/view> 使用组件标签navigator 跳转 navigator 页面链接 属性名 类型 默认值 说明 target String self 在哪个目标上发生跳转，默认当前小程序，可选值self/miniProgram url String 应用内的跳转链接 open-type String navigate 跳转方式 delta Number 当 open-type 为 ‘navigateBack’ 时有效，表示回退的层数 app-id String 当target=”miniProgram”时有效，要打开的小程序 appId path String 当target=”miniProgram”时有效，打开的页面路径，如果为空则打开首页 extra-data Object 当target=”miniProgram”时有效，需要传递给目标小程序的数据，目标小程序可在 App.onLaunch() ，App.onShow() 中获取到这份数据。 version version release 当target=”miniProgram”时有效，要打开的小程序版本，有效值 develop（开发版），trial（体验版），release（正式版），仅在当前小程序为开发版或体验版时此参数有效；如果当前小程序是正式版，则打开的小程序必定是正式版。 hover-class String navigator-hover 指定点击时的样式类，当hover-class=&quot;none&quot;时，没有点击态效果 hover-stop-propagation Boolean false 指定是否阻止本节点的祖先节点出现点击态 hover-start-time Number 50 按住后多久出现点击态，单位毫秒 hover-stay-time Number 600 手指松开后点击态保留时间，单位毫秒 bindsuccess String 当target=”miniProgram”时有效，跳转小程序成功 bindfail String 当target=”miniProgram”时有效，跳转小程序失败 bindcomplete String 当target=”miniProgram”时有效，跳转小程序完成 open-type 有效值： 值 说明 最低版本 navigate 对应wx.navigateTo的功能 redirect 对应wx.redirectTo的功能 switchTab 对应wx.switchTab的功能 reLaunch 对应wx.reLaunch的功能 1.1.0 navigateBack 对应wx.navigateBack的功能 1.1.0 exit 退出小程序，target=”miniProgram”时生效 2.1.0 注：navigator-hover默认为{background-color: rgba(0, 0, 0, 0.1); opacity: 0.7;}, &lt;navigator/&gt;的子节点背景色应为透明色 &lt;view class=\"btn-area\"> &lt;navigator url=\"/page/navigate/navigate?title=navigate\" hover-class=\"navigator-hover\">跳转到新页面&lt;/navigator> &lt;navigator url=\"../../redirect/redirect/redirect?title=redirect\" open-type=\"redirect\" hover-class=\"other-navigator-hover\">在当前页打开&lt;/navigator> &lt;navigator url=\"/page/index/index\" open-type=\"switchTab\" hover-class=\"other-navigator-hover\">切换 Tab&lt;/navigator> &lt;navigator target=\"miniProgram\" open-type=\"navigate\" app-id=\"\" path=\"\" extra-data=\"\" version=\"release\">打开绑定的小程序&lt;/navigator> &lt;/view> 页面跳转传参 传输 直接放到页面路径后既可。示例： // 查看地图分布 clickAllParkMap(){ var parkId=this.data.parkData[0].parkId; wx.navigateTo({ url: \"../park-map/park-map?inputValue=\"+this.data.inputValue+'&amp;parkId='+parkId }); }, // 点击单个 clickParkMap(e){ var index = e.currentTarget.dataset.text; var parkId=this.data.parkData[index].parkId; var parkName = this.data.parkData[index].parkName; wx.navigateTo({ url: \"../park-map/park-map?inputValue=\"+parkName+'&amp;parkId='+parkId }); }, 获取 在页面的onLoad函数，接收参数 options 中获取， /** * 生命周期函数--监听页面加载 */ onLoad: function (options) { var parkId=options.parkId || null; var parkName=options.parkId || null; }, 3.4.10 提示、加载 wx.showToast 显示消息提示框 wx.hideToast 隐藏消息提示框 wx.showModal 显示模态对话框 wx.showLoading 显示 loading 提示框 wx.hideLoading 关闭 loading 提示框 wx.showActionSheet 显示操作菜单 wx.showToast(option) 显示消息提示框 参数 类型 必填 说明 title String 是 提示的内容 icon String 否 图标，有效值”success”、”error” 、”loading” 、”none” image String 否 自定义图标的本地路径，image 的优先级高于 icon duration Number 否 提示的延迟时间，单位毫秒，默认：1500 mask Boolean 否 是否显示透明蒙层，防止触摸穿透，默认：false success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） wx.showToast({ title: '成功', icon: 'success', duration: 2000 }) wx.hideToast() 显示消息提示框.png wx.showModal(option) 显示模态对话框 参数 类型 必填 说明 title String 是 提示的标题 content String 是 提示的内容 showCancel Boolean 否 是否显示取消按钮，默认为 true cancelText String 否 取消按钮的文字，默认为”取消”，最多 4 个字符 cancelColor HexColor 否 取消按钮的文字颜色，默认为”#000000” confirmText String 否 确定按钮的文字，默认为”确定”，最多 4 个字符 confirmColor HexColor 否 确定按钮的文字颜色，默认为”#3CC51F” success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） succes返回参数说明： 参数 类型 说明 confirm Boolean 为 true 时，表示用户点击了确定按钮 cancel Boolean 为 true 时，表示用户点击了取消（用于 Android 系统区分点击蒙层关闭还是点击取消按钮关闭） wx.showModal({ title: '提示', content: '这是一个模态弹窗', success (res) { if (res.confirm) { console.log('用户点击确定') } else if (res.cancel) { console.log('用户点击取消') } } }) 显示模态对话框.png wx.showActionSheet(option) 显示操作菜单 参数 类型 必填 说明 itemList String Array 是 按钮的文字数组，数组长度最大为6个 itemColor HexColor 否 按钮的文字颜色，默认为”#000000” success Function 否 接口调用成功的回调函数，详见返回参数说明 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） success返回参数说明： 参数 类型 说明 tapIndex Number 用户点击的按钮，从上到下的顺序，从0开始 wx.showActionSheet({ itemList: ['A', 'B', 'C'], success (res) { console.log(res.tapIndex) }, fail (res) { console.log(res.errMsg) } }) 显示操作菜单.png 注意 wx.showLoading和 wx.showToast同时只能显示一个 wx.showToast 应与 wx.hideToast配对使用 3.4.11 自定义导航栏使用page.json中配置：navigationStyle 。 详情可以看我另外一片文章 自定义页面导航栏 属性 类型 默认值 描述 navigationStyle string default 导航栏样式，配置值：default默认、custom自定义，只保留右上角胶囊按钮 usingComponents Object 无 页面自定义组件配置 在对应页面的json中开启自定义顶部状态栏，且引入自定义的状态栏组件。 \"navigationStyle\": \"custom\", \"usingComponents\": { \"nav-bar\": \"../../component/navbar/index\" } 自定义组件navbar 在 app.js中获取 手机的状态栏高度以及字体大小。wx.getSystemInfo（） onLaunch: function () { //获取手机导航栏高度 wx.getSystemInfo({ success: res => { var isIos = res.system.indexOf('iOS') > -1; this.globalData.statusHeight = res.statusBarHeight; this.globalData.navHeight = isIos ? 44 : 48; this.globalData.fontSize = res.fontSizeSetting; //设置低版本不显示自定义导航栏 if (res.SDKVersion &amp;&amp; res.SDKVersion.split('.')[0] * 1 &lt;= 2 &amp;&amp; res.SDKVersion.split('.')[1] * 1 &lt; 5){ this.globalData.navHeightHidden=true; } }, fail(err) { console.log(err); } }) } globalData: { //自定义导航组件高度 navHeightHidden:false, statusHeight:null, navHeight:null, fontSize:null, } navbar.wxml &lt;!-- 如果版本低于2.5后，不显示自定义状态栏 --> &lt;block wx:if=\"{{navHeightHidden}}\"> &lt;view>&lt;/view> &lt;/block> &lt;block wx:else> &lt;view style=\"height:{{statusHeight+navHeight}}px\" hidden='{{header.hiddenBlock}}'>&lt;/view> &lt;view class='topbar' style=\"background:{{header.headerbg}}\"> &lt;view class='status' style=\"height:{{statusHeight}}px\">&lt;/view> &lt;view class='navbar' style=\"height:{{navHeight}}px\"> &lt;block wx:if=\"{{header.slot}}\"> &lt;slot>&lt;/slot> &lt;/block> &lt;block wx:else> &lt;view class='navbar_home' wx:if=\"{{header.homeCapsule}}\" style=\"background:{{header.capsulebg}};border:{{header.capsuleborder}}\"> &lt;image src='../../images/black_back.png' bindtap='backClick' style=\"border-right:{{header.capsulesep}}\">&lt;/image> &lt;image src='../../images/home_black.png' bindtap='homeClick'>&lt;/image> &lt;/view> &lt;view class='navbar_back' bindtap='backClick' wx:else> &lt;image src='../../images/black_back.png'>&lt;/image> &lt;/view> &lt;view class='navbar_title' style=\"height:{{navHeight}}px\"> &lt;view style=\"color:{{header.fontColor}};font-size:{{fontSize}}px\">{{header.title}}&lt;/view> &lt;/view> &lt;/block> &lt;/view> &lt;/view> &lt;/block> navbar.wxss .topbar { position: fixed; left: 0; top: 0; width: 100%; z-index: 9999; } .status { width: 100%; } ... navbar.js 编写业务员逻辑，我的是点击左上角返回按钮的事件，弹窗提示要不要返回 var app = getApp(); Component({ properties: { header: { type: Object, value: { homeCapsule: false, headerbg: \"#fff\", title: \"\", fontColor: \"#000\", fontSize: '16', hiddenBlock: false, capsulebg: 'rgba(0,0,0,0.2)', capsuleborder: '1px solid rgba(0, 0, 0, 0.1)', capsulesep: '1px solid rgba(255,255,255,0.2)', slot: false } }, customBackReturn: { type: Boolean, value: false } }, data:{ statusHeight: app.globalData.statusHeight, navHeight: app.globalData.navHeight, fontSize: app.globalData.fontSize, navHeightHidden: app.globalData.navHeightHidden }, methods: { // 定义点击左上角返回按钮的函数 backClick() { var me=this; wx.showModal({ title: '提示', content: '如有改动，请确认是否已点击【保存】', success(res) { if (res.confirm) { if (me.data.customBackReturn) { me.triggerEvent(\"customBackReturn\") } else { if (getCurrentPages().length == 1) { wx.switchTab({ url: '/pages/index/index', }) } else { wx.navigateBack({ delta: 1 }) } } } else if (res.cancel) { } } }) }, homeClick() { wx.switchTab({ url: '/pages/index/index', }) } } }) 组件的json index.json { \"component\": true } 使用组件 在对应页面的json中开启自定义顶部状态栏，且引入自定义的状态栏组件。 \"navigationStyle\": \"custom\", \"usingComponents\": { \"nav-bar\": \"../../component/navbar/index\" } 在对应页面的js中写好定义的组件状态和标题名 //自定义顶部 参数直接能看懂 nvabarData: { homeCapsule: false, title: '户特征', fontColor: \"white\", fontSize: '26rpx', headerbg: '#04aceb', hiddenBlock: false, slot: false }, // 整个导航栏高度 navHeight: app.globalData.navHeight + app.globalData.statusHeight, // 是否显示自定义导航栏（为低版本） navHeightHidden: app.globalData.navHeightHidden, 在index 中使用自定义组件 &lt;!-- 自定义顶部 --> &lt;nav-bar header='{{nvabarData}}'>&lt;/nav-bar> // 我的页面用的是100% 高度的布局， 所有要减去这个状态栏的高度 &lt;view class=\"container\" style=\"height: calc( 100% - {{navHeightHidden?0:navHeight}}px );\">&lt;/view> 四、常用功能4.1 常用小程序api 4.1.1 数据缓存 官方API地址 wx.setStorage(option) 将数据存储在本地缓存中指定的key中，会覆盖掉原来该key对应的内容，这是一个异步接口。 设置setStorage、获取getStorage、删除removeStorage OBJECT参数说明 参数 类型 必填 说明 key String 是 本地缓存中的指定的 key data Object/String 是 需要存储的内容 success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） Page({ data: { logs: [] }, onLoad() { // 设置 wx.setStorage({ key:\"key11\", data:\"value\" }) // 获取 wx.getStorage({ key: 'key11', success (res) { // 直接就是对象 console.log(res.data) } }) // 批量读取 数组 wx.batchGetStorage({ keyList: ['key11'], success (res) { console.log(res) } }) // 删除 wx.removeStorage({ key: 'key', success (res) { console.log(res) } }) } }) wx.setStorageSync(option) 将data存储在本地缓存中指定的key中，会覆盖掉原来该key对应的内容，这是一个同步接口。 设置setStorageSync、获取getStorageSync、删除removeStorageSync OBJECT参数说明 参数 类型 必填 说明 key String 是 本地缓存中的指定的key data Object/String 是 需要存储的内容 Page({ data: { regionData:null }, onLoad() { // 设置 wx.setStorageSync('regionData', {a:1,b:2}); // 获取 直接就是对象 var regionData = wx.getStorageSync('regionData') || ''; // 删除 wx.removeStorageSync('regionData'); } }) wx.batchSetStorageSync(option) 批量存储 Array. kvList，将数据批量存储在本地缓存中指定的 key 中，单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB。这是一个同步接口。 等同于多个setStorageSync ，但是对于多个 key 的读取, 批量读取在性能上优于多次 getStorageSync 读取 OBJECT参数说明 Array. kvList 参数 类型 必填 说明 key String 是 本地缓存中的指定的key data Object/String 是 需要存储的内容 Page({ data: { regionData:null }, onLoad() { // 设置 wx.batchSetStorageSync([ {key: 'key1', value: '1'}, {key: 'key2', value: {a:1,b:2} } ]) // 获取 var valueList = wx.batchGetStorageSync(['key1','key2']) // [\"1\", \"2\"] // 删除 // 使用removeStorageSync 单个删除; } }) 以上三类存储API，注意事项： 1：存储同样的key，会覆盖掉原来该 key 对应的内容。 2：除非用户主动删除或因存储空间原因被系统清理，否则数据都一直可用。 4.1.2 微信小程序画布 canvas 微信小程序标签组件：canvas 属性 类型 默认值 必填 说明 最低版本 type string 否 指定 canvas 类型，支持 2d (2.9.0) 和 webgl (2.7.0) 2.7.0 canvas-id string 否 canvas 组件的唯一标识符，若指定了 type 则无需再指定该属性 1.0.0 disable-scroll boolean false 否 当在 canvas 中移动时且有绑定手势事件时，禁止屏幕滚动以及下拉刷新 1.0.0 bindtouchstart eventhandle 否 手指触摸动作开始 1.0.0 bindtouchmove eventhandle 否 手指触摸后移动 1.0.0 bindtouchend eventhandle 否 手指触摸动作结束 1.0.0 bindtouchcancel eventhandle 否 手指触摸动作被打断，如来电提醒，弹窗 1.0.0 bindlongtap eventhandle 否 手指长按 500ms 之后触发，触发了长按事件后进行移动不会触发屏幕的滚动 1.0.0 binderror eventhandle 否 当发生错误时触发 error 事件，detail = {errMsg} 1.0.0 注意事项： canvas 标签默认宽度300px、高度150px 同一页面中的 canvas-id 不可重复，如果使用一个已经出现过的 canvas-id，该 canvas 标签对应的画布将被隐藏并不再正常工作 请注意原生组件使用限制 开发者工具中默认关闭了 GPU 硬件加速，可在开发者工具的设置中开启“硬件加速”提高 WebGL 的渲染性能 WebGL 支持通过 getContext(‘webgl’, { alpha: true }) 获取透明背景的画布 Canvas 2D（新接口）需要显式设置画布宽高 (默认为 300x150) 避免设置过大的宽高，在安卓下会有crash的问题 Canvas 2D 示例代码 &lt;!-- canvas.wxml --> &lt;canvas type=\"2d\" id=\"myCanvas\">&lt;/canvas> // canvas.js Page({ onReady() { const query = wx.createSelectorQuery() query.select('#myCanvas') .fields({ node: true, size: true }) .exec((res) => { const canvas = res[0].node const ctx = canvas.getContext('2d') const dpr = wx.getSystemInfoSync().pixelRatio canvas.width = res[0].width * dpr canvas.height = res[0].height * dpr ctx.scale(dpr, dpr) ctx.fillRect(0, 0, 100, 100) }) } }) WebGL 示例代码 &lt;!-- canvas.wxml --> &lt;canvas type=\"webgl\" id=\"myCanvas\">&lt;/canvas> // canvas.js Page({ onReady() { const query = wx.createSelectorQuery() query.select('#myCanvas').node().exec((res) => { const canvas = res[0].node const gl = canvas.getContext('webgl') gl.clearColor(1, 0, 1, 1) gl.clear(gl.COLOR_BUFFER_BIT) }) } }) 示例 Page({ data: { }, // 画背景 drawProgressbg: function () { // 使用 旧api绘制 + 新api 自动适配圆圈大小 const query = wx.createSelectorQuery(); query.select('#canvasProgressbg') .fields({ node: true, size: true }) .exec((res) => { // 获取 px -> rpx 比例 // const dpr = wx.getSystemInfoSync().pixelRatio; var width = res[0].width; var height = res[0].height; var ctx = wx.createCanvasContext('canvasProgressbg', this) ctx.setLineWidth(4);// 设置圆环的宽度 ctx.setStrokeStyle('#e2e0e0'); // 设置圆环的颜色 ctx.setLineCap('round') // 设置圆环端点的形状 ctx.beginPath();//开始一个新的路径 var radius = (height - 26) / 2; //设置圆的路径到当前路径 ctx.arc(width / 2, height / 2, radius, 0, 2 * Math.PI, false); ctx.stroke();//对当前路径进行描边 ctx.draw(); }) }, // 画公交线路倒计时 参数： step=( 到站秒数 / (900/2) ) 最大900s drawCircle: function (step) { // 使用 旧api绘制 + 新api 自动适配圆圈大小 const query = wx.createSelectorQuery(); query.select('#canvasProgress') .fields({ node: true, size: true }) .exec((res) => { // 获取 px -> rpx 比例 // const dpr = wx.getSystemInfoSync().pixelRatio; var width = res[0].width; var height = res[0].height; var ctx = wx.createCanvasContext('canvasProgress', this); // 设置渐变 var gradient = ctx.createLinearGradient(200, 100, 100, 200); gradient.addColorStop(\"0\", \"#77d0dc\"); gradient.addColorStop(\"0.5\", \"#1db1c6\"); gradient.addColorStop(\"1.0\", \"#09b1c7\"); ctx.setLineWidth(6); ctx.setStrokeStyle(gradient); ctx.setLineCap('round') ctx.beginPath(); var radius = (height - 30) / 2; // 参数step 为绘制的圆环周长，从0到2为一周 。 -Math.PI / 2 将起始角设在12点钟位置 ，结束角 通过改变 step 的值确定 ctx.arc(width / 2, height / 2, radius, -Math.PI / 2, step * Math.PI - Math.PI / 2, false); ctx.stroke(); // 画跟随的圆圈 内圆 var e = step * Math.PI - Math.PI / 2; ctx.beginPath() let x, y, r1 = 8; // 通过三角函数计算x y 坐标 x = radius * Math.cos(e) + width / 2; y = radius * Math.sin(e) + width / 2; ctx.arc(x, y, r1, 0, 2 * Math.PI) ctx.fillStyle = 'rgba(29,177,198,1)'; ctx.fill() ctx.closePath() // 外圆 ctx.beginPath() let r2 = 15 ctx.arc(x, y, r2, 0, 2 * Math.PI); ctx.fillStyle = 'rgba(29,177,198,0.5)' ctx.fill() ctx.closePath(); ctx.draw(); }) }, }) image.png 4.1.3 相机 wx.chooseImage 使用接口：wx.chooseImage(Object object)从本地相册选择图片或使用相机拍照。具体可看我另外一篇文章 微信小程序调用相机 参数 属性 类型 说明 width number 图像数据矩形的宽度 height number 图像数据矩形的高度 data ArrayBuffer 图像像素点数据，一维数组，每四项表示一个像素点的 rgba 返回值参数 属性 类型 默认值 必填 success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） success 返回值 res 属性 类型 说明 tempThumbPath string 封面图片文件的临时路径 (本地路径) tempVideoPath string 视频的文件的临时路径 (本地路径) Page({ data: { carWin_img_hidden:true, //展示照片的view是否隐藏 carWin_img:'' //存放照片路径的 }, //页面加载设置初始值 可以不要 onReady(res){ this.setData({ carWin_img_hidden: true, carWin_img: '' }); }, //点击事件 clickCarWin(){ var that = this; wx.chooseImage({ count: 1, success: function (res) { // 无论用户是从相册选择还是直接用相机拍摄，路径都是在这里面 var filePath = res.tempFilePaths[0]; //将刚才选的照片/拍的 放到下面view视图中 that.setData({ carWin_img: filePath, //把照片路径存到变量中， carWin_img_hidden: false //让展示照片的view显示 }); // 这个是使用微信接口保存文件到数据库 // wx.uploadFile({ // url: \"\", // filePath: filePath, // name: 'file', // success: function (res) { // } // }) }, fail: function (error) { console.error(\"调用本地相册文件时出错\") console.warn(error) }, complete: function () { } }); } }) 4.1.4 获取位置 获取用户位置信息，共需要使用以下三个api： wx.getSetting 获取用户授权信息列表 wx.authorize 向用户发起授权请求 wx.getLocation 获取用户位置信息 wx.getSetting(option) 获取用户的当前设置。*返回值中只会出现小程序已经向用户请求过的权限。 option 参数说明 属性 类型 默认值 说明 withSubscriptions Boolean false 是否同时获取用户订阅消息的订阅状态，默认不获取。 success function 接口调用成功的回调函数 fail function 接口调用失败的回调函数 complete function 接口调用结束的回调函数（调用成功、失败都会执行） success 回调函数 属性 类型 说明 authSetting AuthSetting 用户授权结果 subscriptionsSetting SubscriptionsSetting 用户订阅消息设置，接口参数withSubscriptions值为true时才会返回。 miniprogramAuthSetting AuthSetting 在插件中调用时，当前宿主小程序的用户授权结果 wx.getSetting({ success (res) { console.log(res.authSetting) // res.authSetting = { // \"scope.userInfo\": true, // \"scope.userLocation\": true // } } }) wx.authorize (option) 用户授权名称列表 可查看 授权scope 列表 option参数说明 属性 类型 必填 说明 scope string 是 需要获取权限的 scope success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） // 可以通过 wx.getSetting 先查询一下用户是否授权了 \"scope.record\" 这个 scope wx.getSetting({ success(res) { // 查询用户是否授权位置信息 if (!res.authSetting['scope.userLocation']) { // 调用位置授权 wx.authorize({ scope: 'scope.userLocation', success() { } }) } } }) wx.getLocation(option) 获取当前的地理位置、速度。当用户离开小程序后，此接口无法调用；当用户点击“显示在聊天顶部”时，此接口可继续调用。 option参数说明 参数 类型 必填 说明 type String 否 默认为”wgs84”返回gps坐标，”gcj02”返回可用于wx.openLocation的坐标 success Function 是 接口调用成功的回调函数，返回内容详见返回参数说明。 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） success返回参数说明 参数 说明 latitude 纬度，浮点数，范围为-90~90，负数表示南纬 longitude 经度，浮点数，范围为-180~180，负数表示西经 speed 速度，浮点数，单位m/s accuracy 位置的精确度 altitude 高度，单位 m verticalAccuracy 垂直精度，单位 m（Android 无法获取，返回 0） horizontalAccuracy 水平精度，单位 m wx.getLocation({ type: 'wgs84', success (res) { const latitude = res.latitude const longitude = res.longitude const speed = res.speed const accuracy = res.accuracy } }) 获取用户位置信息示例 第一步：在app.json中申明 { \"pages\": [ \"pages/index/index\" ], \"window\": { \"backgroundTextStyle\": \"light\", \"navigationBarBackgroundColor\": \"#fff\", \"navigationBarTitleText\": \"Weixin\", \"navigationBarTextStyle\": \"black\" }, \"permission\": { \"scope.userLocation\": { \"desc\": \"你的位置信息将用于小程序首页获取附近公交站点\" } }, \"style\": \"v2\", \"sitemapLocation\": \"sitemap.json\" } 第二步：提前让用户授权，示例在app.js中调用wx.getSetting、wx.authorize 弹窗让用户授权 // app.js App({ onLaunch() { // 位置授权 wx.getSetting({ success(res) { if (!res.authSetting['scope.userLocation']) { wx.authorize({ scope: 'scope.userLocation', success() { } }) } } }) }, globalData: { userInfo: null } }) 第三步：在需要获取位置的地方，调用获取 &lt;!--index.wxml--> &lt;view class=\"container\"> &lt;map id=\"myMap\" show-location /> &lt;button type=\"primary\" bindtap=\"getCenterLocation\">获取位置&lt;/button> &lt;button type=\"primary\" bindtap=\"moveToLocation\">移动位置&lt;/button> &lt;button type=\"primary\" bindtap=\"translateMarker\">移动标注&lt;/button> &lt;button type=\"primary\" bindtap=\"includePoints\">缩放视野展示所有经纬度&lt;/button> &lt;/view> // map.js Page({ onReady: function (e) { // 使用 wx.createMapContext 获取 map 上下文 this.mapCtx = wx.createMapContext('myMap') }, getCenterLocation: function () { this.mapCtx.getCenterLocation({ success: function(res){ console.log(res.longitude) console.log(res.latitude) } }) }, moveToLocation: function () { this.mapCtx.moveToLocation() }, translateMarker: function() { this.mapCtx.translateMarker({ markerId: 0, autoRotate: true, duration: 1000, destination: { latitude:23.10229, longitude:113.3345211, }, animationEnd() { console.log('animation end') } }) }, includePoints: function() { this.mapCtx.includePoints({ padding: [10], points: [{ latitude:23.10229, longitude:113.3345211, }, { latitude:23.00229, longitude:113.3345211, }] }) } }) 4.1.5 屏幕操作 设置屏幕亮度：wx.setScreenBrightness（） 参数值：value 0-1，越大越亮 if (wx.setScreenBrightness) { //设置屏幕亮度 参数值：0-1，越大越亮 wx.setScreenBrightness({ value: 0.6 }); } else { // 如果希望用户在最新版本的客户端上体验您的小程序，可以这样子提示 wx.showModal({ title: '提示', content: '当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。' }) } 获取屏幕亮度 wx.getScreenBrightness() if (wx.getScreenBrightness) { //获取屏幕亮度 值：0-1，越大越亮 success: function (res) { // res.value }, fail: function () { //请求失败 } } else { // 如果希望用户在最新版本的客户端上体验您的小程序，可以这样子提示 wx.showModal({ title: '提示', content: '当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。' }) } 以上两个方法可以配合使用，设置前记得先获取一下屏幕亮度，存起来，设置好亮度等不需要这么亮或用户退出程序时候，在给设置回去，这样用户体验好一些。 注：记得别忘记用户退出程序或者是某个界面时，恢复一下了亮度。 设置屏幕常亮 wx.setKeepScreenOn 参数值： true / false if (wx.setScreenBrightness) { // 保持屏幕常亮 true / false wx.setKeepScreenOn({ keepScreenOn: false }); } else { // 如果希望用户在最新版本的客户端上体验您的小程序，可以这样子提示 wx.showModal({ title: '提示', content: '当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。' }) } 注：记得别忘记用户退出程序或者是某个界面时，重新设置一下不常亮。 4.1.6 扫码 wx.scanCode 调起客户端扫码界面进行扫码 option参数说明 属性 类型 默认值 说明 onlyFromCamera boolean false 是否只能从相机扫码，不允许从相册选择图片 scanType Array. [‘barCode’, ‘qrCode’] 扫码类型 success function 接口调用成功的回调函数 fail function 接口调用失败的回调函数 complete function 接口调用结束的回调函数（调用成功、失败都会执行） object.scanType 的合法值 值 说明 barCode 一维码 qrCode 二维码 datamatrix Data Matrix 码 pdf417 PDF417 条码 success res 属性 类型 说明 result string 所扫码的内容 scanType string 所扫码的类型 charSet string 所扫码的字符集 path string 当所扫的码为当前小程序二维码时，会返回此字段，内容为二维码携带的 path rawData string 原始数据，base64编码 // 允许从相机和相册扫码 wx.scanCode({ success (res) { console.log(res) } }) // 只允许从相机扫码 wx.scanCode({ onlyFromCamera: true, success (res) { console.log(res) } }) 4.2 第三方插件使用微信官方及第三方等提供了很多优秀的小程序页面插件，如：腾讯位置服务地图选点、腾讯位置导航等，使用方式相同，均是无缝跳转到插件小程序页面 在微信公众平台中配置插件 “微信小程序官方后台-设置-第三方服务-插件管理” 里点击 “添加插件”，如：搜索 “腾讯位置服务地图选点” 申请，审核通过后，小程序开发者可在小程序内使用该插件。 引入插件包 点击插件详情，既可看到插件APPid 在app.json中配置使用插件 { \"pages\": [ \"pages/index/index\", \"pages/logs/logs\", \"components/ceshi\" ], \"window\": { \"backgroundTextStyle\": \"light\", \"navigationBarBackgroundColor\": \"#fff\", \"navigationBarTitleText\": \"Weixin\", \"navigationBarTextStyle\": \"black\" }, \"permission\": { \"scope.userLocation\": { \"desc\": \"你的位置信息将用于小程序首页获取附近公交站点\" } }, \"plugins\": { \"routePlan\": { \"version\": \"1.0.5\", \"provider\": \"wx76a9a06e5b4e693e\" } }, \"style\": \"v2\", \"sitemapLocation\": \"sitemap.json\" } 设置定位授权 地图选点插件需要小程序提供定位授权才能够正常使用定位功能： // app.json { \"permission\": { \"scope.userLocation\": { \"desc\": \"你的位置信息将用于小程序定位\" } } } 使用插件 插件页面调用示例： const key = ''; //使用在腾讯位置服务申请的key const referer = ''; //调用插件的app的名称 // 初始位置的经纬度，如果不传 默认当前位置 const location = JSON.stringify({ latitude: 39.89631551, longitude: 116.323459711 }); const category = '生活服务,娱乐休闲'; wx.navigateTo({ url: 'plugin://chooseLocation/index?key=' + key + '&amp;referer=' + referer + '&amp;location=' + location + '&amp;category' + category }); 插件返回数据 //地图返回 在页面的 onShow中 获取数据返回。 const location = chooseLocation.getLocation(); // 返回的数据放在这个对象里面 if (location) { allData.address_name = location.name; allData.address = location.address; allData.address_poi = location.latitude + ',' + location.longitude; } 效果如下 4.3 微信扫码快捷打开小程序页面微信公众平台开放扫描普通链接二维码跳转小程序能力。 普通链接二维码，是指开发者使用工具对网页链接进行编码后生成的二维码。 线下商户可不需更换线下二维码，在小程序后台完成配置后，即可在用户扫描普通链接二维码时打开小程序，使用小程序的功能。 对于普通链接二维码，目前支持使用微信“扫一扫”或微信内长按识别二维码跳转小程序。 登录小程序后台 进入“设置-开发设置-扫普通链接二维码打开小程序”，开启功能后即可配置二维码规则。 配置规则 二维码规则 二维码规则的域名须通过ICP备案的验证。 支持http、https、ftp开头的链接，一个小程序帐号可配置不多于10个二维码前缀规则。 前缀占用规则 可选择是否占用符合二维码匹配规则的所有子规则。如选择占用，则其他帐号不可申请使用满足该前缀匹配规则的其他子规则。 如：若开发者A配置二维码规则：http://aaa/mp?id=123，并选择“占用所有子规则“，其他开发者将不可以配置满足前缀匹配的子规则 下载随机校验文件，并将文件上传至服务器指定位置的目录下（你填写的这个链接，加上这个校验文件名称，必须能访问到，如：http://aaa/mp/rOO4daUTUI.txt），方可通过所属权校验。 根据要求填写好下列选项 如： 制作二维码 使用二维码工具制作二维码：如 草料二维码 将域名放入，可传参，小程序对应页面可接收参数，方法同路由跳转接收参数一样。生成二维码， 然后就可以使用微信扫描这个二维码进入小程序对应页面。 如：its.***.com/ft-xcx?a=1&amp;b=2 4.4 地图map组件提供了地图展示、交互、叠加点线面及文字等功能，同时支持个性化地图样式，可结合地图服务 API 实现更丰富功能，这里简单说一下， 不过多讲解，内容很多，详情去文档看既可。。 微信文档-map 个性化地图 个性化地图能力可在小程序后台“开发-开发者工具-腾讯位置服务”申请开通。 小程序内地图组件应使用同一 subkey，可通过 layer-style（地图官网设置的样式 style 编号）属性选择不同的底图风格。 组件属性的长度单位默认为px，2.4.0起支持传入单位(rpx/px)。。 示例 &lt;!-- line-map --> &lt;view class='station_map'> &lt;map class='map' subkey=\"3A4BZ-TMKEP-OPEDL-VCRQ7-HUJZ5-TJBYJ\" id=\"station_map\" longitude=\"{{longitude}}\" latitude=\"{{latitude}}\" scale=\"14\" markers=\"{{markers}}\" polyline=\"{{polyline}}\" show-location >&lt;/map> &lt;/view> // pages/line/line.js const Common = require(\"../../../utils/common.js\"); //获取应用实例 const app = getApp(); Component({ properties:{ stations: { type: 'Object', value: {} }, lineId: { type: 'String', value:'' } }, data: { // 图片链接 img_server_url: app.globalData.img_server_url, latitude: 22.533773, longitude: 114.057678, markers: [], polyline: [], controls: [] }, ready(){ var markers = []; for (var i = 0; i &lt; this.data.stations.length; i++) { var station = this.data.stations[i]; var poi = Common.wgs84togcj02(station.lng, station.lat); markers.push({ id: i, iconPath:\"./images/station_icon1.png\", latitude: poi[1], longitude: poi[0], width: 20, height: 20, callout: { content: '站名：' + station.station_name, color: '#000', fontSize: '24rpx', padding: '10rpx', bgColor: '', borderRadius: '10rpx' } }) } var poi = Common.wgs84togcj02(this.data.stations[0].lng, this.data.stations[0].lat); this.setData({ markers: markers, latitude: poi[1], longitude: poi[0], }); wx.showLoading({ title: '加载中···', mask: true }); var me = this; let param = { lineId: this.data.lineId }; var url = app.globalData.request_server_url + \"/wechat/getLineGeom\"; Common.fetchGet(url, param, function (records) { wx.hideLoading(); let lineGeo = records.message.replace(/\\w+/, ''); lineGeo = lineGeo.replace(/\\(|\\)/g, ''); lineGeo=lineGeo.split(','); var points = lineGeo.map( (item)=>{ item = item.replace(/^\\s+/,''); item=item.split(' '); var poi = Common.wgs84togcj02(item[0], item[1]); return { longitude: poi[0], latitude: poi[1] } }); var polyline=[{ points: points, color: '#09b1c7', borderColor:'#2f7f39', borderWidth:2, width: 5 }]; me.setData({ polyline: polyline }) }); }, method:{ } }) 4.5 echarts使用 下载echarts 下载echarts微信版 地址：https://github.com/ecomfe/echarts-for-weixin 下载后打开，如图所示： 将下载好的文件中 ec-canvas目录 放在小程序项目目录中即可。如下图所示： 然后在需要的地方引入即可。 效果 示例 在页面开启使用echarts 如：在 page目录的ceshi页面中使用echarts的话，需要在ceshi.json中添加以下配置。 \"usingComponents\": { \"ec-canvas\": \"../../ec-canvas/ec-canvas\" } 引入 在 ceshi.js 中引入echarts.js import * as echarts from '../../ec-canvas/echarts'; wxml元素 在ceshi.wxml中建立一个元素，外层用view包一下是方便设置echarts元素的宽高。 &lt;view class=\"echart_panel\"> &lt;ec-canvas>&lt;/ec-canvas> &lt;/view> 开始编写图表 折线图 我是在ceshi.js中直接写了一个函数，传一些参数，返回一个option，至于echarts的option写法，可以参考echats官网api文档。 function getOption(xData, data_cur, data_his) { var option = { backgroundColor: \"#f5f4f3\", color: [\"#37A2DA\", \"#f2960d\", \"#67E0E3\", \"#9FE6B8\"], title: { text: '实时运行速度', textStyle: { fontWeight: '500', fontSize: 15, color: '#000' }, x:'center', y:'0' }, legend: { data: ['今日', '昨日'], right: 10 }, grid: { top: '15%', left: '1%', right: '3%', bottom: '60rpx', containLabel: true }, tooltip: { show: true, trigger: 'axis' }, xAxis: { type: 'category', boundaryGap: false, data: xData||[], axisLabel: { interval: 11, formatter: function (value, index) { return value.substring(0, 2) * 1; }, textStyle: { fontsize: '10px' } } }, yAxis: { x: 'center', name: 'km/h', type: 'value', min: 0, max: 120 }, series: [{ name: '今日', zIndex:2, type: 'line', smooth: true, symbolSize: 0, data: data_cur||[] },{ name: '昨日', zIndex: 1, type: 'line', smooth: true, symbolSize: 0, data: data_his||[] }] }; return option; } 然后就可以在 页面page中的data中配置初始化，如何初始化？ 首先 建立一个全局变量（注意，放在page外面，要全局变量，不然你在页面加载之后，在动态修改图表数据的话，没法修改，这样方便点）， 然后在data中初始化echats对象 ecLine，名字随便起，按照官方写法即可，onInit函数中参数有三个，canvas, width, height，这些都不需要管，直接初始化echats元素。复制粘贴即可。 let chartLine; Page({ data: { ecLine: { onInit: function (canvas, width, height){ //初始化echarts元素，绑定到全局变量，方便更改数据 chartLine = echarts.init(canvas, null, { width: width, height: height }); canvas.setChart(chartLine); //可以先不setOption，等数据加载好后赋值， //不过那样没setOption前，echats元素是一片空白，体验不好，所有我先set。 var xData = [1,2,3,4,5......]; // x轴数据 自己写 var option = getOption(xData); chartLine.setOption(option); } } } }) 然后将建立的echats对象绑定到echarts元素中，如下： &lt;view class=\"echart_panel\"> &lt;ec-canvas ec=\"{{ ecLine }}\">&lt;/ec-canvas> &lt;/view> 然后就可以在数据加载后，给图表赋值option了，或者是重新setOption的数据。 //ajax请求好数据后，调用获取option函数，传一些数据， //然后用全局变量echarts元素chartLine 来 setOption即可。 // 三个参数： x轴数据，第一条线数据，第二条数据。 随意，echarts就跟正常用随便写就行 // 随便写几个假数据 var xData=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]; var data_cur=[55,67,66,78,55,67,66,78,55,67,66,78,55,67,66,78,55,67,66,78,65,66,65,54]; var data_his=[67,66,78,65,66,65,54,67,66,78,65,66,65,54,67,66,78,65,66,65,54,67,66,78]; // 方法一： var option = getOption(xData, data_cur, data_his); chartLine.setOption(option); // 方法二： //如果上面初始化时候，已经chartLine已经setOption了， //那么建议不要重新setOption，官方推荐写法，重新赋数据即可。 chartLine.setOption({ xAxis: { data: xData }, series: [{ data: data_cur }, { data: data_his }] }); 效果如下： 示例写的折线图，其他类型图表，可以参考echarts官网文档即可。 因为从github下载的echarts.js包含类型比较多，如果上传代码进行发布时，提示echarts文件过大，可以忽略。 或者是自己重新下载echarts定制需要的组件，如我就需要折线图，我就定制带折线图的即可。然后直接替换文件夹中的echarts.js即可。 下载定制echarts官网链接：http://echarts.baidu.com/builder.html 五、上传、发布 小程序打包发布等都很简单,流程： 从微信开发工具上面上传代码到微信公众平台 使用小程序账号登录，进入管理-版本管理，选择发布 正式版、体验版 既可。 配置域名 登录微信公众平台-点击开发管理-开发设置，往下拉进去配置合法域名 上传 发布 进入管理-版本管理，选择刚才提交的版本，点击提交审核发布既可，或者点击小三角，选择选为体验版。 六、小程序开发技术选型（不限于微信小程序） 原生开发 使用小程序原生开发，很方便，官方提供了非常详细的组件、API等，文档也很丰富，开发者社区等。 优点 官方文档清晰明了，更接近手机服务的底层逻辑，开发者可以更有针对性的对小程序进行深度开发 小程序原生平台社区更加活跃 使用原生开发可以紧随官方的版本，更新响应速度快，让项目达到最优状态 完美适配，不会出现适配问题 原生开发的功能更加完善，可以优秀的调用小程序API使用手机各种功能 缺点 仅适用于单个平台的小程序 开发成本高，开发不同平台下的小程序，需要不同的开发工具及语法 维护成本高，同样的项目需要写多套代码，后期维护起来工作量大成本高， 原生组件样式不太美观，需要专门写css美化 uni-app uniapp是跨端的快速开发工具，当前支持微信小程序、百度小程序、头条小程序、qq小程序等14个平台，一套代码适应多个平台。 支持原生代码混写和原生sdk集成，通过条件编译+平台特有API调用，可以优雅的为某平台写个性化代码，调用专有能力而不影响其他平台。 优点 多端开发，一套代码可打包超多个不同平台，生成各种小程序H5及APP应用，不需来回切换各种开发工具 学习成本低，uni-app基于通用的前端技术栈，采用vue语法+微信小程序api，无额外学习成本 插件市场， uni-app拥有上千款的插件，支持NPM、支持平台小程序组件和SDK 组件丰富，样式漂亮 微信小程序依赖于微信的一键登录非常方便，uniapp不但能使用微信登录，而且还有一套自己的用户管理系统 缺点 完善性差，uni-app问世的时间还比较短，坑多，不过官方版本更新活跃，相信这些问题逐渐都会得到解决 兼容问题，uni-app打包出来的小程序可能会存在平台兼容问题，同样的代码会在不同平台下存在差异，如微信小程序、支付宝小程序。 如更新不及时，就不能紧随平台小程序，使用不了小程序平台发布的新功能 文档比较松散，社区质量不如小程序平台 其他类似uni-app的框架 taro、yonbuilder 总结 项目只做单平台的小程序，原生是最优的选择 项目同时开发多平台小程序，使用uni-app最优选择","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://liaoxingwang.github.io/categories/微信小程序/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://liaoxingwang.github.io/tags/微信小程序/"}],"author":"廖兴旺"},{"title":"Nginx安装和配置文件讲解","slug":"Blog-Open-Source-Nginx environment","date":"2023-03-23T09:20:00.000Z","updated":"2024-12-19T06:53:09.544Z","comments":true,"path":"2023/03/23/blog-open-source-nginx-environment/","link":"","permalink":"https://liaoxingwang.github.io/2023/03/23/blog-open-source-nginx-environment/","excerpt":"","text":"Nginx安装和配置文件讲解第一步：下载nginx压缩包可以到官方网站下载安装包也可以通过wget命令下载。 wget -c http://nginx.org/download/nginx-1.17.5.tar.gz 备注：一般会把压缩包放在/usr/local 下 第二步：配置nginx安装所需的环境1.安装gcc安装nginx需要先将源码进行编译，编译需要依赖gcc环境 yum install gcc-c++2.安装PCRE pcre-develNginx的Rewrite模块和HTTP核心模块会使用到PCRE正则表达式语法。这里需要安装两个安装包pcre和pcre-devel。第一个安装包提供编译版本的库，而第二个提供开发阶段的头文件和编译项目的源代码。 yum install -y pcre pcre-devel3.安装zlibzlib库提供了开发人员的压缩算法，在Nginx的各种模块中需要使用gzip压缩。 yum install -y zlib zlib-devel4.安装Open SSLnginx不仅支持 http协议，还支持 https（即在 ssl 协议上传输 http），如果使用了 https，需要安装 OpenSSL 库。 yum install -y openssl openssl-devel第三步：解压nginx压缩包并安装解压 nginx-1.17.5.tar.gz tar -zxvf nginx-1.17.5.tar.gz解压之后，进入加压文件` `然后进行配置，推荐使用默认配置。 命令如下 cd nginx-1.17.5 ./configure （指定目录）第四步：编译安装nginx进入目录 /usr/local/nginx-1.17.5 进行编译 make如果编译出错，请检查是否前面的4个安装都没有问题。` `编译成功之后，就可以安装了 make install第五步：启动nginx启动nginx /usr/local/nginx/sbin/nginx 或者 ./nginx 停止nginx /usr/local/nginx/sbin/nginx -s stop 或者 ./nginx -s stop 重新加载 /usr/local/nginx/sbin/nginx -s reload 或者 ./nginx -s reload 测试检查配置文件 /usr/local/nginx/sbin/nginx -t 或者 ./nginx -tnginx配置文件详解1.nginx文件结构... #全局块 events { #events块 ... } http #http块 { ... #http全局块 server #server块 { ... #server全局块 location [PATTERN] #location块 { ... } location [PATTERN] { ... } } server { ... } ... #http全局块 }1、全局块：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。2、events块：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。3、http块：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。4、server块：配置虚拟主机的相关参数，一个http中可以有多个server。5、location块：配置请求的路由，以及各种页面的处理情况。 2.nginx配置详解#定义Nginx运行的用户和用户组 user www www; # #nginx进程数,建议设置为等于CPU总核心数. worker_processes 8; # #全局错误日志定义类型,[ debug | info | notice | warn | error | crit ] error_log /var/log/nginx/error.log info; # #进程文件 pid /var/run/nginx.pid; # #一个nginx进程打开的最多文件描述符数目,理论值应该是最多打开文件数（系统的值ulimit -n）与nginx进程数相除,但是nginx分配请求并不均匀,所以建议与ulimit -n的值保持一致. worker_rlimit_nofile 65535; # #工作模式与连接数上限 events { #参考事件模型,use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型,如果跑在FreeBSD上面,就用kqueue模型. use epoll; #单个进程最大连接数（最大连接数=连接数*进程数） worker_connections 1024; #最大连接数，默认为512 } # #设定http服务器 http { include mime.types; #文件扩展名与文件类型映射表 default_type application/octet-stream; #默认文件类型 #charset utf-8; #默认编码 server_names_hash_bucket_size 128; #服务器名字的hash表大小 client_header_buffer_size 32k; #上传文件大小限制 large_client_header_buffers 4 64k; #设定请求缓 client_max_body_size 8m; #设定请求缓 keepalive_timeout 65; #连接超时时间，默认为75s，可以在http，server，location块。 # 开启目录列表访问,合适下载服务器,默认关闭. autoindex on; # 显示目录 autoindex_exact_size on; # 显示文件大小 默认为on,显示出文件的确切大小,单位是bytes 改为off后,显示出文件的大概大小,单位是kB或者MB或者GB autoindex_localtime on; # 显示文件时间 默认为off,显示的文件时间为GMT时间 改为on后,显示的文件时间为文件的服务器时间 sendfile on; # 开启高效文件传输模式,sendfile指令指定nginx是否调用sendfile函数来输出文件,对于普通应用设为 on,如果用来进行下载等应用磁盘IO重负载应用,可设置为off,以平衡磁盘与网络I/O处理速度,降低系统的负载.注意：如果图片显示不正常把这个改成off. tcp_nopush on; # 防止网络阻塞 tcp_nodelay on; # 防止网络阻塞 # FastCGI相关参数是为了改善网站的性能：减少资源占用,提高访问速度.下面参数看字面意思都能理解. fastcgi_connect_timeout 300; ## 链接 fastcgi_send_timeout 300; ##读取 是指nginx进程向fastcgi进程发送request的整个过程的超时时间 fastcgi_read_timeout 300; ##发请求 是指fastcgi进程向nginx进程发送response的整个过程的超时时间 fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 128k; # gzip模块设置 gzip on; #开启gzip压缩输出 gzip_min_length 1k; #允许压缩的页面的最小字节数,页面字节数从header偷得content-length中获取.默认是0,不管页面多大都进行压缩.建议设置成大于1k的字节数,小于1k可能会越压越大 gzip_buffers 4 16k; #表示申请4个单位为16k的内存作为压缩结果流缓存,默认值是申请与原始数据大小相同的内存空间来存储gzip压缩结果 gzip_http_version 1.1; #压缩版本（默认1.1,目前大部分浏览器已经支持gzip解压.前端如果是squid2.5请使用1.0） gzip_comp_level 2; #压缩等级.1压缩比最小,处理速度快.9压缩比最大,比较消耗cpu资源,处理速度最慢,但是因为压缩比最大,所以包最小,传输速度快 gzip_types text/plain application/x-javascript text/css application/xml; #压缩类型,默认就已经包含text/html,所以下面就不用再写了,写上去也不会有问题,但是会有一个warn. gzip_vary on;#选项可以让前端的缓存服务器缓存经过gzip压缩的页面.例如:用squid缓存经过nginx压缩的数据 #开启限制IP连接数的时候需要使用 #limit_zone crawler $binary_remote_addr 10m; ##upstream的负载均衡,四种调度算法(下例主讲)## #虚拟主机的配置 server { # 监听端口 listen 80; # 域名可以有多个,用空格隔开 server_name 127.0.0.1; # HTTP 自动跳转 HTTPS rewrite ^(.*) https://www.baidu.com; deny 127.0.0.1; #拒绝的ip allow 172.18.5.54; #允许的ip } upstream myserver { server 127.0.0.1:8080; server 192.168.24.189:8080 backup; #热备 } server { # 监听端口 HTTPS listen 443 ssl; server_name https://www.baidu.com; root /data/www/; # 配置域名证书 ssl_certificate C:\\WebServer\\Certs\\certificate.crt; ssl_certificate_key C:\\WebServer\\Certs\\private.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_protocols SSLv2 SSLv3 TLSv1; ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP; ssl_prefer_server_ciphers on; index index.html index.htm index.php; location ~ .*\\.(php|php5)?$ { fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi.conf; } # 配置地址拦截转发，解决跨域验证问题 location /oauth/{ proxy_pass https://localhost:13580/oauth/; proxy_set_header HOST $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } # 图片缓存时间设置 location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ { expires 10d; } # JS和CSS缓存时间设置 location ~ .*\\.(js|css)?$ { expires 1h; } # 日志格式设定 log_format access &#39;$server_name $remote_addr -$remote_user [$time_local] &quot;$request&quot;&#39; &#39;$status $uptream_status $body_bytes_sent &quot;$http_referer&quot;&#39; &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot; &#39; &#39;$ssl_protocol $ssl_cipher $upstream_addr $request_time $upstream_response_time&#39;; # 定义本虚拟主机的访问日志 access_log /var/log/nginx/access.log access; # 设定查看Nginx状态的地址.StubStatus模块能够获取Nginx自上次启动以来的工作状态，此模块非核心模块，需要在Nginx编译安装时手工指定才能使用 location /NginxStatus { stub_status on; access_log on; auth_basic &quot;NginxStatus&quot;; auth_basic_user_file conf/htpasswd; #htpasswd文件的内容可以用apache提供的htpasswd工具来产生. } } }1.与remoteaddr与http_x_forwarded_for 用以记录客户端的ip地址；2.$remote_user ：用来记录客户端用户名称；3.$time_local ： 用来记录访问时间与时区；4.$request ： 用来记录请求的url与http协议；5.$status ： 用来记录请求状态；成功是200，6.$body_bytes_s ent ：记录发送给客户端文件主体内容大小；7.$http_referer ：用来记录从那个页面链接访问过来的；8.$http_user_agent ：记录客户端浏览器的相关信息；9.惊群现象：一个网路连接到来，多个睡眠的进程被同事叫醒，但只有一个进程能获得链接，这样会影响系统性能。10.每个指令必须有分号结束。 nginx配置nginx是一个功能非常强大的web服务器加反向代理服务器，同时又是邮件服务器等等 在项目使用中，使用最多的三个核心功能是反向代理、负载均衡和静态服务器 这三个不同的功能的使用，都跟nginx的配置密切相关，nginx服务器的配置信息主要集中在nginx.conf这个配置文件中，并且所有的可配置选项大致分为以下几个部分 main # 全局配置 events { # nginx工作模式配置 } http { # http设置 .... server { # 服务器主机配置 .... location { # 路由配置 .... } location path { .... } location otherpath { .... } } server { .... location { .... } } upstream name { # 负载均衡配置 .... } }如上述配置文件所示，主要由6个部分组成： main：用于进行nginx全局信息的配置 events：用于nginx工作模式的配置 http：用于进行http协议信息的一些配置 server：用于进行服务器访问信息的配置 location：用于进行访问路由的配置 upstream：用于进行负载均衡的配置 main模块观察下面的配置代码 # user nobody nobody; worker_processes 2; # error_log logs/error.log # error_log logs/error.log notice # error_log logs/error.log info # pid logs/nginx.pid worker_rlimit_nofile 1024;上述配置都是存放在main全局配置模块中的配置项 user用来指定nginx worker进程运行用户以及用户组，默认nobody账号运行 worker_processes指定nginx要开启的子进程数量，运行过程中监控每个进程消耗内存(一般几M~几十M不等)根据实际情况进行调整，通常数量是CPU内核数量的整数倍 error_log定义错误日志文件的位置及输出级别【debug / info / notice / warn / error / crit】 pid用来指定进程id的存储文件的位置 worker_rlimit_nofile用于指定一个进程可以打开最多文件数量的描述 event 模块上干货 event { worker_connections 1024; multi_accept on; use epoll; }上述配置是针对nginx服务器的工作模式的一些操作配置 worker_connections 指定最大可以同时接收的连接数量，这里一定要注意，最大连接数量是和worker processes共同决定的。 multi_accept 配置指定nginx在收到一个新连接通知后尽可能多的接受更多的连接 use epoll 配置指定了线程轮询的方法，如果是linux2.6+，使用epoll，如果是BSD如Mac请使用Kqueue server模块srever模块配置是http模块中的一个子模块，用来定义一个虚拟访问主机，也就是一个虚拟服务器的配置信息 server { listen 80; server_name localhost 192.168.1.100; root /nginx/www; index index.php index.html index.html; charset utf-8; access_log logs/access.log; error_log logs/error.log; ...... }核心配置信息如下： server：一个虚拟主机的配置，一个http中可以配置多个server server_name：用力啊指定ip地址或者域名，多个配置之间用空格分隔 root：表示整个server虚拟主机内的根目录，所有当前主机中web项目的根目录 index：用户访问web网站时的全局首页 charset：用于设置www/路径中配置的网页的默认编码格式 access_log：用于指定该虚拟主机服务器中的访问记录日志存放路径 error_log：用于指定该虚拟主机服务器中访问错误日志的存放路径 location模块location模块是nginx配置中出现最多的一个配置，主要用于配置路由访问信息 在路由访问信息配置中关联到反向代理、负载均衡等等各项功能，所以location模块也是一个非常重要的配置模块 基本配置 location / { root /nginx/www; index index.php index.html index.htm; }location /：表示匹配访问根目录 root：用于指定访问根目录时，访问虚拟主机的web目录 index：在不指定访问具体资源时，默认展示的资源文件列表 反向代理配置方式 通过反向代理代理服务器访问模式，通过proxy_set配置让客户端访问透明化 location / { proxy_pass http://localhost:8888; proxy_set_header X-real-ip $remote_addr; proxy_set_header Host $http_host; }uwsgi配置 wsgi模式下的服务器配置访问方式 location / { include uwsgi_params; uwsgi_pass localhost:8888 }upstream模块upstream模块主要负责负载均衡的配置，通过默认的轮询调度方式来分发请求到后端服务器 简单的配置方式如下 upstream name { ip_hash; server 192.168.1.100:8000; server 192.168.1.100:8001 down; server 192.168.1.100:8002 max_fails=3; server 192.168.1.100:8003 fail_timeout=20s; server 192.168.1.100:8004 max_fails=3 fail_timeout=20s; }核心配置信息如下 ip_hash：指定请求调度算法，默认是weight权重轮询调度，可以指定 server host:port：分发服务器的列表配置 – down：表示该主机暂停服务 – max_fails：表示失败最大次数，超过失败最大次数暂停服务 – fail_timeout：表示如果请求受理失败，暂停指定的时间之后重新发起请求 ​ 持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】笑～","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://liaoxingwang.github.io/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://liaoxingwang.github.io/tags/Nginx/"}],"author":"廖兴旺"},{"title":"Java学习之Java环境配置","slug":"Blog-Open-Source-Java environment","date":"2023-03-22T09:20:00.000Z","updated":"2024-12-19T06:53:09.541Z","comments":true,"path":"2023/03/22/blog-open-source-java-environment/","link":"","permalink":"https://liaoxingwang.github.io/2023/03/22/blog-open-source-java-environment/","excerpt":"","text":"Java学习笔记之Java环境配置1. 配置Path环境变量计算机右键属性—高级系统设置—环境变量; 新建，添加变量名 JAVA_HOME ，变量值为之前自己jdk的安装路径，如下： C:\\Program Files\\Java\\jdk1.8.0_181 系统环境变量新建CLASSPATH环境变量新建，添加变量名 CLASSPATH ，变量值为： .;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar 或者 .;%JAVA_HOME%\\lib 我试过两个都可以，所以二选一，注意不要忘记前面的点和中间的分号。点击“确定“，如图所示： 编辑Path变量找到系统变量里变量为Path的行，选中，并点击编辑，追加如下： %JAVA_HOME%\\bin 检测JDK环境变量是否配置成功使用快捷键win+R，在弹出的运行命令窗口输入CMD回车运行，光标后输入java，然后回车，看到如下图所示，表示环境变量安装成功。 2. Java程序开发运行流程开发Java程序，需要三个步骤：编写程序，编译程序，运行程序。 3. HelloWorldpublic class HelloWorld { public static void main(String[] args) { System.out.println(&quot;HelloWorld&quot;); } }","categories":[{"name":"Java","slug":"Java","permalink":"https://liaoxingwang.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://liaoxingwang.github.io/tags/Java/"}],"author":"廖兴旺"},{"title":"专业团队高效接单","slug":"Blog-Open-Source","date":"2020-11-21T09:20:00.000Z","updated":"2024-12-19T06:53:09.548Z","comments":true,"path":"2020/11/21/blog-open-source/","link":"","permalink":"https://liaoxingwang.github.io/2020/11/21/blog-open-source/","excerpt":"","text":"团队介绍滴滴滴，接单啦接单啦欢迎各位老板咨询18124777246 服务包括管理系统，小程序，APP，优质课程讲解等都可以找我哦，质量保证，服务态度超好，售后服务一级棒 我们的优势： 6年Java开发经验，有带领团队经验，良好的售后服务，有团队可整包开发，对待项目认真负责能按时交付，在项目开发过程中积极与用户对接，质量保证，时间效率高，解决问题能力强。经验丰富、认真细致、责任心强！ 服务前需客户提供的信息：• 需求文档，需求功能的确定• 双方确定开发周期，合理安排时间• 项目git地址，以及权限开通，若无我们可提供 我们能做的事情• 整包服务(只需沟通需求，或文档若无我们可以代写文档)• 前后端(Java，vue，React，Angular)课程辅导，面试辅导• 后台管理系统开发• 物联网平台开发• 数据API开发• 毕业设计整套开发• 微信公众号开发• 微信小程序开发• PC网站官网开发• H5移动端开发• 大学算法课程• 面试代做答疑助攻• 前端官网整套服务• 商单• 毕设• 面试辅助答疑• 算法课程讲解• 其他业务正扩展中敬请期待 团队人员 角色 开发职位 负责人 高级Java开发 队员 前端工程师(5人) 队员 后端工程师(5人) 队员 测试工程师(2人) 队员 Android工程师(2人) 队员 iOS工程师(2人) 后端包含的工作：1、需求分析讨论或腾讯会议沟通2、技术选型，框架搭建接口实现3、数据库表设计，设计文档4、接口文档产出5、接口对接，问题记录修复6、项目部署上线 前端包含的工作：1、开需求评审会，讨论相关需求，并提出自己的相关看法2、前端技术选型，搭建基本架构3、前端静态页面实现4、模拟接口进行交互调整5、对接后台接口，完成功能6、项目自测并分析项目可优化点7、接口文档产出8、操作手册编写 前端技术能力* 框架 1. vue2 2. vue2+nuxt.js 3. vue3 4. react 5. jquery * 多端框架 1. uni-app 2. Taro 3. ui库 4. element-ui 5. element-plus 6. Ant Design 7. vant 8. layui * 第三方库 1. axios 2. echarts 3. qrcodejs2 4. html2canvas 5. bootstrap * 其他 1. es6 2. webpack 3. vite 持续更新… 后端技术能力1、熟悉 Java 语法，多线程、集合等基础框架,熟练掌握Spring,SpringMVC，Mybatis,SpringBoot等开源技术，以及 Gradle、Maven 等项目,并能熟练搭建整合SSM框架，进行 Junit，Debug测试以及热部署。2、熟练掌握常见的开发工具Eclipse，IDEA，并能熟练使用常见的项目构建工具maven构建项目, 熟悉分布式 的Git协同开发工具。3、熟练掌握Mysql数据库。熟悉常见的Sql优化，熟悉Mysql 的读写分离，Mycat分库分表和Linux系统下 的环境搭建。4、熟悉Redis非关系型数据库，熟悉Redis的高可用架构，了解缓存雪崩和穿透等解决方案，知道如何保证缓 存数据库双写时的数据一致性。5、熟悉Shiro，Spring Security，Sa-Token认证授权框架，Quartz定时工具以及利用Echarts实现数据可视化。6、熟悉Solr的全文搜索引擎，FastDFS分布式文件等。7、熟悉Linux操作系统的常用命令以及Nginx，ZooKeeper，Redis的集群环境搭建，熟悉应用服务器软件 Tomcat 等容器配置和部署。8、熟练掌握基于RPC的Dubbo，WebService技术，熟悉网络编程，mqtt，Websocket，modbus，tcp协议开发，熟悉物联网项目开发，终端设备接入，LoRa，Bluetooth数据对接。9、熟练使用ZooKeeper分布式协调工具，了解其集群管理，配置管理以及分布式锁的应用。10、熟悉kafak，RabbitMQ，RocketMQ等消息中间件，了解如何保证消息中间件的高可用以及消息的可靠传输和顺序 性问题。利用 MQ 做异步处理，削峰填谷。11、熟悉JVM体系结构与GC优化对,JVM 原理深刻理解，包括内存模型、垃圾回收机制等。12、熟练运用springBoot，springClood、dubbo 以及springcloud alibaba等主流框架。13、熟练使用构建容器有jenkins、docker、k8s、rancher 经验部署。 项目经验以下项目都为真实项目，可体验1.DC农业官网 https://www.idianchou.com/前端技术栈：vue2+nuxt.js+element-ui+echarts+axios+postcss-px2rem 2.供应商发票系统 http://zsc.dianchoutest.com:10086/login前端技术栈：react+redux+antd+axios后端技术栈：SpingCloud+SpringSecurity +Kafka +MySQL +Redis 3.供应商小程序 #小程序://DC供应商端/lL8Wtd3ldbuRhgH前端技术栈：微信原生小程序+flyio.js 4.dch5 http://zsc.dianchoutest.com前端技术栈:vue2+vant+qrcodejs2+html2canvas+axios+echarts 5.蔬东坡DC后台管理http://zsc.dianchoutest.com:9050/#/login前端技术栈:vue3+vuex+postcss-pxtorem+element-plus+axios+ts后端技术栈：SpingCloud+SpringSecurity +MySQL+ Kafka +Redis 6.智农宁津管理后台 http://zsc.dianchoutest.com:9060/#/login前端技术栈：vite+vue3+ts+element-plus+pinia+axios+eslint+husky+lint-staged后端技术栈：SpingCloud+SpringSecurity +MySQL +Redis 7.智农宁津 小程序://智农宁津/dabZgAIqbqA5XUk 8.DC严选批发 #小程序://DC严选批发/wiGGRkzduyc1tro 9.DC云菜篮 #小程序://DC云菜篮/BhPr6pG95sY562y 10.DC餐单 #小程序://DC餐单/AFTxFWDy1EHza7u 11.DC生鲜 #小程序://DC生鲜/OgfRQeruyHHs1OI 12.DC精品水果批发 #小程序://DC精品水果批发/NorNX8c4IjfsPiH 13.DC小掌柜 14.读行网15.山海秀16.读行网后台管理系统 17.鑫宝体育前端技术栈：vite+vue3+ts+element-plus+pinia+axios+eslint+husky+lint-staged+ Nuxt后端技术栈：Spring、SpringMVC +SpingCloud+阿里云PolarDB +Redis+ Nginx18.鑫宝体育ssr19.鑫宝体育后台管理系统20.鑫宝体育H521.鑫宝体育小程序 22.南山课后服务23.中启教育后台管理系统24.四点半小程序 25.找礼品网 PC（SSR）、找礼品网 PC、集团商城 PC前端技术栈：vue2 + Nuxt.js + echarts+rerender-spa-plugin+vue-meta-info+vue-cropper+QRCode.js后端技术栈：SpingCloud+ SpringSecurity oauth2+MySQL +Redis+ Nginx 26.找礼品网移动端、集团商城 移动端前端技术栈：vue2 + vuex + axios + echart后端技术栈：SpingCloud+ SpringSecurity oauth2+MySQL+ RabbitMQ +Redis+ Nginx 27.艾象商城微信小程序、艾象商城百度小程序、艾象集采微信小程序前端技术栈：uni-app+vant后端技术栈：SpingCloud+ SpringSecurity oauth2+MySQL+ RabbitMQ +Redis+ Nginx 28.云通讯BOSS平台、云通讯EMS平台、中行企业短信平台、聚信通讯信息平台、川航短信平台、东莞证券短信平台前端技术栈：vue2+Element-ui+vuedraggable+mavonEditor+Export2Excel+echarts后端技术栈：SpingCloud+ SpringSecurity oauth2+MySQL + RabbitMQ +Redis+ Nginx 29.EMS信息监控大屏前端技术栈：websocket+Echarts+i18n+webpack+vue2+Element-ui后端技术栈：SpingCloud+ SpringSecurity oauth2+MySQL +Redis+ Nginx 30.易顺云企业管理系统前端技术栈：vue2 + element ui + echarts后端技术栈：SpingCloud+ SpringSecurity oauth2+MySQL +Redis+ Nginx 31.深圳市城市轨道交通CLC二期系统前端技术栈：vue3 + typeScript + antdVue ui + echart后端技术栈：SpingCloud+MySQL +Redis+ Nginx 32.天津四号线运营管理系统前端技术栈：react + antd后端技术栈：SpingCloud+MySQL +Redis+ RabbitMQ+ Maven + Nginx 33.九彩育儿(微信小程序) 持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】笑～","categories":[{"name":"高效接单","slug":"高效接单","permalink":"https://liaoxingwang.github.io/categories/高效接单/"}],"tags":[{"name":"高效接单","slug":"高效接单","permalink":"https://liaoxingwang.github.io/tags/高效接单/"}],"author":"廖兴旺"}],"categories":[{"name":"Java","slug":"Java","permalink":"https://liaoxingwang.github.io/categories/Java/"},{"name":"MySql","slug":"MySql","permalink":"https://liaoxingwang.github.io/categories/MySql/"},{"name":"Git","slug":"Git","permalink":"https://liaoxingwang.github.io/categories/Git/"},{"name":"MyBatis-Plus","slug":"MyBatis-Plus","permalink":"https://liaoxingwang.github.io/categories/MyBatis-Plus/"},{"name":"Linux","slug":"Linux","permalink":"https://liaoxingwang.github.io/categories/Linux/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://liaoxingwang.github.io/categories/微信小程序/"},{"name":"Nginx","slug":"Nginx","permalink":"https://liaoxingwang.github.io/categories/Nginx/"},{"name":"高效接单","slug":"高效接单","permalink":"https://liaoxingwang.github.io/categories/高效接单/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://liaoxingwang.github.io/tags/Java/"},{"name":"MySql","slug":"MySql","permalink":"https://liaoxingwang.github.io/tags/MySql/"},{"name":"Git","slug":"Git","permalink":"https://liaoxingwang.github.io/tags/Git/"},{"name":"MyBatis-Plus","slug":"MyBatis-Plus","permalink":"https://liaoxingwang.github.io/tags/MyBatis-Plus/"},{"name":"Linux","slug":"Linux","permalink":"https://liaoxingwang.github.io/tags/Linux/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://liaoxingwang.github.io/tags/微信小程序/"},{"name":"Nginx","slug":"Nginx","permalink":"https://liaoxingwang.github.io/tags/Nginx/"},{"name":"高效接单","slug":"高效接单","permalink":"https://liaoxingwang.github.io/tags/高效接单/"}]}